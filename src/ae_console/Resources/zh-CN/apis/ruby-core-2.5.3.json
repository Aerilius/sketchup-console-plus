{"Array": {"description": "数组是任何对象的有序、索引为整数的集合。\\n n数组索引从0开始，如在C或Java中。假定负索引是相对于数组结尾的，也就是说，索引-1表示数组的最后一个元素，-2是数组中最后一个元素的下一个元素，依此类推。\\n \\n==正在创建数组\\n \\n可以使用literal构造函数<code>[]</code>创建新数组。数组可以包含不同类型的对象。例如，下面的数组包含一个整数、一个字符串和一个浮点值：\\n \n   ary = [1, \"two\", 3.0] #=> [1, \"two\", 3.0]\n\\n还可以通过使用零、一个（数组的初始大小）或两个参数（初始大小和默认对象）显式调用Array.new来创建数组。\\n \n   ary = Array.new    #=> []\n   Array.new(3)       #=> [nil, nil, nil]\n   Array.new(3, true) #=> [true, true, true]\n \\n请注意，第二个参数用对同一对象的引用填充数组。因此，只有在需要用本机不变的对象（如符号、数字、真或假）实例化数组时，才建议使用这种方法。\\n \\n若要使用单独的对象创建数组，可以改为传递块。\\n此方法可以安全地与可变对象（如哈希、字符串或其他数组）一起使用：\\n \n   Array.new(4) { Hash.new }  #=> [{}, {}, {}, {}]\n   Array.new(4) {|i| i.to_s } #=> [\"0\", \"1\", \"2\", \"3\"]\n \\n这也是一种快速建立多维数组的方法：\\n \n   empty_table = Array.new(3) { Array.new(3) }\n   #=> [[nil, nil, nil], [nil, nil, nil], [nil, nil, nil]]\n \\n还可以使用内核提供的array（）方法创建数组，该方法尝试调用to35y，然后to_u a on其参数。\\n \\n Array({:a => \"a\", :b => \"b\"}) #=> [[:a, \"a\"], [:b, \"b\"]] \\n \\n==示例用法\\n \\n除了通过可枚举模块混合的方法外，array类还具有访问、搜索和以其他方式操作数组的专有方法。\\n \\n一些更常见的示例如下所示。\\n \\n==访问元素\\n \\n可以使用array[]方法检索数组中的元素。它可以接受一个整数参数（数字索引）、一对参数（起始和长度）或一个范围。负索引从结尾开始计数，其中-1是最后一个元素。\\n \n   arr = [1, 2, 3, 4, 5, 6]\n   arr[2]    #=> 3\n   arr[100]  #=> nil\n   arr[-3]   #=> 4\n   arr[2, 3] #=> [3, 4, 5]\n   arr[1..4] #=> [2, 3, 4, 5]\n   arr[1..-3] #=> [2, 3, 4]\n \\n访问特定数组元素的另一种方法是使用at方法\n   arr.at(0) #=> 1\n \\n #slice方法的工作方式与数组[]相同。\\n \\n若要对数组边界之外的索引引发错误，或者在发生这种情况时提供默认值，可以使用fetch。\\n \n   arr = ['a', 'b', 'c', 'd', 'e', 'f']\n   arr.fetch(100) #=> IndexError: index 100 outside of array bounds: -6...6\n   arr.fetch(100, \"oops\") #=> \"oops\"\n \\n special方法first和last将分别返回数组的第一个和最后一个元素。\\n \n   arr.first #=> 1\n   arr.last  #=> 6\n \\n若要返回数组的前+n+个元素，请使用take \n   arr.take(3) #=> [1, 2, 3]\n \\n drop执行与take相反的操作，方法是在删除+n+个元素后返回元素：\\n \n   arr.drop(3) #=> [4, 5, 6]\n \\n==获取有关数组的信息\\n \\n数组始终跟踪其自身长度。要查询数组包含的元素数量，请使用length、count或size。\\n \n  browsers = ['Chrome', 'Firefox', 'Safari', 'Opera', 'IE']\n  browsers.length #=> 5\n  browsers.count #=> 5\n \\n若要检查数组是否包含任何元素，请执行以下操作：\n  browsers.empty? #=> false\n \\n若要检查数组\n  browsers.include?('Konqueror') #=> false\n中是否包含特定项，请执行以下操作：将项添加到数组中\\n \\n可以使用push或<\\n \n  arr = [1, 2, 3, 4]\n  arr.push(5) #=> [1, 2, 3, 4, 5]\n  arr << 6    #=> [1, 2, 3, 4, 5, 6]\n \\n unshift将向数组的开头添加新项。\\n \n   arr.unshift(0) #=> [0, 1, 2, 3, 4, 5, 6]\n \\n使用insert，您可以在任何位置向数组添加新元素。\\n \n   arr.insert(3, 'apple')  #=> [0, 1, 2, 'apple', 3, 4, 5, 6]\n \\n使用insert方法，您还可以一次插入多个值：\\n \n   arr.insert(3, 'orange', 'pear', 'grapefruit')\n   #=> [0, 1, 2, \"orange\", \"pear\", \"grapefruit\", \"apple\", 3, 4, 5, 6]\n \\n==从数组中删除项\\n \\n方法pop删除数组中的最后一个元素并返回它：\\n \n   arr =  [1, 2, 3, 4, 5, 6]\n   arr.pop #=> 6\n   arr #=> [1, 2, 3, 4, 5]\n \\n若要检索并同时删除第一个项，请使用shift:\\n \n   arr.shift #=> 1\n   arr #=> [2, 3, 4, 5]\n \\n删除特定索引中的元素：\\n\n   arr.delete_at(2) #=> 4\n   arr #=> [2, 3, 5]\n \\n要删除数组中的任何特定元素，请使用delete:\\n \n   arr = [1, 2, 2, 3]\n   arr.delete(2) #=> 2\n   arr #=> [1,3]\n \\n如果需要从数组中删除+nil+值，则使用一种有用的方法是\\n compact:\\n \n   arr = ['foo', 0, nil, 'bar', 7, 'baz', nil]\n   arr.compact  #=> ['foo', 0, 'bar', 7, 'baz']\n   arr          #=> ['foo', 0, nil, 'bar', 7, 'baz', nil]\n   arr.compact! #=> ['foo', 0, 'bar', 7, 'baz']\n   arr          #=> ['foo', 0, 'bar', 7, 'baz']\n \\n另一个常见的需要是从数组中删除重复元素。\\n \\n它具有非破坏性uniq和破坏性方法uniq！\\n \n   arr = [2, 5, 6, 556, 6, 6, 8, 9, 0, 123, 556]\n   arr.uniq #=> [2, 5, 6, 556, 8, 9, 0, 123]\n \\n==对数组进行迭代\\n \\n与包含可枚举模块的所有类一样，数组具有每个方法，该方法定义应迭代哪些元素以及如何迭代。对于数组的每个元素，数组实例中的所有元素都按顺序生成到提供的块中。\\n \\n请注意，此操作使数组保持不变。\\n \n   arr = [1, 2, 3, 4, 5]\n   arr.each { |a| print a -= 10, \" \" }\n   # prints: -9 -8 -7 -6 -5\n   #=> [1, 2, 3, 4, 5]\n \\n另一个有时有用的迭代器是reverse_，每个迭代器将以相反的顺序遍历数组中的元素。\\n \n   words = %w[first second third fourth fifth sixth]\n   str = \"\"\n   words.reverse_each { |word| str += \"#{word} \" }\n   p str #=> \"sixth fifth fourth third second first \"\n \\n #map方法可用于创建基于原始数组的新数组，但其值由所提供的块修改：\\n \n   arr.map { |a| 2*a }   #=> [2, 4, 6, 8, 10]\n   arr                   #=> [1, 2, 3, 4, 5]\n   arr.map! { |a| a**2 } #=> [1, 4, 9, 16, 25]\n   arr                   #=> [1, 4, 9, 16, 25]\n \\n==从数组中选择项\\n \\n可根据块中定义的条件从数组中选择元素。选择可以以破坏性或非破坏性的方式进行。虽然破坏性操作将修改它们被调用的数组，但非破坏性方法通常返回带有选定元素的新数组，但保持原始数组不变。\\n\\n==非目标", "name": "Array", "namespace": "", "path": "Array", "type": "class", "visibility": "public"}, "Array#&": {"description": "set intersection-返回一个包含两个数组共用的唯一元素的新数组。从原始数组中保留顺序。\\n \\n它使用元素的哈希和eql比较元素？提高效率的方法。\\n \n   [ 1, 1, 3, 5 ] & [ 3, 2, 1 ]                 #=> [ 1, 3 ]\n   [ 'a', 'b', 'b', 'z' ] & [ 'a', 'b', 'c' ]   #=> [ 'a', 'b' ]\n \\n另见数组uniq。", "name": "&", "namespace": "Array", "path": "Array#&", "type": "instance_method", "visibility": "public"}, "Array#*": {"description": "重复-使用字符串参数，相当于<code>ary.join(str)</code>。\\n \\n否则，返回通过连接+int+份+self+创建的新数组。\\n n \n   [ 1, 2, 3 ] * 3    #=> [ 1, 2, 3, 1, 2, 3, 1, 2, 3 ]\n   [ 1, 2, 3 ] * \",\"  #=> \"1,2,3\"", "name": "*", "namespace": "Array", "path": "Array#*", "type": "instance_method", "visibility": "public"}, "Array#+": {"description": "串联-返回通过将两个数组串联在一起生成第三个数组而生成的新数组。\\n \n   [ 1, 2, 3 ] + [ 4, 5 ]    #=> [ 1, 2, 3, 4, 5 ]\n   a = [ \"a\", \"b\", \"c\" ]\n   c = a + [ \"d\", \"e\", \"f\" ]\n   c                         #=> [ \"a\", \"b\", \"c\", \"d\", \"e\", \"f\" ]\n   a                         #=> [ \"a\", \"b\", \"c\" ]\n \\n注that\n   x += y\nis相同的as\n   x = x + y\nThis表示它生成一个新数组。因此，在阵列上重复使用<code>+=</code>会非常低效。\\n \\n另请参阅数组concat。", "name": "+", "namespace": "Array", "path": "Array#+", "type": "instance_method", "visibility": "public"}, "Array#-": {"description": "数组差异\\n \\n返回原始数组的副本的新数组，删除+other_ary+中也出现的任何项。从原始数组中保留顺序。\\n \\n它使用元素的哈希和eql比较元素？提高效率的方法。\\n \n   [ 1, 1, 2, 2, 3, 3, 4, 5 ] - [ 1, 2, 4 ]  #=>  [ 3, 3, 5 ]\n \\n如果需要类似设置的行为，请参阅库类集。", "name": "-", "namespace": "Array", "path": "Array#-", "type": "instance_method", "visibility": "public"}, "Array#<<": {"description": "附加-将给定对象推到此数组的末尾。此表达式返回数组本身，因此可以将多个附录链接在一起。n \n   a = [ 1, 2 ]\n   a << \"c\" << \"d\" << [ 3, 4 ]\n           #=>  [ 1, 2, \"c\", \"d\", [ 3, 4 ] ]\n   a\n           #=>  [ 1, 2, \"c\", \"d\", [ 3, 4 ] ]", "name": "<<", "namespace": "Array", "path": "Array#<<", "type": "instance_method", "visibility": "public"}, "Array#<=>": {"description": "比较-如果此数组小于、等于或大于+other_ary+，则返回整数（+-1+, +0+或<code>+1</code>）。\\n \\n比较每个数组中的每个对象（使用<=>运算符）。\\n \\n数组在“ELEMENT_WISE”manner;中进行比较。使用<=>运算符将+ary+的第一个元素与+other_ary+的第一个元素进行比较，然后\\n将第二个元素中的每个元素进行比较，等等…\\n只要任何此类比较的结果不是零（即两个对应的元素不相等），就会返回整个数组比较的结果。\\n \\n如果所有元素都相等，则结果基于数组长度的比较。因此，根据数组<=>if、\\n，两个数组是“相等的”，并且只有当它们具有相同的长度并且每个元素的值等于另一个数组中相应元素的值时，才是“相等的”。\\n \\n如果+other_ary+不是数组或两个元素的比较返回+nil+，则返回+nil+。n \n   [ \"a\", \"a\", \"c\" ]    <=> [ \"a\", \"b\", \"c\" ]   #=> -1\n   [ 1, 2, 3, 4, 5, 6 ] <=> [ 1, 2 ]            #=> +1\n   [ 1, 2 ]             <=> [ 1, :two ]         #=> nil", "name": "<=>", "namespace": "Array", "path": "Array#<=>", "type": "instance_method", "visibility": "public"}, "Array#==": {"description": "相等-如果两个数组包含相同数量的元素，并且每个元素等于（根据对象==）+other_ary+中的相应元素，则两个数组相等。n \n   [ \"a\", \"c\" ]    == [ \"a\", \"c\", 7 ]     #=> false\n   [ \"a\", \"c\", 7 ] == [ \"a\", \"c\", 7 ]     #=> true\n   [ \"a\", \"c\", 7 ] == [ \"a\", \"d\", \"f\" ]   #=> false", "name": "==", "namespace": "Array", "path": "Array#==", "type": "instance_method", "visibility": "public"}, "Array#[]": {"description": "元素引用-返回+index+处的元素，或返回从+start+索引开始并继续执行+length+元素的子数组，或返回由+range+个索引指定的子数组。\\n \\n负索引从数组结尾向后计数（-1是最后一个元素）。对于+start+和+range+情况，起始索引就在元素之前。此外，当元素范围的起始索引位于数组的末尾时，将返回空数组。\\n \\n如果索引（或起始索引）超出范围，则返回+nil+。n \n   a = [ \"a\", \"b\", \"c\", \"d\", \"e\" ]\n   a[2] +  a[0] + a[1]    #=> \"cab\"\n   a[6]                   #=> nil\n   a[1, 2]                #=> [ \"b\", \"c\" ]\n   a[1..3]                #=> [ \"b\", \"c\", \"d\" ]\n   a[4..7]                #=> [ \"e\" ]\n   a[6..10]               #=> nil\n   a[-3, 3]               #=> [ \"c\", \"d\", \"e\" ]\n   # special cases\n   a[5]                   #=> nil\n   a[6, 1]                #=> nil\n   a[5, 1]                #=> []\n   a[5..10]               #=> []", "name": "[]", "namespace": "Array", "path": "Array#[]", "type": "instance_method", "visibility": "public"}, "Array#[]=": {"description": "元素分配-将元素设置为+index+，或从+start+索引中替换+length+元素的子数组，或替换由+range+索引指定的子数组。\\n \\n如果索引大于数组的当前容量，则数组将自动增长。如果+length+为零，则元素将以+start+插入数组。\\n \\n负索引将从数组结尾倒数。对于+start+和+range+情况，起始索引就在元素之前。\\n \\n如果负索引点超过数组开头，则引发IndexError。\\n \\n另请参阅array push和array unshift。n \n   a = Array.new\n   a[4] = \"4\";                 #=> [nil, nil, nil, nil, \"4\"]\n   a[0, 3] = [ 'a', 'b', 'c' ] #=> [\"a\", \"b\", \"c\", nil, \"4\"]\n   a[1..2] = [ 1, 2 ]          #=> [\"a\", 1, 2, nil, \"4\"]\n   a[0, 2] = \"?\"               #=> [\"?\", 2, nil, \"4\"]\n   a[0..2] = \"A\"               #=> [\"A\", \"4\"]\n   a[-1]   = \"Z\"               #=> [\"A\", \"Z\"]\n   a[1..-1] = nil              #=> [\"A\", nil]\n   a[1..-1] = []               #=> [\"A\"]\n   a[0, 0] = [ 1, 2 ]          #=> [1, 2, \"A\"]\n   a[3, 0] = \"B\"               #=> [1, 2, \"A\", \"B\"]", "name": "[]=", "namespace": "Array", "path": "Array#[]=", "type": "instance_method", "visibility": "public"}, "Array#any?": {"description": "迭代弱引用对象中的键和对象", "name": "any?", "namespace": "Array", "path": "Array#any?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Array#append": {"description": "附加-将给定对象推到此数组的末尾。此表达式返回数组本身，因此可以将多个附录链接在一起。另请参见数组弹出以获得相反的效果。n \n   a = [ \"a\", \"b\", \"c\" ]\n   a.push(\"d\", \"e\", \"f\")\n           #=> [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"]\n   [1, 2, 3].push(4).push(5)\n           #=> [1, 2, 3, 4, 5]", "name": "append", "namespace": "Array", "path": "Array#append", "type": "instance_method", "visibility": "public"}, "Array#assoc": {"description": "搜索其元素也是数组的数组，将+obj+与使用<code>obj.==</code>的每个包含数组的第一个元素进行比较。\\n \\n返回第一个匹配的包含数组（即第一个关联数组），如果找不到匹配，则返回+nil+。\\n \\n另请参见数组rassoc \n   s1 = [ \"colors\", \"red\", \"blue\", \"green\" ]\n   s2 = [ \"letters\", \"a\", \"b\", \"c\" ]\n   s3 = \"foo\"\n   a  = [ s1, s2, s3 ]\n   a.assoc(\"letters\")  #=> [ \"letters\", \"a\", \"b\", \"c\" ]\n   a.assoc(\"foo\")      #=> nil", "name": "assoc", "namespace": "Array", "path": "Array#assoc", "type": "instance_method", "visibility": "public"}, "Array#at": {"description": "返回元素+index+。从+self+年底开始，指数为负。如果索引超出范围，则返回+nil+。另请参见数组[]。n \n   a = [ \"a\", \"b\", \"c\", \"d\", \"e\" ]\n   a.at(0)     #=> \"a\"\n   a.at(-1)    #=> \"e\"", "name": "at", "namespace": "Array", "path": "Array#at", "type": "instance_method", "visibility": "public"}, "Array#bsearch": {"description": "通过使用二进制搜索，从该数组中查找满足给定条件的值，其中n是数组的大小。\\n \\n您可以在两种模式下使用此方法：查找最小模式和查找任意模式。在这两种情况下，数组元素相对于块必须是单调的（或排序的）。\\n \\n在find minimum模式下（这是典型用例的一个好选择），\\n块必须始终返回true或false，并且必须有一个索引i（0<=i<=ary.size），以便：\\n \\n- 对于索引小于\n  i, and\n的任何元素，块返回false-对于索引为greater\n  than or equal to i.\n的任何元素，块返回true \\n此方法返回是第i个元素。如果i等于ary.size，则返回nil。\\n \n   ary = [0, 4, 7, 10, 12]\n   ary.bsearch {|x| x >=   4 } #=> 4\n   ary.bsearch {|x| x >=   6 } #=> 7\n   ary.bsearch {|x| x >=  -1 } #=> 0\n   ary.bsearch {|x| x >= 100 } #=> nil\n \\n在find any模式（其行为类似于libc的bsearch（3））中，块必须始终返回一个数字，并且必须有两个索引i和j \\n（0<=i<=j<=ary.size），以便：\\n \\n- 如果0<=k<i，块返回ary[k]的正数，如果i<=k<j，块返回ary[k]的零，并且\\n- 块返回负数nary[k]if\n  j <= k < ary.size.\n的编号\\n在此条件下，此方法返回索引在i…j内的任何元素。如果i等于j（即没有满足块的元素），则此方法返回nil。\\n \n   ary = [0, 4, 7, 10, 12]\n   # try to find v such that 4 <= v < 8\n   ary.bsearch {|x| 1 - x / 4 } #=> 4 or 7\n   # try to find v such that 8 <= v < 10\n   ary.bsearch {|x| 4 - x / 2 } #=> nil\n \\n您不能在time;中混合两种模式。块必须始终返回真/假，或始终返回数字。它未定义在每次迭代中实际获取的值。", "name": "bsearch", "namespace": "Array", "path": "Array#bsearch", "type": "instance_method", "visibility": "public"}, "Array#bsearch_index": {"description": "通过使用二进制搜索，从该数组中查找满足给定条件的值的索引，其中n是数组的大小。\\n \\n根据块的性质，它支持两种模式。它们与bsearch方法的情况完全相同，唯一的区别是此方法返回元素的索引，而不是元素本身。有关更多详细信息，请参阅bsearch的文档。", "name": "bsearch_index", "namespace": "Array", "path": "Array#bsearch_index", "type": "instance_method", "visibility": "public"}, "Array#clear": {"description": "从+self+中删除所有元素。n \n   a = [ \"a\", \"b\", \"c\", \"d\", \"e\" ]\n   a.clear    #=> [ ]", "name": "clear", "namespace": "Array", "path": "Array#clear", "type": "instance_method", "visibility": "public"}, "Array#collect": {"description": "为+self+的每个元素调用一次给定的块。\\n \\n建立包含区块传回值的新阵列。\\n \\n另请参见Enumerable Collect。\\n \\n如果没有给定块，则返回枚举器。n \n   a = [ \"a\", \"b\", \"c\", \"d\" ]\n   a.collect { |x| x + \"!\" }         #=> [\"a!\", \"b!\", \"c!\", \"d!\"]\n   a.map.with_index { |x, i| x * i } #=> [\"\", \"b\", \"cc\", \"ddd\"]\n   a                                 #=> [\"a\", \"b\", \"c\", \"d\"]", "name": "collect", "namespace": "Array", "path": "Array#collect", "type": "instance_method", "visibility": "public"}, "Array#collect!": {"description": "为+self+的每个元素调用一次给定的块，用块返回的值替换元素。\\n \\n另请参见Enumerable Collect。\\n \\n如果没有给定块，则返回枚举器。n \n   a = [ \"a\", \"b\", \"c\", \"d\" ]\n   a.map! {|x| x + \"!\" }\n   a #=>  [ \"a!\", \"b!\", \"c!\", \"d!\" ]\n   a.collect!.with_index {|x, i| x[0...i] }\n   a #=>  [\"\", \"b\", \"c!\", \"d!\"]", "name": "collect!", "namespace": "Array", "path": "Array#collect!", "type": "instance_method", "visibility": "public"}, "Array#combination": {"description": "当使用块调用时，从数组中生成长度为+n+的元素的所有组合，然后返回数组本身。\\n \\n实作无法保证组合产生的顺序。\\n \\n如果没有给定块，则返回枚举器。\\n \\n示例：\\n \n   a = [1, 2, 3, 4]\n   a.combination(1).to_a  #=> [[1],[2],[3],[4]]\n   a.combination(2).to_a  #=> [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]\n   a.combination(3).to_a  #=> [[1,2,3],[1,2,4],[1,3,4],[2,3,4]]\n   a.combination(4).to_a  #=> [[1,2,3,4]]\n   a.combination(0).to_a  #=> [[]] # one combination of length 0\n   a.combination(5).to_a  #=> []   # no combinations of length 5", "name": "combination", "namespace": "Array", "path": "Array#combination", "type": "instance_method", "visibility": "public"}, "Array#compact": {"description": "返回+self+的副本，删除所有+nil+元素。n \n   [ \"a\", nil, \"b\", nil, \"c\", nil ].compact\n                     #=> [ \"a\", \"b\", \"c\" ]", "name": "compact", "namespace": "Array", "path": "Array#compact", "type": "instance_method", "visibility": "public"}, "Array#compact!": {"description": "从数组中删除+nil+个元素。\\n \\n如果未做任何更改，则返回+nil+，否则返回数组。n \n   [ \"a\", nil, \"b\", nil, \"c\" ].compact! #=> [ \"a\", \"b\", \"c\" ]\n   [ \"a\", \"b\", \"c\" ].compact!           #=> nil", "name": "compact!", "namespace": "Array", "path": "Array#compact!", "type": "instance_method", "visibility": "public"}, "Array#concat": {"description": "在+self+中附加+otherary+s的元素。\\n \n   [ \"a\", \"b\" ].concat( [\"c\", \"d\"] ) #=> [ \"a\", \"b\", \"c\", \"d\" ]\n   [ \"a\" ].concat( [\"b\"], [\"c\", \"d\"] ) #=> [ \"a\", \"b\", \"c\", \"d\" ]\n   [ \"a\" ].concat #=> [ \"a\" ]\n\n   a = [ 1, 2, 3 ]\n   a.concat( [ 4, 5 ] )\n   a                                 #=> [ 1, 2, 3, 4, 5 ]\n\n   a = [ 1, 2 ]\n   a.concat(a, a)                    #=> [1, 2, 1, 2, 1, 2]\n \\n另请参阅数组+。", "name": "concat", "namespace": "Array", "path": "Array#concat", "type": "instance_method", "visibility": "public"}, "Array#count": {"description": "返回元素数。\\n \\n如果给定参数，则使用<code>==</code>计算等于+obj+ \\n的元素数。\\n \\n如果给定了块，则统计块返回真值的元素数。n \n   ary = [1, 2, 4, 2]\n   ary.count                  #=> 4\n   ary.count(2)               #=> 2\n   ary.count { |x| x%2 == 0 } #=> 3", "name": "count", "namespace": "Array", "path": "Array#count", "type": "instance_method", "visibility": "public"}, "Array#cycle": {"description": "为每个元素调用给定的块+n+次，如果给定+nil+，则永远调用。\\n \\n如果给定非正数或数组为空，则不执行任何操作。\\n \\n如果循环已完成但未中断，则返回+nil+。\\n \\n如果没有给定块，则返回枚举器。\\n \n   a = [\"a\", \"b\", \"c\"]\n   a.cycle { |x| puts x }     # print, a, b, c, a, b, c,.. forever.\n A.循环（2）x输出x打印，A、B、C、A、B、C。", "name": "cycle", "namespace": "Array", "path": "Array#cycle", "type": "instance_method", "visibility": "public"}, "Array#delete": {"description": "删除+self+中等于+obj+的所有项目。\\n \\n返回最后一个删除的项目，如果找不到匹配的项目，则返回+nil+。\\n \\n如果给定了可选代码块，则如果找不到该项，则返回该块的结果。（要删除+nil+个元素并获得信息性的返回值，请使用array compact！）n \n   a = [ \"a\", \"b\", \"b\", \"b\", \"c\" ]\n   a.delete(\"b\")                   #=> \"b\"\n   a                               #=> [\"a\", \"c\"]\n   a.delete(\"z\")                   #=> nil\n   a.delete(\"z\") { \"not found\" }   #=> \"not found\"", "name": "delete", "namespace": "Array", "path": "Array#delete", "type": "instance_method", "visibility": "public"}, "Array#delete_at": {"description": "删除指定的+index+处的元素，返回该元素；如果+index+超出范围，则删除+nil+。\\n \\n另请参见数组切片！n \n   a = [\"ant\", \"bat\", \"cat\", \"dog\"]\n   a.delete_at(2)    #=> \"cat\"\n   a                 #=> [\"ant\", \"bat\", \"dog\"]\n   a.delete_at(99)   #=> nil", "name": "delete_at", "namespace": "Array", "path": "Array#delete_at", "type": "instance_method", "visibility": "public"}, "Array#delete_if": {"description": "删除块计算结果为+true+的每个元素+self+。\\n \\n每次调用块时，数组都会立即更改，而不是在迭代结束后更改。\\n \\n另请参见数组拒绝！\\n \\n如果没有给定块，则返回枚举器。n \n   scores = [ 97, 42, 75 ]\n   scores.delete_if {|score| score < 80 }   #=> [97]", "name": "delete_if", "namespace": "Array", "path": "Array#delete_if", "type": "instance_method", "visibility": "public"}, "Array#dig": {"description": "通过在每个步骤调用+dig+来提取由<i>idx-\\n objects序列指定的嵌套值，如果任何中间步骤为+nil+，则返回+nil+。n \n  a = [[1, [2, 3]]]\n\n  a.dig(0, 1, 1)                    #=> 3\n  a.dig(1, 2, 3)                    #=> nil\n  a.dig(0, 0, 0)                    #=> TypeError: Integer does not have #dig method\n  [42, {foo: :bar}].dig(1, :foo)    #=> :bar", "name": "dig", "namespace": "Array", "path": "Array#dig", "type": "instance_method", "visibility": "public"}, "Array#drop": {"description": "从+ary+中删除前+n+个元素，并返回数组中的其余元素。\\n \\n如果给定负数，则引发ArgumentError。\\n \\n另见数组take \n   a = [1, 2, 3, 4, 5, 0]\n   a.drop(3)             #=> [4, 5, 0]", "name": "drop", "namespace": "Array", "path": "Array#drop", "type": "instance_method", "visibility": "public"}, "Array#drop_while": {"description": "将元素拖至第一个元素，但不包括该块返回+nil+或+false+的元素，并返回包含其余元素的数组。\\n \\n如果没有给定块，则返回枚举器。\\n \\n另请参阅array take偅while \n   a = [1, 2, 3, 4, 5, 0]\n   a.drop_while {|i| i < 3 }   #=> [3, 4, 5, 0]", "name": "drop_while", "namespace": "Array", "path": "Array#drop_while", "type": "instance_method", "visibility": "public"}, "Array#each": {"description": "为+self+中的每个元素调用一次给定的块，并将该元素作为参数传递。返回数组本身。\\n \\n如果没有给定块，则返回枚举器。\\n \n   a = [ \"a\", \"b\", \"c\" ]\n   a.each {|x| print x, \" -- \" }\n \\n产生：\\n \\n a--b--c--", "name": "each", "namespace": "Array", "path": "Array#each", "type": "instance_method", "visibility": "public"}, "Array#each_index": {"description": "与数组相同，但传递元素的+index+而不是元素本身。\\n \\n如果没有给定块，则返回枚举器。\\n \n   a = [ \"a\", \"b\", \"c\" ]\n   a.each_index {|x| print x, \" -- \" }\n \\n产生：\\n \\n 0--1--2--", "name": "each_index", "namespace": "Array", "path": "Array#each_index", "type": "instance_method", "visibility": "public"}, "Array#empty?": {"description": "如果+self+不包含元素，则返回+true+。\\n n    [].empty?   #=> true", "name": "empty?", "namespace": "Array", "path": "Array#empty?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Array#eql?": {"description": "如果+self+和+other+是同一对象，或者两个数组的内容相同（根据对象eql），则返回+true+。.", "name": "eql?", "namespace": "Array", "path": "Array#eql?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Array#fetch": {"description": "尝试返回位置+index+处的元素，但如果引用的+index+位于数组边界之外，则引发IndexError \\n异常。可以通过提供第二个参数来防止此错误，该参数将充当+default+值。\\n \\n或者，如果给定了块，则只有在引用无效的+index+时才会执行该块。\\n \\n从数组结尾算起的+index+计数的负值。n \n   a = [ 11, 22, 33, 44 ]\n   a.fetch(1)               #=> 22\n   a.fetch(-1)              #=> 44\n   a.fetch(4, 'cat')        #=> \"cat\"\n   a.fetch(100) { |i| puts \"#{i} is out of bounds\" }\n                            #=> \"100 is out of bounds\"", "name": "fetch", "namespace": "Array", "path": "Array#fetch", "type": "instance_method", "visibility": "public"}, "Array#fill": {"description": "前三个表单将所选元素+self+（可能是整个数组）设置为+obj+。\\n \\n +nil+的+start+等于零。\\n \\n +length+的+nil+等于数组的长度。\\n \\n最后三个表单用给定块的值填充数组，该值传递给要填充的每个元素的绝对索引。\\n \\n从数组结尾算起的+start+计数的负值，其中+-1+是最后一个元素。n \n   a = [ \"a\", \"b\", \"c\", \"d\" ]\n   a.fill(\"x\")              #=> [\"x\", \"x\", \"x\", \"x\"]\n   a.fill(\"z\", 2, 2)        #=> [\"x\", \"x\", \"z\", \"z\"]\n   a.fill(\"y\", 0..1)        #=> [\"y\", \"y\", \"z\", \"z\"]\n   a.fill { |i| i*i }       #=> [0, 1, 4, 9]\n   a.fill(-2) { |i| i*i*i } #=> [0, 1, 8, 27]", "name": "fill", "namespace": "Array", "path": "Array#fill", "type": "instance_method", "visibility": "public"}, "Array#find_index": {"description": "返回+ary+中第一个对象的索引，使该对象为<code>==</code>到+obj+。\\n \\n如果给定的是块而不是参数，则返回块为其返回+true+的第一个对象的索引。如果找不到匹配项，则返回+nil+。\\n \\n另请参阅array rindex。\\n \\n如果既不提供块也不提供参数，则返回枚举器。n \n   a = [ \"a\", \"b\", \"c\" ]\n   a.index(\"b\")              #=> 1\n   a.index(\"z\")              #=> nil\n   a.index { |x| x == \"b\" }  #=> 1", "name": "find_index", "namespace": "Array", "path": "Array#find_index", "type": "instance_method", "visibility": "public"}, "Array#first": {"description": "返回数组的第一个元素或前+n+个元素。\\n如果数组为空，则第一个窗体返回+nil+，第二个窗体返回空数组。另请参见数组last了解相反的效果。n \n   a = [ \"q\", \"r\", \"s\", \"t\" ]\n   a.first     #=> \"q\"\n   a.first(2)  #=> [\"q\", \"r\"]", "name": "first", "namespace": "Array", "path": "Array#first", "type": "instance_method", "visibility": "public"}, "Array#flatten": {"description": "返回一维平面化为+self+的新数组\\n（递归）。\\n \\n也就是说，对于每个数组元素，将其元素提取到新数组中。\\n \\n可选的+level+参数决定要展平的递归级别。n \n   s = [ 1, 2, 3 ]           #=> [1, 2, 3]\n   t = [ 4, 5, 6, [7, 8] ]   #=> [4, 5, 6, [7, 8]]\n   a = [ s, t, 9, 10 ]       #=> [[1, 2, 3], [4, 5, 6, [7, 8]], 9, 10]\n   a.flatten                 #=> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n   a = [ 1, 2, [3, [4, 5] ] ]\n   a.flatten(1)              #=> [1, 2, 3, [4, 5]]", "name": "flatten", "namespace": "Array", "path": "Array#flatten", "type": "instance_method", "visibility": "public"}, "Array#flatten!": {"description": "将+self+平整到位。\\n \\n如果未进行任何修改（即数组不包含子数组），则返回+nil+。\\n \\n可选的+level+参数确定要展平的递归级别。n \n   a = [ 1, 2, [3, [4, 5] ] ]\n   a.flatten!   #=> [1, 2, 3, 4, 5]\n   a.flatten!   #=> nil\n   a            #=> [1, 2, 3, 4, 5]\n   a = [ 1, 2, [3, [4, 5] ] ]\n   a.flatten!(1) #=> [1, 2, 3, [4, 5]]", "name": "flatten!", "namespace": "Array", "path": "Array#flatten!", "type": "instance_method", "visibility": "public"}, "Array#frozen?": {"description": "如果此数组被冻结（或排序时暂时冻结），则返回+true+。另请参见对象冻结？", "name": "frozen?", "namespace": "Array", "path": "Array#frozen?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Array#hash": {"description": "计算此数组的哈希代码。\\n \\n具有相同内容的两个数组将具有相同的哈希代码（并将使用eql进行比较？）.\\n \\n另请参见对象哈希。", "name": "hash", "namespace": "Array", "path": "Array#hash", "type": "instance_method", "visibility": "public"}, "Array#include?": {"description": "如果给定的+object+存在于+self+中（即，如果任何元素<code>==</code> +object+），则返回+true+，否则返回+false+。n \n   a = [ \"a\", \"b\", \"c\" ]\n   a.include?(\"b\")   #=> true\n   a.include?(\"z\")   #=> false", "name": "include?", "namespace": "Array", "path": "Array#include?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Array#index": {"description": "返回+ary+中第一个对象的索引，使该对象为<code>==</code>到+obj+。\\n \\n如果给定的是块而不是参数，则返回块为其返回+true+的第一个对象的索引。如果找不到匹配项，则返回+nil+。\\n \\n另请参阅array rindex。\\n \\n如果既不提供块也不提供参数，则返回枚举器。n \n   a = [ \"a\", \"b\", \"c\" ]\n   a.index(\"b\")              #=> 1\n   a.index(\"z\")              #=> nil\n   a.index { |x| x == \"b\" }  #=> 1", "name": "index", "namespace": "Array", "path": "Array#index", "type": "instance_method", "visibility": "public"}, "Array#initialize": {"description": "返回新数组。\\n \\n在第一个表单中，如果不发送参数，则新数组将为空。\\n当发送+size+和可选的+default+时，将创建一个包含+size+份+default+的数组。请注意，所有元素都将引用同一对象+default+。\\n \\n第二个窗体创建作为参数传递的数组的副本（数组是通过对参数调用to_ary生成的）。\\n \n  first_array = [\"Matz\", \"Guido\"]\n\n  second_array = Array.new(first_array) #=> [\"Matz\", \"Guido\"]\n\n  first_array.equal? second_array       #=> false\n \\n在最后一个窗体中，将创建给定大小的数组。此数组中的每个元素都是通过将元素的索引传递给给定的块并存储返回值来创建的。\\n \n  Array.new(3){ |index| index ** 2 }\n  # => [0, 1, 4]\n \\n==common gotchas \\n \\n发送第二个参数时，将使用相同的对象作为所有数组元素的值：\\n \n   a = Array.new(2, Hash.new)\n   # => [{}, {}]\n+str+00245 \\n由于所有数组元素都存储相同的哈希，因此其中一个元素的更改将影响所有这些元素。\\n \\n如果需要多个副本，则应使用块版本，每次需要初始化数组元素时，都使用该块的结果：\\n \n   a = Array.new(2) { Hash.new }\n   a[0]['cat'] = 'feline'\n   a # => [{\"cat\"=>\"feline\"}, {}]", "name": "initialize", "namespace": "Array", "path": "Array#initialize", "type": "instance_method", "visibility": "public"}, "Array#initialize_copy": {"description": "将+self+的内容替换为+other_ary+的内容，必要时截断或展开。n \n   a = [ \"a\", \"b\", \"c\", \"d\", \"e\" ]\n   a.replace([ \"x\", \"y\", \"z\" ])   #=> [\"x\", \"y\", \"z\"]\n   a                              #=> [\"x\", \"y\", \"z\"]", "name": "initialize_copy", "namespace": "Array", "path": "Array#initialize_copy", "type": "instance_method", "visibility": "public"}, "Array#insert": {"description": "在元素前面插入给定的值，并使用给定的+index+。\\n \\n负索引从数组结尾开始倒数，其中+-1+是最后一个元素。如果使用负索引，则给定值将插入该元素之后，因此使用+-1+索引将在数组末尾插入值。n \n   a = %w{ a b c d }\n   a.insert(2, 99)         #=> [\"a\", \"b\", 99, \"c\", \"d\"]\n   a.insert(-2, 1, 2, 3)   #=> [\"a\", \"b\", 99, \"c\", 1, 2, 3, \"d\"]", "name": "insert", "namespace": "Array", "path": "Array#insert", "type": "instance_method", "visibility": "public"}, "Array#inspect": {"description": "创建+self+的字符串表示形式。\\n n    [ \"a\", \"b\", \"c\" ].to_s     #=> \"[\\\"a\\\", \\\"b\\\", \\\"c\\\"]\"", "name": "to_s", "namespace": "Array", "path": "Array#to_s", "type": "instance_method", "visibility": "public"}, "Array#to_s": {"description": "创建+self+的字符串表示形式。\\n n    [ \"a\", \"b\", \"c\" ].to_s     #=> \"[\\\"a\\\", \\\"b\\\", \\\"c\\\"]\"", "name": "to_s", "namespace": "Array", "path": "Array#to_s", "type": "instance_method", "visibility": "public"}, "Array#join": {"description": "返回通过将数组的每个元素转换为一个字符串而创建的字符串，该字符串由给定的+separator+分隔。\\n如果+separator+是+nil+，则使用当前的<code>$,</code>。\\n如果+separator+和<code>$,</code>都是+nil+，则使用空字符串。\\n \n   [ \"a\", \"b\", \"c\" ].join        #=> \"abc\"\n   [ \"a\", \"b\", \"c\" ].join(\"-\")   #=> \"a-b-c\"\n \\n对于嵌套数组，递归应用join:\\n \\n    [ \"a\", [1, 2, [:x, :y]], \"b\" ].join(\"-\")   #=> \"a-1-2-x-y-b\"", "name": "join", "namespace": "Array", "path": "Array#join", "type": "instance_method", "visibility": "public"}, "Array#keep_if": {"description": "删除给定块的计算结果为+false+的每个元素+self+。\\n \\n另请参阅数组选择！\\n \\n如果没有给定块，则返回枚举器。n \n   a = %w{ a b c d e f }\n   a.keep_if { |v| v =~ /[aeiou]/ }  #=> [\"a\", \"e\"]", "name": "keep_if", "namespace": "Array", "path": "Array#keep_if", "type": "instance_method", "visibility": "public"}, "Array#last": {"description": "返回+self+的最后一个元素。如果数组为空，则第一个窗体返回+nil+。\\n \\n另请参见数组了解相反的效果。n \n   a = [ \"w\", \"x\", \"y\", \"z\" ]\n   a.last     #=> \"z\"\n   a.last(2)  #=> [\"y\", \"z\"]", "name": "last", "namespace": "Array", "path": "Array#last", "type": "instance_method", "visibility": "public"}, "Array#length": {"description": "返回+self+中的元素数。可能是零。n \n   [ 1, 2, 3, 4, 5 ].length   #=> 5\n   [].length                  #=> 0", "name": "size", "namespace": "Array", "path": "Array#size", "type": "instance_method", "visibility": "public"}, "Array#size": {"description": "返回+self+中的元素数。可能是零。n \n   [ 1, 2, 3, 4, 5 ].length   #=> 5\n   [].length                  #=> 0", "name": "size", "namespace": "Array", "path": "Array#size", "type": "instance_method", "visibility": "public"}, "Array#map": {"description": "为+self+的每个元素调用一次给定的块。\\n \\n建立包含区块传回值的新阵列。\\n \\n另请参见Enumerable Collect。\\n \\n如果没有给定块，则返回枚举器。n \n   a = [ \"a\", \"b\", \"c\", \"d\" ]\n   a.collect { |x| x + \"!\" }         #=> [\"a!\", \"b!\", \"c!\", \"d!\"]\n   a.map.with_index { |x, i| x * i } #=> [\"\", \"b\", \"cc\", \"ddd\"]\n   a                                 #=> [\"a\", \"b\", \"c\", \"d\"]", "name": "map", "namespace": "Array", "path": "Array#map", "type": "instance_method", "visibility": "public"}, "Array#map!": {"description": "为+self+的每个元素调用一次给定的块，用块返回的值替换元素。\\n \\n另请参见Enumerable Collect。\\n \\n如果没有给定块，则返回枚举器。n \n   a = [ \"a\", \"b\", \"c\", \"d\" ]\n   a.map! {|x| x + \"!\" }\n   a #=>  [ \"a!\", \"b!\", \"c!\", \"d!\" ]\n   a.collect!.with_index {|x, i| x[0...i] }\n   a #=>  [\"\", \"b\", \"c!\", \"d!\"]", "name": "map!", "namespace": "Array", "path": "Array#map!", "type": "instance_method", "visibility": "public"}, "Array#max": {"description": "返回带最大值的ARY对象。第一个窗体假定所有对象都实现<code>Comparable</code>；\\n第二个窗体使用块返回<em>a<=>b->em>。\\n \n   ary = %w(albatross dog horse)\n   ary.max                                   #=> \"horse\"\n   ary.max { |a, b| a.length <=> b.length }  #=> \"albatross\"\n \\n如果给定+n+参数，则以数组形式返回最多+n+个元素。n \n   ary = %w[albatross dog horse]\n   ary.max(2)                                  #=> [\"horse\", \"dog\"]\n   ary.max(2) {|a, b| a.length <=> b.length }  #=> [\"albatross\", \"horse\"]", "name": "max", "namespace": "Array", "path": "Array#max", "type": "instance_method", "visibility": "public"}, "Array#min": {"description": "返回带有最小值的ARY对象。第一个窗体假定所有对象实现<code>Comparable</code>；\\n第二个窗体使用块返回<em>a<=>b。\\n \n   ary = %w(albatross dog horse)\n   ary.min                                   #=> \"albatross\"\n   ary.min { |a, b| a.length <=> b.length }  #=> \"dog\"\n \\n如果给定+n+参数，则以数组形式返回至少+n+个元素。n \n   ary = %w[albatross dog horse]\n   ary.min(2)                                  #=> [\"albatross\", \"dog\"]\n   ary.min(2) {|a, b| a.length <=> b.length }  #=> [\"dog\", \"horse\"]", "name": "min", "namespace": "Array", "path": "Array#min", "type": "instance_method", "visibility": "public"}, "Array#pack": {"description": "根据<i>atemplateString<i>（参见下表）中的指令，将<i>arr->i>的内容打包成二进制序列\\n directives``A，``A，`` A，`和``Z'后面可能跟一个count，\\n它给出结果字段的宽度。其余的指令也可能接受一个计数，指示要转换的数组元素的数目。如果计数是星号（``<code>*</code>''，则所有剩余的数组元素都将被转换。任何指令“<code>sSiIlL</code>”后面都可以加下划线（“<code>_</code>”）或感叹号（“<code>!</code>”）以使用基础平台的本机大小作为指定的type;；否则，它们使用平台独立大小。模板字符串中的空格将被忽略。另见<code>String#unpack</code>。\\n \n   a = [ \"a\", \"b\", \"c\" ]\n   n = [ 65, 66, 67 ]\n   a.pack(\"A3A3A3\")   #=> \"a  b  c  \"\n   a.pack(\"a3a3a3\")   #=> \"a\\000\\000b\\000\\000c\\000\\000\"\n   n.pack(\"ccc\")      #=> \"ABC\"\n \\n如果指定了abufferstring<i>abufferstring且其容量足够，则+pack+将其用作缓冲区并返回它。\\n如果偏移量是由<i>AtemplateString的开头指定的，则结果将在偏移量之后填充。\\n如果存在<i>abufferstring<i>的原始内容，并且其长度大于\\n偏移量，则结果将覆盖<i>offsetofbuffer的其余内容。\\n如果较短，则用“<code>\\0</code>”填充间隙。\\n \\n请注意，`` buffer:“”选项不保证在+pack+中不分配内存。如果<i>abufferstring的容量不足，+pack+将分配内存。\\n \\n +pack+的指令。\\n \\n integer array \\n directive element meansion \\n- ------------------------------------------------------------------------------------\\n c integer 8位无符号（无符号字符）\\n s integer 16位无符号，本机endian（uint16_t）\\n l integer 32位无符号，本机endian（uint32_t \\n q integer 64位无符号，本机endian（uint64_t \\n j integer指针宽度无符号，本机endian（uintptr_t）\n               |         | (J is available since Ruby 2.3.)\n               |         |\n c integer 8位有符号（有符号字符），n s integer 16位有符号，本机endian（int16_t \\n l integer 32位有符号，本机endian（int32_t）\\n q integer 64位有符号，本机endian（int64_t）\\n j integer指针宽度有符号，本机endian（intptr_t）\n               |         | (j is available since Ruby 2.3.)\n               |         |\n S_ s！integer_unsigned short，native endian \\n i I_ i！integer_unsigned int，本机endian \\n L_ L！integer_unsigned long，native endian \\n Q_ q！integer_unsigned long long，native endian（参数错误\n               |         | if the platform has no long long type.)\n               |         | (Q_ and Q! is available since Ruby 2.1.)\n J！integer_uintptr_t，本机endian（与j相同）\n               |         | (J! is available since Ruby 2.3.)\n               |         |\n s_ s！integer_signed short，native endian \\n i i_ i！integer_signed int，native endian \\n l_ l！integer_signed long，native endian \\n q_ Q！integer_signed long long，native endian（参数错误\n               |         | if the platform has no long long type.)\n               |         | (q_ and q! is available since Ruby 2.1.)\n J！integer_intptr_t，本机endian（与j相同）\n               |         | (j! is available since Ruby 2.3.)\n               |         |\n s>s>s！>S！>integer与不带“>”的指令相同，但\\n l>l>l！>我！>big endian \\n i！>我！>（Ruby 1.9.3之后提供）n q>q>q！>问！>“s>”与“n”相同\\n j>j>j！>J！>“l>”is same as“N”\n               |         |\n s<s<s！<s！<integer与不带“<”的指令相同，但\\n l<l<l！<l！<小endian \\n i！<我！<（Ruby 1.9.3之后提供）n q<q<q！<Q！<“s<”与“v”相同\\n j<j<j！<j！<“l<”与“v”\n               |         |\n N integer 16位无符号，网络（big endian）字节顺序\\n integer 32位无符号，网络（big endian）字节顺序\\n v integer 16位无符号，vax（little endian）字节顺序\\n v integer 32位无符号，vax（little endian）字节1000相同334 u integer utf-8 character \\n w integer ber compressed integer \\n \\n float array \\n directive element meansion \\n- -------------------------------------------------------------------\\n d float double precision，本机格式\\n f f float single precision，本机格式\\n e float double precision，little endian byte order \\n e float single precision，little endian byte order \\n g float double precision，network（big endian）byte order \\n \\n string array \\n指令element含义\\n- --------------------------------------------------------------------------\\n a string任意二进制字符串（空格填充，count为width）n a string任意二进制字符串（空填充，count为width）n z string与“a”相同，但null与*\\n b一起添加", "name": "pack", "namespace": "Array", "path": "Array#pack", "type": "instance_method", "visibility": "public"}, "Array#permutation": {"description": "当使用块调用时，生成数组元素的长度为+n+的所有排列，然后返回数组本身。\\n \\n如果未指定+n+，则生成所有元素的所有排列。\\n \\n实作无法保证产生排列的顺序。\\n \\n如果没有给定块，则返回枚举器。\\n \\n示例：\\n \\n a=[1，2，3]\\n  a.permutation.to_a    #=> [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] \\n  a.permutation(1).to_a #=> [[1],[2],[3]] \\n  a.permutation(2).to_a #=> [[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]] \\n  a.permutation(3).to_a #=> [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] \\n  a.permutation(0).to_a #=> [[]] # one permutation of length 0 \\n  a.permutation(4).to_a #=> []   # no permutations of length 4", "name": "permutation", "namespace": "Array", "path": "Array#permutation", "type": "instance_method", "visibility": "public"}, "Array#pop": {"description": "从+self+中移除最后一个元素并返回它，或者如果数组为空则返回+nil+。\\n \\n如果给定一个数字+n+，则返回最后一个+n+元素的数组\\n（或更少），就像<code>array.slice!(-n, n)</code>一样。另请参见数组推动以获得相反的效果。n \n   a = [ \"a\", \"b\", \"c\", \"d\" ]\n   a.pop     #=> \"d\"\n   a.pop(2)  #=> [\"b\", \"c\"]\n   a         #=> [\"a\"]", "name": "pop", "namespace": "Array", "path": "Array#pop", "type": "instance_method", "visibility": "public"}, "Array#prepend": {"description": "将对象预处理到+self+的前面，向上移动其他元素。\\n有关相反的效果，请参见数组移位。n \n   a = [ \"b\", \"c\", \"d\" ]\n   a.unshift(\"a\")   #=> [\"a\", \"b\", \"c\", \"d\"]\n   a.unshift(1, 2)  #=> [ 1, 2, \"a\", \"b\", \"c\", \"d\"]", "name": "prepend", "namespace": "Array", "path": "Array#prepend", "type": "instance_method", "visibility": "public"}, "Array#product": {"description": "返回所有数组中所有元素组合的数组。\\n \\n传回的阵列长度是长度+self+与变元阵列的乘积。\\n \\n如果给定一个块，product将生成所有组合并返回+self+ \\n。n \n   [1,2,3].product([4,5])     #=> [[1,4],[1,5],[2,4],[2,5],[3,4],[3,5]]\n   [1,2].product([1,2])       #=> [[1,1],[1,2],[2,1],[2,2]]\n   [1,2].product([3,4],[5,6]) #=> [[1,3,5],[1,3,6],[1,4,5],[1,4,6],\n                              #     [2,3,5],[2,3,6],[2,4,5],[2,4,6]]\n   [1,2].product()            #=> [[1],[2]]\n   [1,2].product([])          #=> []", "name": "product", "namespace": "Array", "path": "Array#product", "type": "instance_method", "visibility": "public"}, "Array#push": {"description": "附加-将给定对象推到此数组的末尾。此表达式返回数组本身，因此可以将多个附录链接在一起。另请参见数组弹出以获得相反的效果。n \n   a = [ \"a\", \"b\", \"c\" ]\n   a.push(\"d\", \"e\", \"f\")\n           #=> [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"]\n   [1, 2, 3].push(4).push(5)\n           #=> [1, 2, 3, 4, 5]", "name": "append", "namespace": "Array", "path": "Array#append", "type": "instance_method", "visibility": "public"}, "Array#rassoc": {"description": "搜索元素也是数组的数组。\\n \\n将+obj+与使用<code>obj.==</code>的每个包含数组的第二个元素进行比较。\\n \\n返回第一个与+obj+匹配的包含数组。\\n \\n另请参阅数组关联。\\n \n   a = [ [ 1, \"one\"], [2, \"two\"], [3, \"three\"], [\"ii\", \"two\"] ]\n   a.rassoc(\"two\")    #=> [2, \"two\"]\n   a.rassoc(\"four\")   #=> nil", "name": "rassoc", "namespace": "Array", "path": "Array#rassoc", "type": "instance_method", "visibility": "public"}, "Array#reject": {"description": "返回一个新数组，该数组包含+self+中给定块不是+true+的项。保留未拒绝元素的顺序。\\n \\n另请参阅array delete_如果\\n \\n如果没有给定块，则返回枚举器。", "name": "reject", "namespace": "Array", "path": "Array#reject", "type": "instance_method", "visibility": "public"}, "Array#reject!": {"description": "删除块计算结果为+true+的每个元素+self+，如果没有进行任何更改，则返回+nil+。\\n \\n每次调用块时，数组可能不会立即更改。\\n \\n另请参见可枚举拒绝和数组删除if。\\n \\n如果没有给定块，则返回枚举器。", "name": "reject!", "namespace": "Array", "path": "Array#reject!", "type": "instance_method", "visibility": "public"}, "Array#repeated_combination": {"description": "当用块调用时，从数组中生成长度为+n+的元素的所有重复组合，然后返回数组本身。\\n \\n实作无法保证重复组合产生的顺序。\\n \\n如果没有给定块，则返回枚举器。\\n \\n示例：\\n \\n a=[1，2，3]\\n  a.repeated_combination(1).to_a  #=> [[1], [2], [3]] \\n  a.repeated_combination(2).to_a  #=> [[1,1],[1,2],[1,3],[2,2],[2,3],[3,3]] \\n  a.repeated_combination(3).to_a  #=> [[1,1,1],[1,1,2],[1,1,3],[1,2,2],[1,2,3],\n                                 #    [1,3,3],[2,2,2],[2,2,3],[2,3,3],[3,3,3]]\n a.repeated_combination(4).to_a  #=> [[1,1,1,1],[1,1,1,2],[1,1,1,3],[1,1,2,2],[1,1,2,3],\n                                 #    [1,1,3,3],[1,2,2,2],[1,2,2,3],[1,2,3,3],[1,3,3,3],\n                                 #    [2,2,2,2],[2,2,2,3],[2,2,3,3],[2,3,3,3],[3,3,3,3]]\n a.repeated_combination(0).to_a  #=> [[]] # one combination of length 0", "name": "repeated_combination", "namespace": "Array", "path": "Array#repeated_combination", "type": "instance_method", "visibility": "public"}, "Array#repeated_permutation": {"description": "使用块调用时，生成数组元素的所有重复排列，长度为+n+，然后返回数组本身。\\n \\n实作无法保证重复排列产生的顺序。\\n \\n如果没有给定块，则返回枚举器。\\n \\n范例：\\n \n   a = [1, 2]\n   a.repeated_permutation(1).to_a  #=> [[1], [2]]\n   a.repeated_permutation(2).to_a  #=> [[1,1],[1,2],[2,1],[2,2]]\n   a.repeated_permutation(3).to_a  #=> [[1,1,1],[1,1,2],[1,2,1],[1,2,2],\n                                   #    [2,1,1],[2,1,2],[2,2,1],[2,2,2]]\n   a.repeated_permutation(0).to_a  #=> [[]] # one permutation of length 0", "name": "repeated_permutation", "namespace": "Array", "path": "Array#repeated_permutation", "type": "instance_method", "visibility": "public"}, "Array#replace": {"description": "将+self+的内容替换为+other_ary+的内容，必要时截断或展开。n \n   a = [ \"a\", \"b\", \"c\", \"d\", \"e\" ]\n   a.replace([ \"x\", \"y\", \"z\" ])   #=> [\"x\", \"y\", \"z\"]\n   a                              #=> [\"x\", \"y\", \"z\"]", "name": "replace", "namespace": "Array", "path": "Array#replace", "type": "instance_method", "visibility": "public"}, "Array#reverse": {"description": "返回一个新数组，该数组按相反顺序包含+self+的元素。n \n   [ \"a\", \"b\", \"c\" ].reverse   #=> [\"c\", \"b\", \"a\"]\n   [ 1 ].reverse               #=> [1]", "name": "reverse", "namespace": "Array", "path": "Array#reverse", "type": "instance_method", "visibility": "public"}, "Array#reverse!": {"description": "反向+self+到位。n \n   a = [ \"a\", \"b\", \"c\" ]\n   a.reverse!       #=> [\"c\", \"b\", \"a\"]\n   a                #=> [\"c\", \"b\", \"a\"]", "name": "reverse!", "namespace": "Array", "path": "Array#reverse!", "type": "instance_method", "visibility": "public"}, "Array#reverse_each": {"description": "与数组相同，但按相反顺序遍历+self+。\\n \n   a = [ \"a\", \"b\", \"c\" ]\n   a.reverse_each {|x| print x, \" \" }\n \\n产生：\\n \\n c b a", "name": "reverse_each", "namespace": "Array", "path": "Array#reverse_each", "type": "instance_method", "visibility": "public"}, "Array#rindex": {"description": "返回+self+ <code>==</code>到+obj+中最后一个对象的索引。\\n \\n如果给定的是块而不是参数，则返回块为其返回+true+的第一个对象的索引，从最后一个对象开始。\\n \\n如果找不到匹配项，则返回+nil+。\\n \\n另请参阅数组索引。\\n \\n如果既不提供块也不提供参数，则返回枚举器。n \n   a = [ \"a\", \"b\", \"b\", \"b\", \"c\" ]\n   a.rindex(\"b\")             #=> 3\n   a.rindex(\"z\")             #=> nil\n   a.rindex { |x| x == \"b\" } #=> 3", "name": "rindex", "namespace": "Array", "path": "Array#rindex", "type": "instance_method", "visibility": "public"}, "Array#rotate": {"description": "通过旋转+self+返回新数组，使+count+处的元素是新数组的第一个元素。\\n \\n如果+count+为负，则从+self+结束时开始以相反的方向旋转，其中+-1+是最后一个元素。n \n   a = [ \"a\", \"b\", \"c\", \"d\" ]\n   a.rotate         #=> [\"b\", \"c\", \"d\", \"a\"]\n   a                #=> [\"a\", \"b\", \"c\", \"d\"]\n   a.rotate(2)      #=> [\"c\", \"d\", \"a\", \"b\"]\n   a.rotate(-3)     #=> [\"b\", \"c\", \"d\", \"a\"]", "name": "rotate", "namespace": "Array", "path": "Array#rotate", "type": "instance_method", "visibility": "public"}, "Array#rotate!": {"description": "将+self+旋转到位，使+count+处的元素位于第一位，并返回+self+。\\n \\n如果+count+为负，则它将从数组的末尾开始反向旋转，其中+-1+是最后一个元素。n \n   a = [ \"a\", \"b\", \"c\", \"d\" ]\n   a.rotate!        #=> [\"b\", \"c\", \"d\", \"a\"]\n   a                #=> [\"b\", \"c\", \"d\", \"a\"]\n   a.rotate!(2)     #=> [\"d\", \"a\", \"b\", \"c\"]\n   a.rotate!(-3)    #=> [\"a\", \"b\", \"c\", \"d\"]", "name": "rotate!", "namespace": "Array", "path": "Array#rotate!", "type": "instance_method", "visibility": "public"}, "Array#sample": {"description": "从阵列中选择一个随机元素或+n+个随机元素。\\n \\n通过在数组中使用随机和唯一索引来选择元素，以确保元素不会重复自身，除非数组已包含重复元素。\\n \\n如果数组为空，则第一个窗体返回+nil+，第二个窗体返回空数组。\\n \\n可选的+rng+参数将用作随机数生成器。n \n   a = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]\n   a.sample         #=> 7\n   a.sample(4)      #=> [6, 4, 2, 5]", "name": "sample", "namespace": "Array", "path": "Array#sample", "type": "instance_method", "visibility": "public"}, "Array#select": {"description": "返回一个新数组，该数组包含+ary+的所有元素，对于这些元素，给定的+block+将返回一个真值。\\n \\n如果没有给定块，则返回枚举器。\\n \n   [1,2,3,4,5].select { |num|  num.even?  }   #=> [2, 4]\n100423 \\n另请参阅Enumerable Select。", "name": "select", "namespace": "Array", "path": "Array#select", "type": "instance_method", "visibility": "public"}, "Array#select!": {"description": "调用给定的块，传入+self+中的连续元素，删除块返回+false+值的元素。\\n \\n每次调用块时，数组可能不会立即更改。\\n \\n如果进行了更改，则返回+self+，否则返回+nil+。\\n \\n另请参阅array keep_if \\n \\n如果没有给定块，则返回枚举器。", "name": "select!", "namespace": "Array", "path": "Array#select!", "type": "instance_method", "visibility": "public"}, "Array#shift": {"description": "移除+self+的第一个元素并返回它（将所有其他元素向下移动一个）。如果数组为空，则返回+nil+。\\n \\n如果给定数字+n+，则返回前+n+个元素（或更少）的数组，就像<code>array.slice!(0, n)</code>一样。其中+ary+ \\n只包含其余元素，不包括移位到+new_ary+的元素。另请参见数组取消滑动以获得相反的效果。n \n   args = [ \"-m\", \"-q\", \"filename\" ]\n   args.shift     #=> \"-m\"\n   args           #=> [\"-q\", \"filename\"]\n\n   args = [ \"-m\", \"-q\", \"filename\" ]\n   args.shift(2)  #=> [\"-m\", \"-q\"]\n   args           #=> [\"filename\"]", "name": "shift", "namespace": "Array", "path": "Array#shift", "type": "instance_method", "visibility": "public"}, "Array#shuffle": {"description": "返回一个新数组，其中元素+self+随机排列。\\n \n   a = [ 1, 2, 3 ]           #=> [1, 2, 3]\n   a.shuffle                 #=> [2, 3, 1]\n   a                         #=> [1, 2, 3]\n \\n可选的+rng+参数将用作随机数生成器。\\n n    a.shuffle(random: Random.new(1))  #=> [1, 3, 2]", "name": "shuffle", "namespace": "Array", "path": "Array#shuffle", "type": "instance_method", "visibility": "public"}, "Array#shuffle!": {"description": "将+self+中的元素重新排列到位。\\n \n   a = [ 1, 2, 3 ]           #=> [1, 2, 3]\n   a.shuffle!                #=> [2, 3, 1]\n   a                         #=> [2, 3, 1]\n \\n可选的+rng+参数将用作随机数生成器。\\n n    a.shuffle!(random: Random.new(1))  #=> [1, 3, 2]", "name": "shuffle!", "namespace": "Array", "path": "Array#shuffle!", "type": "instance_method", "visibility": "public"}, "Array#slice": {"description": "元素引用-返回+index+处的元素，或返回从+start+索引开始并继续执行+length+元素的子数组，或返回由+range+个索引指定的子数组。\\n \\n负索引从数组结尾向后计数（-1是最后一个元素）。对于+start+和+range+情况，起始索引就在元素之前。此外，当元素范围的起始索引位于数组的末尾时，将返回空数组。\\n \\n如果索引（或起始索引）超出范围，则返回+nil+。n \n   a = [ \"a\", \"b\", \"c\", \"d\", \"e\" ]\n   a[2] +  a[0] + a[1]    #=> \"cab\"\n   a[6]                   #=> nil\n   a[1, 2]                #=> [ \"b\", \"c\" ]\n   a[1..3]                #=> [ \"b\", \"c\", \"d\" ]\n   a[4..7]                #=> [ \"e\" ]\n   a[6..10]               #=> nil\n   a[-3, 3]               #=> [ \"c\", \"d\", \"e\" ]\n   # special cases\n   a[5]                   #=> nil\n   a[6, 1]                #=> nil\n   a[5, 1]                #=> []\n   a[5..10]               #=> []", "name": "slice", "namespace": "Array", "path": "Array#slice", "type": "instance_method", "visibility": "public"}, "Array#slice!": {"description": "删除由+index+（可选多达+length+个元素）或+range+给定的元素。\\n \\n如果+index+超出范围，则返回已删除的对象或+nil+。n \n   a = [ \"a\", \"b\", \"c\" ]\n   a.slice!(1)     #=> \"b\"\n   a               #=> [\"a\", \"c\"]\n   a.slice!(-1)    #=> \"c\"\n   a               #=> [\"a\"]\n   a.slice!(100)   #=> nil\n   a               #=> [\"a\"]", "name": "slice!", "namespace": "Array", "path": "Array#slice!", "type": "instance_method", "visibility": "public"}, "Array#sort": {"description": "返回通过排序+self+创建的新数组。\\n \\n将使用<code><=></code>运算符或可选代码块对排序进行比较。\\n \\n区块必须执行+a+与+b+之间的比较，当+b+跟+a+时传回小于0的整数，当+a+与+b+相等时传回+0+，或当+a+跟+b+时传回大于0的整数。\\n \\n无法保证结果稳定。当两个元素的比较返回+0+时，元素的顺序是不可预测的。\\n \n   ary = [ \"d\", \"a\", \"e\", \"c\", \"b\" ]\n   ary.sort                     #=> [\"a\", \"b\", \"c\", \"d\", \"e\"]\n   ary.sort { |a, b| b <=> a }  #=> [\"e\", \"d\", \"c\", \"b\", \"a\"]\n \\n另请参阅可枚举的排序依据。", "name": "sort", "namespace": "Array", "path": "Array#sort", "type": "instance_method", "visibility": "public"}, "Array#sort!": {"description": "对+self+进行排序。\\n \\n将使用<code><=></code>运算符或可选代码块对排序进行比较。\\n \\n区块必须执行+a+与+b+之间的比较，当+b+遵循+a+时传回小于0的整数，当+a+与+b+相等时传回+0+，或当+a+遵循+b+时传回大于0的整数。\\n \\n无法保证结果稳定。当两个元素的比较返回+0+时，元素的顺序是不可预测的。\\n \n   ary = [ \"d\", \"a\", \"e\", \"c\", \"b\" ]\n   ary.sort!                     #=> [\"a\", \"b\", \"c\", \"d\", \"e\"]\n   ary.sort! { |a, b| b <=> a }  #=> [\"e\", \"d\", \"c\", \"b\", \"a\"]\n \\n另请参阅可枚举的排序依据。", "name": "sort!", "namespace": "Array", "path": "Array#sort!", "type": "instance_method", "visibility": "public"}, "Array#sort_by!": {"description": "使用通过将+self+中的值映射到给定块而生成的一组键对+self+进行就地排序。\\n \\n无法保证结果稳定。当两个键相等时，相应元素的顺序是不可预测的。\\n \\n如果没有给定块，则返回枚举器。\\n \\n另请参阅可枚举的排序依据。", "name": "sort_by!", "namespace": "Array", "path": "Array#sort_by!", "type": "instance_method", "visibility": "public"}, "Array#sum": {"description": "返回元素的和。\\n例如，[e1，e2，e3].sum返回init+e1+e2+e3。\\n \\n如果给定了块，则在添加前将该块应用于每个元素。\\n \\n如果<i>ary->is empty，则返回<i>i n it->i>。\\n \n  [].sum                             #=> 0\n  [].sum(0.0)                        #=> 0.0\n  [1, 2, 3].sum                      #=> 6\n  [3, 5.5].sum                       #=> 8.5\n  [2.5, 3.0].sum(0.0) {|e| e * e }   #=> 15.25\n  [Object.new].sum                   #=> TypeError\n \\n阵列的（算术）平均值可按如下方式获得。\\n \n  mean = ary.sum(0.0) / ary.length\n \\n此方法可以通过explicit<i>init<i>参数用于非数字对象。\\n \n  [\"a\", \"b\", \"c\"].sum(\"\")            #=> \"abc\"\n  [[1], [[2]], [3]].sum([])          #=> [1, [2], 3]\n \\n但是，对于字符串数组和数组数组，array join和array flatten比array sum更快。\\n \n  [\"a\", \"b\", \"c\"].join               #=> \"abc\"\n  [[1], [[2]], [3]].flatten(1)       #=> [1, [2], 3]\n \\n \\n array sum方法可能不考虑对“+”方法（如integer+）的方法重新定义。", "name": "sum", "namespace": "Array", "path": "Array#sum", "type": "instance_method", "visibility": "public"}, "Array#take": {"description": "返回数组中的前+n+个元素。\\n \\n如果给定负数，则引发\n   ary = Array.new    #=> []\n   Array.new(3)       #=> [nil, nil, nil]\n   Array.new(3, true) #=> [true, true, true]\n。\\n \\n另见数组drop \n   ary = [1, \"two\", 3.0] #=> [1, \"two\", 3.0]\n", "name": "take", "namespace": "Array", "path": "Array#take", "type": "instance_method", "visibility": "public"}, "Array#take_while": {"description": "将元素传递到块，直到块返回+nil+或+false+，然后\\n停止迭代并返回所有先前元素的数组。\\n \\n如果没有给定块，则返回枚举器。\\n \\n另请参阅array drop_while \n   a = [1, 2, 3, 4, 5, 0]\n   a.take_while { |i| i < 3 }  #=> [1, 2]", "name": "take_while", "namespace": "Array", "path": "Array#take_while", "type": "instance_method", "visibility": "public"}, "Array#to_a": {"description": "返回+self+。\\n \\n如果在数组的子类上调用，则将接收器转换为数组对象。", "name": "to_a", "namespace": "Array", "path": "Array#to_a", "type": "instance_method", "visibility": "public"}, "Array#to_ary": {"description": "返回哈希中的键值对数。n \n   h = { \"d\" => 100, \"a\" => 200, \"v\" => 300, \"e\" => 400 }\n   h.length        #=> 4\n   h.delete(\"a\")   #=> 200\n   h.length        #=> 3", "name": "to_ary", "namespace": "Array", "path": "Array#to_ary", "type": "instance_method", "visibility": "public"}, "Array#to_h": {"description": "返回将<i>ary<i>解释为成对数组的结果。n \n   [[:foo, :bar], [1, 2]].to_h\n     # => {:foo => :bar, 1 => 2}", "name": "to_h", "namespace": "Array", "path": "Array#to_h", "type": "instance_method", "visibility": "public"}, "Array#transpose": {"description": "假设+self+是一个数组数组，并转换行和列。\\n \n   a = [[1,2], [3,4], [5,6]]\n   a.transpose   #=> [[1, 3, 5], [2, 4, 6]]\n \\n如果子数组的长度不匹配，则会引发IndexError。", "name": "transpose", "namespace": "Array", "path": "Array#transpose", "type": "instance_method", "visibility": "public"}, "Array#uniq": {"description": "通过删除+self+中的重复值返回新数组。\\n \\n如果给定了块，它将使用块的返回值进行比较。\\n \\n它使用哈希和eql比较值？提高效率的方法。\\n \\n +self+按顺序遍历，并保留第一个匹配项。n \n   a = [ \"a\", \"a\", \"b\", \"b\", \"c\" ]\n   a.uniq   # => [\"a\", \"b\", \"c\"]\n\n   b = [[\"student\",\"sam\"], [\"student\",\"george\"], [\"teacher\",\"matz\"]]\n   b.uniq { |s| s.first } # => [[\"student\", \"sam\"], [\"teacher\", \"matz\"]]", "name": "uniq", "namespace": "Array", "path": "Array#uniq", "type": "instance_method", "visibility": "public"}, "Array#uniq!": {"description": "从+self+中删除重复元素。\\n \\n如果给定了块，它将使用块的返回值进行比较。\\n \\n它使用哈希和eql比较值？提高效率的方法。\\n \\n +self+按顺序遍历，并保留第一个匹配项。\\n \\n如果未做任何更改（即，找不到重复项），则返回+nil+。n \n   a = [ \"a\", \"a\", \"b\", \"b\", \"c\" ]\n   a.uniq!   # => [\"a\", \"b\", \"c\"]\n\n   b = [ \"a\", \"b\", \"c\" ]\n   b.uniq!   # => nil\n\n   c = [[\"student\",\"sam\"], [\"student\",\"george\"], [\"teacher\",\"matz\"]]\n   c.uniq! { |s| s.first } # => [[\"student\", \"sam\"], [\"teacher\", \"matz\"]]", "name": "uniq!", "namespace": "Array", "path": "Array#uniq!", "type": "instance_method", "visibility": "public"}, "Array#unshift": {"description": "将对象预处理到+self+的前面，向上移动其他元素。\\n有关相反的效果，请参见数组移位。n \n   a = [ \"b\", \"c\", \"d\" ]\n   a.unshift(\"a\")   #=> [\"a\", \"b\", \"c\", \"d\"]\n   a.unshift(1, 2)  #=> [ 1, 2, \"a\", \"b\", \"c\", \"d\"]", "name": "prepend", "namespace": "Array", "path": "Array#prepend", "type": "instance_method", "visibility": "public"}, "Array#values_at": {"description": "返回一个数组，其中包含与给定的+选择器+（s）对应的+self+中的元素。\\n \\n选择器可以是整数索引或范围。\\n \\n另请参见数组选择。n \n   a = %w{ a b c d e f }\n   a.values_at(1, 3, 5)          # => [\"b\", \"d\", \"f\"]\n   a.values_at(1, 3, 5, 7)       # => [\"b\", \"d\", \"f\", nil]\n   a.values_at(-1, -2, -2, -7)   # => [\"f\", \"e\", \"e\", nil]\n   a.values_at(4..6, 3...6)      # => [\"e\", \"f\", nil, \"d\", \"e\", \"f\"]", "name": "values_at", "namespace": "Array", "path": "Array#values_at", "type": "instance_method", "visibility": "public"}, "Array#zip": {"description": "将任何参数转换为数组，然后将+self+的元素与每个参数中的相应元素合并。\\n \\n这会产生一个<code>ary.size</code>_u n_uuu-元素阵列的序列，其中n_u是一个超过参数计数的序列。\\n \\n如果任何参数的大小小于初始数组的大小，则提供+nil+个值。\\n \\n如果给定了块，则对每个输出+array+调用该块，否则将返回一个数组数组。n \n   a = [ 4, 5, 6 ]\n   b = [ 7, 8, 9 ]\n   [1, 2, 3].zip(a, b)   #=> [[1, 4, 7], [2, 5, 8], [3, 6, 9]]\n   [1, 2].zip(a, b)      #=> [[1, 4, 7], [2, 5, 8]]\n   a.zip([1, 2], [8])    #=> [[4, 1, 8], [5, 2, nil], [6, nil, nil]]", "name": "zip", "namespace": "Array", "path": "Array#zip", "type": "instance_method", "visibility": "public"}, "Array#|": {"description": "set union-返回一个新数组，方法是将+ary+与+other_ary+联接在一起，不包括任何重复项，并保留给定数组的顺序。\\n \\n它使用元素的哈希和eql比较元素？提高效率的方法。\\n \n   [ \"a\", \"b\", \"c\" ] | [ \"c\", \"d\", \"a\" ]    #=> [ \"a\", \"b\", \"c\", \"d\" ]\n   [ \"c\", \"d\", \"a\" ] | [ \"a\", \"b\", \"c\" ]    #=> [ \"c\", \"d\", \"a\", \"b\" ]\n \\n另请参阅数组uniq。", "name": "|", "namespace": "Array", "path": "Array#|", "type": "instance_method", "visibility": "public"}, "Array.[]": {"description": "返回用给定对象填充的新数组。n \n  Array.[]( 1, 'a', /^A/ ) # => [1, \"a\", /^A/]\n  Array[ 1, 'a', /^A/ ]    # => [1, \"a\", /^A/]\n  [ 1, 'a', /^A/ ]         # => [1, \"a\", /^A/]", "name": "[]", "namespace": "Array", "path": "Array.[]", "type": "class_method", "visibility": "public"}, "Array.try_convert": {"description": "尝试使用+to_ary+方法将+obj+转换为数组。如果由于任何原因无法转换+obj+，则返回已转换的数组或+nil+。\\n此方法可用于检查参数是否为数组。\\n \n   Array.try_convert([1])   #=> [1]\n   Array.try_convert(\"1\")   #=> nil\n\n   if tmp = Array.try_convert(arg)\n     # the argument is an array\n   elsif tmp = String.try_convert(arg)\n     # the argument is a string\n结束", "name": "try_convert", "namespace": "Array", "path": "Array.try_convert", "type": "class_method", "visibility": "public"}, "BasicObject": {"description": "basicObject是Ruby中所有类的父类。这是一个明确的空白类。\\n \\n BasicObject可用于创建独立于Ruby对象层次结构的对象层次结构、代理对象（如Delegator类）或其他必须避免Ruby方法和类的命名空间污染的用途。\\n \\n为避免对其他用户造成BasicObject污染，应创建一个适当命名的子类BasicObject，而不是直接修改BasicObject:\\n \n  class MyObjectSystem < BasicObject\n  end\n \\n BasicObject不包括内核（对于+puts+这样的方法），并且BasicObject在标准库的命名空间之外，因此如果不使用完整的cl，将无法找到常见类\\n驴子路。\\n \\n可以使用各种策略将标准库的有用部分提供给BasicObject的子类。子类可以通过<code>include Kernel</code>获得+puts+、+exit+等。可以创建和包含一个自定义的类内核模块，也可以通过缺少的方法使用委托：\n    def method_missing(name, *args, &block)\n      super unless DELEGATE.include? name\n      ::Kernel.send(name, *args, &block)\n    end\n000551\n    def respond_to_missing?(name, include_private = false)\n      DELEGATE.include?(name) or super\n    end\n  end\n\\n通过引用根类100中所需的常量，可以在BasicObject子类中获得从Ruby标准库访问类和模块的权限。0555或<code>::Enumerator</code>。\\n与方法丢失一样，const丢失可用于将常量查找委托给+object+：\\n \n  class MyObjectSystem < BasicObject\n    def self.const_missing(name)\n      ::Object.const_get(name)\n    end\n结束", "name": "BasicObject", "namespace": "", "path": "BasicObject", "type": "class", "visibility": "public"}, "BasicObject#!": {"description": "布尔否定。", "name": "!", "namespace": "BasicObject", "path": "BasicObject#!", "type": "instance_method", "visibility": "public"}, "BasicObject#!=": {"description": "如果两个对象不相等，则返回“真”，否则返回“假”。", "name": "!=", "namespace": "BasicObject", "path": "BasicObject#!=", "type": "instance_method", "visibility": "public"}, "BasicObject#==": {"description": "相等-在<code>Object</code>级别，只有当+obj+和+other+是同一对象时，<code>==</code>才会返回<code>true</code>。\\n通常，此方法在子类中被重写，以提供特定于类的含义。\\n \\n与<code>==</code>不同，<code>equal?</code>方法不应被子类重写，因为它用于确定对象标识\\n（即，如果<code>a</code>与<code>b</code>是同一对象，则<code>a.equal?(b)</code>）：\\n \n  obj = \"a\"\n  other = obj.dup\n\n  obj == other      #=> true\n  obj.equal? other  #=> false\n  obj.equal? obj    #=> true\n \\n如果+obj+和+other+引用同一哈希键，则<code>eql?</code>方法返回<code>true</code>。哈希使用它来测试成员是否相等。对于<code>Object</code>类的对象，<code>eql?</code>\\n与<code>==</code>同义。子类通常通过将<code>eql?</code>别名为其重写的<code>==</code>方法来延续这一传统，但也有例外。例如，<code>Numeric</code>类型在<code>==</code>之间执行类型转换，而不是在<code>eql?</code>之间执行类型转换，因此：\\n \n   1 == 1.0     #=> true\n   1.eql? 1.0   #=> false", "name": "==", "namespace": "BasicObject", "path": "BasicObject#==", "type": "instance_method", "visibility": "public"}, "BasicObject#__id__": {"description": "call seq:\n   obj.__id__       -> integer\n   obj.object_id    -> integer\n \\n返回+obj+的整数标识符。\\n \\n对于给定对象，对+object_id+的所有调用都将返回相同的数字，并且没有两个活动对象将共享一个ID。\\n \\n注意：内部类的某些对象将被重用以进行优化。\\n这是即时值和冻结字符串文本的情况。\\n \\n即时值不是通过引用传递的，而是通过以下值传递的：n +nil+、+true+、+false+、FixNums、符号和一些浮点值。n \n    Object.new.object_id  == Object.new.object_id  # => false\n    (21 * 2).object_id    == (21 * 2).object_id    # => true\n    \"hello\".object_id     == \"hello\".object_id     # => false\n    \"hi\".freeze.object_id == \"hi\".freeze.object_id # => true", "name": "__id__", "namespace": "BasicObject", "path": "BasicObject#__id__", "type": "instance_method", "visibility": "public"}, "BasicObject#__send__": {"description": "调用由\\u符号\\标识的方法，传递指定的任何\\n参数。如果名称+send+与obj中的现有方法冲突，则可以使用<code>__send__</code>。\\n当方法由字串识别时，字串会\\n转换为符号。n \n    class Klass\n      def hello(*args)\n        \"Hello \" + args.join(' ')\n      end\n    end\n    k = Klass.new\n    k.send :hello, \"gentle\", \"readers\"   #=> \"Hello gentle readers\"", "name": "__send__", "namespace": "BasicObject", "path": "BasicObject#__send__", "type": "instance_method", "visibility": "public"}, "BasicObject#equal?": {"description": "相等-在<code>Object</code>级别，只有当+obj+和+other+是同一对象时，<code>==</code>才会返回<code>true</code>。\\n通常，此方法在子类中被重写，以提供特定于类的含义。\\n \\n与<code>==</code>不同，<code>equal?</code>方法不应被子类重写，因为它用于确定对象标识\\n（即，如果<code>a</code>与<code>b</code>是同一对象，则<code>a.equal?(b)</code>）：\\n \n  obj = \"a\"\n  other = obj.dup\n\n  obj == other      #=> true\n  obj.equal? other  #=> false\n  obj.equal? obj    #=> true\n \\n如果+obj+和+other+引用同一哈希键，则<code>eql?</code>方法返回<code>true</code>。哈希使用它来测试成员是否相等。对于<code>Object</code>类的对象，<code>eql?</code>\\n与<code>==</code>同义。子类通常通过将<code>eql?</code>别名为其重写的<code>==</code>方法来延续这一传统，但也有例外。例如，<code>Numeric</code>类型在<code>==</code>之间执行类型转换，而不是在<code>eql?</code>之间执行类型转换，因此：\\n \n   1 == 1.0     #=> true\n   1.eql? 1.0   #=> false", "name": "equal?", "namespace": "BasicObject", "path": "BasicObject#equal?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "BasicObject#initialize": {"description": "未记录的", "name": "initialize", "namespace": "BasicObject", "path": "BasicObject#initialize", "type": "instance_method", "visibility": "private"}, "BasicObject#instance_eval": {"description": "在接收器（obj）上下文中计算包含ruby源代码或给定块的字符串。为了设置上下文，在代码执行时，变量+self+被设置为obj，使代码可以访问obj_uuuu的实例变量和私有方法。\\n \\n当给<code>instance_eval</code>一个块时，obj也作为块的唯一参数传入。\\n \\n当给予<code>instance_eval</code> +String+时，可选的第二个和第三个参数提供一个文件名和起始行号，在报告编译错误时使用该文件名和起始行号。n \n   class KlassWithSecret\n     def initialize\n       @secret = 99\n     end\n     private\n     def the_secret\n       \"Ssssh! The secret is #{@secret}.\"\n     end\n   end\n   k = KlassWithSecret.new\n   k.instance_eval { @secret }          #=> 99\n   k.instance_eval { the_secret }       #=> \"Ssssh! The secret is 99.\"\n   k.instance_eval {|obj| obj == self } #=> true", "name": "instance_eval", "namespace": "BasicObject", "path": "BasicObject#instance_eval", "type": "instance_method", "visibility": "public"}, "BasicObject#instance_exec": {"description": "在接收器（obj）的上下文中执行给定的块。为了设置上下文，在代码执行时变量+self+被设置为obj，这样代码就可以访问obj_uuuuu的实例变量。参数作为块参数传递。n \n   class KlassWithSecret\n     def initialize\n       @secret = 99\n     end\n   end\n   k = KlassWithSecret.new\n   k.instance_exec(5) {|x| @secret+x }   #=> 104", "name": "instance_exec", "namespace": "BasicObject", "path": "BasicObject#instance_exec", "type": "instance_method", "visibility": "public"}, "BasicObject#method_missing": {"description": "Ruby在发送一条它无法处理的消息时调用。\\n<i>symbol='i>是被调用方法的符号，而<i>args='i>\\n是传递给它的任何参数。默认情况下，当调用此方法时，解释器会引发错误。但是，可以重写该方法以提供更动态的行为。\\n如果决定不处理某个特定方法，则应调用\\n<i>super<i>super，以便祖先可以选择缺少的方法。\\n下面的示例创建了一个类<code>Roman</code>，该类用罗马数字组成的名称响应方法，并返回相应的整数值。n \n   class Roman\n     def roman_to_int(str)\n       # ...\n     end\n     def method_missing(methId)\n       str = methId.id2name\n       roman_to_int(str)\n     end\n   end\n\n   r = Roman.new\n   r.iv      #=> 4\n   r.xxiii   #=> 23\n   r.mm      #=> 2000", "name": "method_missing", "namespace": "BasicObject", "path": "BasicObject#method_missing", "type": "instance_method", "visibility": "private"}, "BasicObject#singleton_method_added": {"description": "未记录的", "name": "singleton_method_added", "namespace": "BasicObject", "path": "BasicObject#singleton_method_added", "type": "instance_method", "visibility": "private"}, "BasicObject#singleton_method_removed": {"description": "未记录的", "name": "singleton_method_removed", "namespace": "BasicObject", "path": "BasicObject#singleton_method_removed", "type": "instance_method", "visibility": "private"}, "BasicObject#singleton_method_undefined": {"description": "未记录的", "name": "singleton_method_undefined", "namespace": "BasicObject", "path": "BasicObject#singleton_method_undefined", "type": "instance_method", "visibility": "private"}, "Object": {"description": "对象是所有Ruby对象的默认根。对象继承自BasicObject，它允许创建备用对象层次结构。除非显式重写，否则对象上的方法对所有类都可用。\\n \\n object在内核模块中混合，使内置内核函数可全局访问。虽然对象的实例方法是由内核模块定义的，但是为了清晰起见，我们选择在这里记录它们。\\n \\n引用从对象继承的类中的常量时，不需要使用完整的命名空间。例如，在+YourClass+中引用+File+将找到顶级文件类。\\n \\n在对象方法的描述中，参数<i>symbol='i>引用的符号是带引号的字符串或符号（例如<code>:name</code>）。", "name": "Object", "namespace": "", "path": "Object", "type": "class", "visibility": "public"}, "Object#!~": {"description": "如果两个对象不匹配，则返回true（使用<i>=~<i>\\n方法），否则返回false。", "name": "!~", "namespace": "Object", "path": "Object#!~", "type": "instance_method", "visibility": "public"}, "Object#<=>": {"description": "如果+obj+和+other+是同一对象或<code>obj == other</code>，则返回0，否则返回nil。\\n \\n <code><=></code>被各种方法用于比较对象，例如Enumerable Sort、Enumerable Max等。\\n \\n您的<code><=></code>实现应返回以下值之一：-1、0、n 1或nil。-1表示自我比他人小。0表示自我等于他人。\\n 1表示self比other大。零表示无法比较这两个值。\\n \\n当您定义<code><=></code>时，您可以包括与获得方法<code><=</code>、<code><</code>, <code>==</code>、<code>>=</code>、<code>></code>和<code>between?</code>相当的方法。", "name": "<=>", "namespace": "Object", "path": "Object#<=>", "type": "instance_method", "visibility": "public"}, "Object#===": {"description": "iterates的给定的块，通过在integer价值从+int+到和包括+limit+。是的。如果没有布拉克是给定的，而enumerator是安全返回。   5.upto(10) {|i| print i, \" \" }   #=> 5 6 7 8 9 10 ---。", "name": "===", "namespace": "Object", "path": "Object#===", "type": "instance_method", "visibility": "public"}, "Object#=~": {"description": "模式匹配-由后代（尤其是<code>Regexp</code>和<code>String</code>）覆盖，以提供有意义的模式匹配语义。", "name": "=~", "namespace": "Object", "path": "Object#=~", "type": "instance_method", "visibility": "public"}, "Object#assert_Qundef": {"description": ":nodoc:", "name": "assert_Qundef", "namespace": "Object", "path": "Object#assert_Qundef", "type": "instance_method", "visibility": "public"}, "Object#class": {"description": "返回<i>obj>的类。必须始终使用显式接收器调用此方法，因为<code>class</code>也是Ruby中的保留字。n \n   1.class      #=> Integer\n   self.class   #=> Object", "name": "class", "namespace": "Object", "path": "Object#class", "type": "instance_method", "visibility": "public"}, "Object#clone": {"description": "生成<i>obj的浅副本---复制了\\n<i>obj的实例变量，但没有复制它们引用的对象。\\n <code>clone</code>复制冻结的（除非:freeze关键字参数的值为假）和污点状态<i>obj。\\n另请参阅<code>Object#dup</code>下的讨论。\\n \n   class Klass\n      attr_accessor :str\n   end\n   s1 = Klass.new      #=> #<Klass:0x401b3a38>\n   s1.str = \"Hello\"    #=> \"Hello\"\n   s2 = s1.clone       #=> #<Klass:0x401b3998 @str=\"Hello\">\n   s2.str[1,4] = \"i\"   #=> \"i\"\n   s1.inspect          #=> \"#<Klass:0x401b3a38 @str=\\\"Hi\\\">\"\n   s2.inspect          #=> \"#<Klass:0x401b3998 @str=\\\"Hi\\\">\"\n \\n此方法可能具有类特定的行为。如果是这样，该行为将记录在类的+initialize_copy+方法下。", "name": "clone", "namespace": "Object", "path": "Object#clone", "type": "instance_method", "visibility": "public"}, "Object#define_singleton_method": {"description": "在接收器中定义单例方法。方法参数可以是+Proc+、+Method+或+UnboundMethod+对象。\\n如果指定了块，则将其用作方法体。n \n   class A\n     class << self\n       def class_name\n         to_s\n       end\n     end\n   end\n   A.define_singleton_method(:who_am_i) do\n     \"I am: #{class_name}\"\n   end\n   A.who_am_i   # ==> \"I am: A\"\n\n   guy = \"Bob\"\n   guy.define_singleton_method(:hello) { \"#{self}: Hello there!\" }\n   guy.hello    #=>  \"Bob: Hello there!\"", "name": "define_singleton_method", "namespace": "Object", "path": "Object#define_singleton_method", "type": "instance_method", "visibility": "public"}, "Object#display": {"description": "在给定端口上打印（默认值<code>$></code>）。\\n相当于：\\n \n   def display(port=$>)\n     port.write self\n     nil\n   end\n \\n例如：\\n \n   1.display\n   \"cat\".display\n   [ 4, 5, 6 ].display\n   puts\n \\n<em>products:-\\n \\n 1cat[4，5，6]", "name": "display", "namespace": "Object", "path": "Object#display", "type": "instance_method", "visibility": "public"}, "Object#dup": {"description": "生成<i>obj的浅副本---复制了\\n<i>obj的实例变量，但没有复制它们引用的对象。\\n <code>dup</code>复制<i>obj>的污染状态。\\n \\n此方法可能具有类特定的行为。如果是这样，该行为将记录在类的+initialize_copy+方法下。\\n \\n===在dup与clone之间\\n \\n通常，<code>clone</code>和<code>dup</code>在后代类中可能具有不同的语义。虽然<code>clone</code>用于复制对象，包括其内部状态，但<code>dup</code> \\n通常使用子对象的类来创建新实例。\\n \\n使用dup时，不会复制对象扩展使用的任何模块。\\n \\n class klass \\n attr_accessor :str \\n end \\n \\n module foo \\n def foo;'foo'；end \\n \\n s1 = Klass.new #=> #<Klass:0x401b3a38> \\n s1.extend(Foo) #=> #<Klass:0x401b3a38> \\n s1.foo #=> \"foo\" \\n \\n s2 = s1.clone #=> #<Klass:0x401b3a38> \\n s2.foo #=> \"foo\" \\n \\n s3 = s1.dup #=> #<Klass:0x401b3a38> \\n s3.foo #=> NoMethodError: undefined method `foo' for #<Klass:0x401b3a38>", "name": "dup", "namespace": "Object", "path": "Object#dup", "type": "instance_method", "visibility": "public"}, "Object#enum_for": {"description": "创建一个新的枚举器，该枚举器将通过在+obj+上调用+method+进行枚举，如果有，则传递+args+。\\n \\n如果给定了块，它将用于计算枚举器的大小，而不需要对其进行迭代（请参见枚举器大小）。\\n \\n==示例\n  str = \"xyz\"\n\n  enum = str.enum_for(:each_byte)\n  enum.each { |b| puts b }\n  # => 120\n  # => 121\n  # => 122\n\n  # protect an array from being modified by some_method\n  a = [1, 2, 3]\n  some_method(a.to_enum)\n \\n在定义泛型可枚举的方法时（如果没有传递块），通常调用to_enum。\\n \\n下面是这样一个示例，其中参数传递和大小调整块为：\\n \n  module Enumerable\n    # a generic method to repeat the values of any enumerable\n    def repeat(n)\n      raise ArgumentError, \"#{n} is negative!\" if n < 0\n      unless block_given?\n        return to_enum(__method__, n) do # __method__ is :repeat here\n          sz = size     # Call size and multiply by n...\n          sz * n if sz  # but return nil if size itself is nil\n        end\n      end\n      each do |*val|\n        n.times { yield *val }\n      end\n    end\n  end\n\n  %i[hello world].repeat(2) { |w| puts w }\n    # => Prints 'hello', 'hello', 'world', 'world'\n  enum = (1..14).repeat(3)\n    # => returns an Enumerator when called without a block\n  enum.first(4) # => [1, 1, 1, 2]\n  enum.size # => 42", "name": "enum_for", "namespace": "Object", "path": "Object#enum_for", "type": "instance_method", "visibility": "public"}, "Object#eql?": {"description": "相等-在<code>Object</code>级别，只有当+obj+和+other+是同一对象时，<code>==</code>才会返回<code>true</code>。\\n通常，此方法在子类中被重写，以提供特定于类的含义。\\n \\n与<code>==</code>不同，<code>equal?</code>方法不应被子类重写，因为它用于确定对象标识\\n（即，如果<code>a</code>与<code>b</code>是同一对象，则<code>a.equal?(b)</code>）：\\n \n  obj = \"a\"\n  other = obj.dup\n\n  obj == other      #=> true\n  obj.equal? other  #=> false\n  obj.equal? obj    #=> true\n \\n如果+obj+和+other+引用同一哈希键，则<code>eql?</code>方法返回<code>true</code>。哈希使用它来测试成员是否相等。对于<code>Object</code>类的对象，<code>eql?</code>\\n与<code>==</code>同义。子类通常通过将<code>eql?</code>别名为其重写的<code>==</code>方法来延续这一传统，但也有例外。例如，<code>Numeric</code>类型在<code>==</code>之间执行类型转换，而不是在<code>eql?</code>之间执行类型转换，因此：\\n \n   1 == 1.0     #=> true\n   1.eql? 1.0   #=> false", "name": "eql?", "namespace": "Object", "path": "Object#eql?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Object#extend": {"description": "向obj添加每个模块作为参数提供的实例方法。n \n   module Mod\n     def hello\n       \"Hello from Mod.\\n\"\n     end\n   end\n\n   class Klass\n     def hello\n       \"Hello from Klass.\\n\"\n     end\n   end\n\n   k = Klass.new\n   k.hello         #=> \"Hello from Klass.\\n\"\n   k.extend(Mod)   #=> #<Klass:0x401b3bc8>\n   k.hello         #=> \"Hello from Mod.\\n\"", "name": "extend", "namespace": "Object", "path": "Object#extend", "type": "instance_method", "visibility": "public"}, "Object#freeze": {"description": "防止对obj进行进一步修改。如果尝试修改，将引发\\n <code>RuntimeError</code>。\\n无法解冻冻结的对象。另见<code>Object#frozen?</code>。\\n \\n此方法返回self。\\n \n   a = [ \"a\", \"b\", \"c\" ]\n   a.freeze\n   a << \"z\"\n \\n<em>产生：.-\\n \n   prog.rb:3:in `<<': can't modify frozen Array (FrozenError)\n   \tfrom prog.rb:3\n \\n下列类的对象始终被冻结：integer、\\n float、symbol。", "name": "freeze", "namespace": "Object", "path": "Object#freeze", "type": "instance_method", "visibility": "public"}, "Object#frozen?": {"description": "返回obj的冻结状态。n \n   a = [ \"a\", \"b\", \"c\" ]\n   a.freeze    #=> [\"a\", \"b\", \"c\"]\n   a.frozen?   #=> true", "name": "frozen?", "namespace": "Object", "path": "Object#frozen?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Object#hash": {"description": "", "name": "hash", "namespace": "Object", "path": "Object#hash", "type": "instance_method", "visibility": "public"}, "Object#initialize_clone": {"description": "!\n :nodoc:", "name": "initialize_clone", "namespace": "Object", "path": "Object#initialize_clone", "type": "instance_method", "visibility": "public"}, "Object#initialize_copy": {"description": ":nodoc:", "name": "initialize_copy", "namespace": "Object", "path": "Object#initialize_copy", "type": "instance_method", "visibility": "public"}, "Object#initialize_dup": {"description": "!\n :nodoc:", "name": "initialize_dup", "namespace": "Object", "path": "Object#initialize_dup", "type": "instance_method", "visibility": "public"}, "Object#inspect": {"description": "返回一个字符串，该字符串包含人类可读的<i>obj>\\n默认值<code>inspect</code>显示对象的类名、对象ID的编码以及实例变量及其值的列表（通过对每个变量调用inspect）。\\n用户定义的类应重写此方法，以便更好地表示<i>obj。重写此方法时，它应返回一个其编码与默认外部编码兼容的字符串。n \n   [ 1, 2, 3..4, 'five' ].inspect   #=> \"[1, 2, 3..4, \\\"five\\\"]\"\n   Time.new.inspect                 #=> \"2008-03-08 19:43:39 +0900\"\n\n   class Foo\n   end\n   Foo.new.inspect                  #=> \"#<Foo:0x0300c868>\"\n\n   class Bar\n     def initialize\n       @bar = 1\n     end\n   end\n   Bar.new.inspect                  #=> \"#<Bar:0x0300c868 @bar=1>\"", "name": "inspect", "namespace": "Object", "path": "Object#inspect", "type": "instance_method", "visibility": "public"}, "Object#instance_of?": {"description": "如果<i>obj<i>是给定类的实例，则返回<code>true</code>。另见<code>Object#kind_of?</code>。n \n   class A;     end\n   class B < A; end\n   class C < B; end\n\n   b = B.new\n   b.instance_of? A   #=> false\n   b.instance_of? B   #=> true\n   b.instance_of? C   #=> false", "name": "instance_of?", "namespace": "Object", "path": "Object#instance_of?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Object#instance_variable_defined?": {"description": "如果给定的实例变量在<i>obj>中定义，则返回<code>true</code>。\\n字符串参数转换为符号。n \n   class Fred\n     def initialize(p1, p2)\n       @a, @b = p1, p2\n     end\n   end\n   fred = Fred.new('cat', 99)\n   fred.instance_variable_defined?(:@a)    #=> true\n   fred.instance_variable_defined?(\"@b\")   #=> true\n   fred.instance_variable_defined?(\"@c\")   #=> false", "name": "instance_variable_defined?", "namespace": "Object", "path": "Object#instance_variable_defined?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Object#instance_variable_get": {"description": "返回给定实例变量的值，如果未设置实例变量，则返回nil。变量名的<code>@</code>部分应包含在常规实例变量中。如果提供的符号作为实例变量名无效，则引发<code>NameError</code>异常。\\n字符串参数转换为符号。n \n   class Fred\n     def initialize(p1, p2)\n       @a, @b = p1, p2\n     end\n   end\n   fred = Fred.new('cat', 99)\n   fred.instance_variable_get(:@a)    #=> \"cat\"\n   fred.instance_variable_get(\"@b\")   #=> 99", "name": "instance_variable_get", "namespace": "Object", "path": "Object#instance_variable_get", "type": "instance_method", "visibility": "public"}, "Object#instance_variable_set": {"description": "将名为<i>symbol<i>的实例变量设置为给定的\\n对象，从而使类作者尝试提供正确封装的工作失败。此变量在调用之前不必存在。\\n如果实例变量名作为字符串传递，则该字符串将转换为符号。n \n   class Fred\n     def initialize(p1, p2)\n       @a, @b = p1, p2\n     end\n   end\n   fred = Fred.new('cat', 99)\n   fred.instance_variable_set(:@a, 'dog')   #=> \"dog\"\n   fred.instance_variable_set(:@c, 'cat')   #=> \"cat\"\n   fred.inspect                             #=> \"#<Fred:0x401b3da8 @a=\\\"dog\\\", @b=99, @c=\\\"cat\\\">\"", "name": "instance_variable_set", "namespace": "Object", "path": "Object#instance_variable_set", "type": "instance_method", "visibility": "public"}, "Object#instance_variables": {"description": "返回接收器的实例变量名数组。注意，仅仅定义一个访问器并不会创建相应的实例变量。n \n   class Fred\n     attr_accessor :a1\n     def initialize\n       @iv = 3\n     end\n   end\n   Fred.new.instance_variables   #=> [:@iv]", "name": "instance_variables", "namespace": "Object", "path": "Object#instance_variables", "type": "instance_method", "visibility": "public"}, "Object#is_a?": {"description": "返回<code>true</code> if<i>class='i>is the class of \\n<i>obj='i>，or if<i>class='i>is one of the superclasses of \\n<i>obj='i>or modules included i n<i>obj.'i>。n \n   module M;    end\n   class A\n     include M\n   end\n   class B < A; end\n   class C < B; end\n\n   b = B.new\n   b.is_a? A          #=> true\n   b.is_a? B          #=> true\n   b.is_a? C          #=> false\n   b.is_a? M          #=> true\n\n   b.kind_of? A       #=> true\n   b.kind_of? B       #=> true\n   b.kind_of? C       #=> false\n   b.kind_of? M       #=> true", "name": "is_a?", "namespace": "Object", "path": "Object#is_a?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Object#itself": {"description": "返回接收器。n \n   string = \"my string\"\n   string.itself.object_id == string.object_id   #=> true", "name": "itself", "namespace": "Object", "path": "Object#itself", "type": "instance_method", "visibility": "public"}, "Object#kind_of?": {"description": "返回<code>true</code> if<i>class='i>is the class of \\n<i>obj='i>，or if<i>class='i>is one of the superclasses of \\n<i>obj='i>or modules included i n<i>obj.'i>。n \n   module M;    end\n   class A\n     include M\n   end\n   class B < A; end\n   class C < B; end\n\n   b = B.new\n   b.is_a? A          #=> true\n   b.is_a? B          #=> true\n   b.is_a? C          #=> false\n   b.is_a? M          #=> true\n\n   b.kind_of? A       #=> true\n   b.kind_of? B       #=> true\n   b.kind_of? C       #=> false\n   b.kind_of? M       #=> true", "name": "kind_of?", "namespace": "Object", "path": "Object#kind_of?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Object#method": {"description": "在<i>obj<i>中查找作为接收器的命名方法，返回<code>Method</code>对象（或提升<code>NameError</code>）。<code>Method</code>对象充当<i>obj的对象实例中的闭包，因此实例变量和<code>self</code>的值仍然可用。n \n   class Demo\n     def initialize(n)\n       @iv = n\n     end\n     def hello()\n       \"Hello, @iv = #{@iv}\"\n     end\n   end\n\n   k = Demo.new(99)\n   m = k.method(:hello)\n   m.call   #=> \"Hello, @iv = 99\"\n\n   l = Demo.new('Fred')\n   m = l.method(\"hello\")\n   m.call   #=> \"Hello, @iv = Fred\"", "name": "method", "namespace": "Object", "path": "Object#method", "type": "instance_method", "visibility": "public"}, "Object#methods": {"description": "返回obj的公共和受保护方法的名称列表。这将包括在obj的祖先中可以访问的所有方法。\\n如果可选参数为<code>false</code>，它将返回一个由<i>obj<i>的公共和受保护的singleton方法组成的数组，该数组将不包括<i>obj>中包含的模块中的方法。n \n   class Klass\n     def klass_method()\n     end\n   end\n   k = Klass.new\n   k.methods[0..9]    #=> [:klass_method, :nil?, :===,\n                      #    :==~, :!, :eql?\n                      #    :hash, :<=>, :class, :singleton_class]\n   k.methods.length   #=> 56\n\n   k.methods(false)   #=> []\n   def k.singleton_method; end\n   k.methods(false)   #=> [:singleton_method]\n\n   module M123; def m123; end end\n   k.extend M123\n   k.methods(false)   #=> [:singleton_method]", "name": "methods", "namespace": "Object", "path": "Object#methods", "type": "instance_method", "visibility": "public"}, "Object#nil?": {"description": "只有对象<i>nil</i>响应<code>true</code>到<code>nil?</code>。n \n   Object.new.nil?   #=> false\n   nil.nil?          #=> true", "name": "nil?", "namespace": "Object", "path": "Object#nil?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Object#object_id": {"description": "call seq:\n   obj.__id__       -> integer\n   obj.object_id    -> integer\n \\n返回+obj+的整数标识符。\\n \\n对于给定对象，对+object_id+的所有调用都将返回相同的数字，并且没有两个活动对象将共享一个ID。\\n \\n注意：内部类的某些对象将被重用以进行优化。\\n这是即时值和冻结字符串文本的情况。\\n \\n即时值不是通过引用传递的，而是通过以下值传递的：n +nil+、+true+、+false+、FixNums、符号和一些浮点值。n \n    Object.new.object_id  == Object.new.object_id  # => false\n    (21 * 2).object_id    == (21 * 2).object_id    # => true\n    \"hello\".object_id     == \"hello\".object_id     # => false\n    \"hi\".freeze.object_id == \"hi\".freeze.object_id # => true", "name": "object_id", "namespace": "Object", "path": "Object#object_id", "type": "instance_method", "visibility": "public"}, "Object#private_methods": {"description": "返回可访问的私有方法列表。如果<i>all<i>参数设置为<code>false</code>，则仅列出接收器中的那些方法。", "name": "private_methods", "namespace": "Object", "path": "Object#private_methods", "type": "instance_method", "visibility": "public"}, "Object#protected_methods": {"description": "返回可访问的受保护方法列表。如果<i>all<i>参数设置为<code>false</code>，则仅列出接收器中的那些方法。", "name": "protected_methods", "namespace": "Object", "path": "Object#protected_methods", "type": "instance_method", "visibility": "public"}, "Object#public_method": {"description": "与“方法”类似，只搜索公共方法。", "name": "public_method", "namespace": "Object", "path": "Object#public_method", "type": "instance_method", "visibility": "public"}, "Object#public_methods": {"description": "返回可由<i>obj访问的公共方法列表。如果<i>all<i>参数设置为<code>false</code>，则仅列出接收器中的那些方法。", "name": "public_methods", "namespace": "Object", "path": "Object#public_methods", "type": "instance_method", "visibility": "public"}, "Object#public_send": {"description": "调用由\\符号\\标识的方法，将指定的任何参数传递给它。与send不同，public_send只调用公共方法。\\n当方法由字符串标识时，该字符串将转换为符号。\\n \\n 1.public_send（：puts，“hello”）导致NoMethodError", "name": "public_send", "namespace": "Object", "path": "Object#public_send", "type": "instance_method", "visibility": "public"}, "Object#rawVALUE": {"description": ":nodoc:", "name": "rawVALUE", "namespace": "Object", "path": "Object#rawVALUE", "type": "instance_method", "visibility": "public"}, "Object#remove_instance_variable": {"description": "从<i>obj>中删除命名实例变量，返回该变量的值。n \n   class Dummy\n     attr_reader :var\n     def initialize\n       @var = 99\n     end\n     def remove\n       remove_instance_variable(:@var)\n     end\n   end\n   d = Dummy.new\n   d.var      #=> 99\n   d.remove   #=> 99\n   d.var      #=> nil", "name": "remove_instance_variable", "namespace": "Object", "path": "Object#remove_instance_variable", "type": "instance_method", "visibility": "public"}, "Object#respond_to?": {"description": "如果obj响应给定方法，则返回+true+。只有当可选的第二个参数的计算结果为+true+时，搜索中才包括私有方法和受保护方法。\\n \\n如果该方法未实现，则在Windows上为Process.fork，在GNU/Linux上为File.lchmod等，将返回\\n false。\\n \\n如果未定义方法，则调用<code>respond_to_missing?</code> \\n方法并返回结果。\\n \\n将method name参数指定为字符串时，该字符串将转换为符号。", "name": "respond_to?", "namespace": "Object", "path": "Object#respond_to?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Object#respond_to_missing?": {"description": "不要直接使用THIS。\\n \\n hook method返回obj_u是否可以响应\\u id方法。\\n \\n将method name参数指定为字符串时，该字符串将转换为符号。\\n \\n看到了吗？以及BasicObject的示例。", "name": "respond_to_missing?", "namespace": "Object", "path": "Object#respond_to_missing?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Object#send": {"description": "调用由\\u符号\\标识的方法，传递指定的任何\\n参数。如果名称+send+与obj中的现有方法冲突，则可以使用<code>__send__</code>。\\n当方法由字串识别时，字串会\\n转换为符号。n \n    class Klass\n      def hello(*args)\n        \"Hello \" + args.join(' ')\n      end\n    end\n    k = Klass.new\n    k.send :hello, \"gentle\", \"readers\"   #=> \"Hello gentle readers\"", "name": "send", "namespace": "Object", "path": "Object#send", "type": "instance_method", "visibility": "public"}, "Object#singleton_class": {"description": "返回<i>obj>的singleton类。如果<i>obj<i>没有singleton类，则此方法将创建一个新的singleton类。\\n \\n如果<i>obj，则它分别返回NilClass、TrueClass或FalseClass。\\n如果<i>obj<i>是整数、浮点或符号，则它将引发TypeError。n \n   Object.new.singleton_class  #=> #<Class:#<Object:0xb7ce1e24>>\n   String.singleton_class      #=> #<Class:String>\n   nil.singleton_class         #=> NilClass", "name": "singleton_class", "namespace": "Object", "path": "Object#singleton_class", "type": "instance_method", "visibility": "public"}, "Object#singleton_method": {"description": "与“方法”类似，只搜索单例方法。n \n   class Demo\n     def initialize(n)\n       @iv = n\n     end\n     def hello()\n       \"Hello, @iv = #{@iv}\"\n     end\n   end\n\n   k = Demo.new(99)\n   def k.hi\n     \"Hi, @iv = #{@iv}\"\n   end\n   m = k.singleton_method(:hi)\n   m.call   #=> \"Hi, @iv = 99\"\n   m = k.singleton_method(:hello) #=> NameError", "name": "singleton_method", "namespace": "Object", "path": "Object#singleton_method", "type": "instance_method", "visibility": "public"}, "Object#singleton_methods": {"description": "返回<i>obj>的singleton方法的名称数组。\\n如果可选的<i>all<i>参数为true，则列表将包括<i>obj中包含的模块中的方法。\\n只返回public和protected singleton方法。n \n   module Other\n     def three() end\n   end\n\n   class Single\n     def Single.four() end\n   end\n\n   a = Single.new\n\n   def a.one()\n   end\n\n   class << a\n     include Other\n     def two()\n     end\n   end\n\n   Single.singleton_methods    #=> [:four]\n   a.singleton_methods(false)  #=> [:two, :one]\n   a.singleton_methods         #=> [:two, :one, :three]", "name": "singleton_methods", "namespace": "Object", "path": "Object#singleton_methods", "type": "instance_method", "visibility": "public"}, "Object#taint": {"description": "把这个物体标上污点。\\n \\n标记为污染的对象将受到各种内置方法的限制。这是为了防止不安全的数据（如命令行参数或从内核获取的字符串）无意中损害用户的系统。\\n \\n若要检查对象是否被污染，请使用“被污染”？.\\n\\n只有在代码检查了受污染的对象并确定它是安全的情况下，才应取消对该对象的标记。为此，请使用取消标记。", "name": "taint", "namespace": "Object", "path": "Object#taint", "type": "instance_method", "visibility": "public"}, "Object#tainted?": {"description": "如果对象被污染，则返回true。\\n \\n有关详细信息，请参阅污点。", "name": "tainted?", "namespace": "Object", "path": "Object#tainted?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Object#tap": {"description": "将self转换为块，然后返回self。\\n此方法的主要目的是“利用”方法链，以便对链中的中间结果执行操作。\\n \n   (1..10)                  .tap {|x| puts \"original: #{x}\" }\n     .to_a                  .tap {|x| puts \"array:    #{x}\" }\n     .select {|x| x.even? } .tap {|x| puts \"evens:    #{x}\" }\n.地图x x*x.点击x放置“方块：{x}”", "name": "tap", "namespace": "Object", "path": "Object#tap", "type": "instance_method", "visibility": "public"}, "Object#to_enum": {"description": "创建一个新的枚举器，该枚举器将通过在+obj+上调用+method+进行枚举，如果有，则传递+args+。\\n \\n如果给定了块，它将用于计算枚举器的大小，而不需要对其进行迭代（请参见枚举器大小）。\\n \\n==示例\n  str = \"xyz\"\n\n  enum = str.enum_for(:each_byte)\n  enum.each { |b| puts b }\n  # => 120\n  # => 121\n  # => 122\n\n  # protect an array from being modified by some_method\n  a = [1, 2, 3]\n  some_method(a.to_enum)\n \\n在定义泛型可枚举的方法时（如果没有传递块），通常调用to_enum。\\n \\n下面是这样一个示例，其中参数传递和大小调整块为：\\n \n  module Enumerable\n    # a generic method to repeat the values of any enumerable\n    def repeat(n)\n      raise ArgumentError, \"#{n} is negative!\" if n < 0\n      unless block_given?\n        return to_enum(__method__, n) do # __method__ is :repeat here\n          sz = size     # Call size and multiply by n...\n          sz * n if sz  # but return nil if size itself is nil\n        end\n      end\n      each do |*val|\n        n.times { yield *val }\n      end\n    end\n  end\n\n  %i[hello world].repeat(2) { |w| puts w }\n    # => Prints 'hello', 'hello', 'world', 'world'\n  enum = (1..14).repeat(3)\n    # => returns an Enumerator when called without a block\n  enum.first(4) # => [1, 1, 1, 2]\n  enum.size # => 42", "name": "to_enum", "namespace": "Object", "path": "Object#to_enum", "type": "instance_method", "visibility": "public"}, "Object#to_s": {"description": "返回表示<i>obj>的字符串。默认的<code>to_s</code>打印对象的类和对象ID的编码。在特殊情况下，作为Ruby程序的初始执行上下文的顶级对象返回“main”。", "name": "to_s", "namespace": "Object", "path": "Object#to_s", "type": "instance_method", "visibility": "public"}, "Object#trust": {"description": "与untaint等效的方法已弃用。", "name": "trust", "namespace": "Object", "path": "Object#trust", "type": "instance_method", "visibility": "public"}, "Object#untaint": {"description": "从对象中删除污点标记。\\n \\n有关详细信息，请参阅污点。", "name": "untaint", "namespace": "Object", "path": "Object#untaint", "type": "instance_method", "visibility": "public"}, "Object#untrust": {"description": "已弃用与污点等效的方法。", "name": "untrust", "namespace": "Object", "path": "Object#untrust", "type": "instance_method", "visibility": "public"}, "Object#untrusted?": {"description": "已弃用的方法等同于污染？.", "name": "untrusted?", "namespace": "Object", "path": "Object#untrusted?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Object#validate_object": {"description": ":nodoc:", "name": "validate_object", "namespace": "Object", "path": "Object#validate_object", "type": "instance_method", "visibility": "public"}, "Object#yield_self": {"description": "向块生成self并返回块的结果。n \n   \"my string\".yield_self {|s| s.upcase }   #=> \"MY STRING\"\n   3.next.yield_self {|x| x**x }.to_s       #=> \"256\"", "name": "yield_self", "namespace": "Object", "path": "Object#yield_self", "type": "instance_method", "visibility": "public"}, "Object::Bignum": {"description": "", "name": "Bignum", "namespace": "Object", "path": "Object::Bignum", "type": "constant", "return": ["Class", ""], "visibility": "public"}, "Object::Fixnum": {"description": "", "name": "Fixnum", "namespace": "Object", "path": "Object::Fixnum", "type": "constant", "return": ["Class", ""], "visibility": "public"}, "Module": {"description": "*******************************************************************\\n\\n \n  A <code>Module</code> is a collection of methods and constants. The\n  methods in a module may be instance methods or module methods.\n  Instance methods appear as methods in a class when the module is\n  included, module methods do not. Conversely, module methods may be\n  called without creating an encapsulating object, while instance\n  methods may not. (See <code>Module#module_function</code>.)\n\n  In the descriptions that follow, the parameter <i>sym</i> refers\n  to a symbol, which is either a quoted string or a\n  <code>Symbol</code> (such as <code>:name</code>).\n\n     module Mod\n       include Math\n       CONST = 1\n       def meth\n         #  ...\n       end\n     end\n     Mod.class              #=> Module\n     Mod.constants          #=> [:CONST, :PI, :E]\n     Mod.instance_methods   #=> [:meth]", "name": "Module", "namespace": "", "path": "Module", "type": "class", "visibility": "public"}, "Module#<": {"description": "如果<i>mod<i>是<i>other<i>的子类，则返回true。如果两者之间没有关系，则返回<code>nil</code>。\\n（从类定义的角度考虑关系）：\\n“class a<b”表示“a<b”。）", "name": "<", "namespace": "Module", "path": "Module#<", "type": "instance_method", "visibility": "public"}, "Module#<=": {"description": "如果“mod”是“other”的子类或与“other”相同，则返回“true”。如果两者之间没有关系，则返回<code>nil</code>。\\n（从类定义的角度考虑关系）：\\n“class a<b”表示“a<b”。）", "name": "<=", "namespace": "Module", "path": "Module#<=", "type": "instance_method", "visibility": "public"}, "Module#<=>": {"description": "比较-返回-1、0、+1或nil，具体取决于+module+ \\n是否包含+other_module+、它们是否相同，或者+other_module+是否包含+module+。\\n \\n如果+module+与+other_module+没有关系，如果+other_module+不是模块，或者这两个值不可比，则返回+nil+。", "name": "<=>", "namespace": "Module", "path": "Module#<=>", "type": "instance_method", "visibility": "public"}, "Module#==": {"description": "相等-在<code>Object</code>级别，只有当+obj+和+other+是同一对象时，<code>==</code>才会返回<code>true</code>。\\n通常，此方法在子类中被重写，以提供特定于类的含义。\\n \\n与<code>==</code>不同，<code>equal?</code>方法不应被子类重写，因为它用于确定对象标识\\n（即，如果<code>a</code>与<code>b</code>是同一对象，则<code>a.equal?(b)</code>）：\\n \n  obj = \"a\"\n  other = obj.dup\n\n  obj == other      #=> true\n  obj.equal? other  #=> false\n  obj.equal? obj    #=> true\n \\n如果+obj+和+other+引用同一哈希键，则<code>eql?</code>方法返回<code>true</code>。哈希使用它来测试成员是否相等。对于<code>Object</code>类的对象，<code>eql?</code>\\n与<code>==</code>同义。子类通常通过将<code>eql?</code>别名为其重写的<code>==</code>方法来延续这一传统，但也有例外。例如，<code>Numeric</code>类型在<code>==</code>之间执行类型转换，而不是在<code>eql?</code>之间执行类型转换，因此：\\n \n   1 == 1.0     #=> true\n   1.eql? 1.0   #=> false", "name": "==", "namespace": "Module", "path": "Module#==", "type": "instance_method", "visibility": "public"}, "Module#===": {"description": "case equality-返回<code>true</code>，如果<i>obj<i>i s an \\n instance of<i>mod='i>or an instance of one of<i>mod='s descendants.\\n对模块的使用有限，但可以在<code>case</code>语句中按类对对象进行分类。", "name": "===", "namespace": "Module", "path": "Module#===", "type": "instance_method", "visibility": "public"}, "Module#>": {"description": "如果“mod”是“other”的祖先，则返回“true”。如果两者之间没有关系，则返回<code>nil</code>。\\n（从类定义的角度来考虑关系：\\n“class a<b”表示“b>a”。）", "name": ">", "namespace": "Module", "path": "Module#>", "type": "instance_method", "visibility": "public"}, "Module#>=": {"description": "如果<i>mod<i>是<i>other<i>的祖先，或两个模块相同，则返回true。如果两者之间没有关系，则返回<code>nil</code>。\\n（从类定义的角度来考虑关系：\\n“class a<b”表示“b>a”。）", "name": ">=", "namespace": "Module", "path": "Module#>=", "type": "instance_method", "visibility": "public"}, "Module#alias_method": {"description": "生成方法的新副本。这可以\\n用来保留对被重写的方法的访问。\\n \n   module Mod\n     alias_method :orig_exit, :exit\n     def exit(code=0)\n       puts \"Exiting with code #{code}\"\n       orig_exit(code)\n     end\n   end\n   include Mod\n   exit(99)\n \\n<em>生成：.<em>\\n \\n exiting with code 99", "name": "alias_method", "namespace": "Module", "path": "Module#alias_method", "type": "instance_method", "visibility": "public"}, "Module#ancestors": {"description": "返回在<i>mod中包含/预装的模块列表（包括<i>mod<i>itself）。n \n   module Mod\n     include Math\n     include Comparable\n     prepend Enumerable\n   end\n\n   Mod.ancestors        #=> [Enumerable, Mod, Comparable, Math]\n   Math.ancestors       #=> [Math]\n   Enumerable.ancestors #=> [Enumerable]", "name": "ancestors", "namespace": "Module", "path": "Module#ancestors", "type": "instance_method", "visibility": "public"}, "Module#append_features": {"description": "当这个模块包含在另一个模块中时，Ruby在这个模块中调用<code>append_features</code>，并将其传递给mod中的接收模块。Ruby的默认实现是将这个模块的常量、方法和模块变量添加到mod_u中，如果这个模块还没有添加到mod或其祖先中。另见<code>Module#include</code>。", "name": "append_features", "namespace": "Module", "path": "Module#append_features", "type": "instance_method", "visibility": "private"}, "Module#attr": {"description": "第一种形式相当于<code>attr_reader</code>。\\n第二个表单等价于<code>attr_accessor(name)</code>，但已弃用。\\n最后一个表单等同于<code>attr_reader(name)</code>，但已弃用。", "name": "attr", "namespace": "Module", "path": "Module#attr", "type": "instance_method", "visibility": "public"}, "Module#attr_accessor": {"description": "定义此模块的命名属性，其中名称为\\n<i>symbol.<i><code>id2name</code>，创建实例变量（<code>@name</code>）和相应的访问方法来读取它。\\n还创建一个名为<code>name=</code>的方法来设置属性。\\n字符串参数转换为符号。n \n   module Mod\n     attr_accessor(:one, :two)\n   end\n   Mod.instance_methods.sort   #=> [:one, :one=, :two, :two=]", "name": "attr_accessor", "namespace": "Module", "path": "Module#attr_accessor", "type": "instance_method", "visibility": "public"}, "Module#attr_reader": {"description": "创建实例变量和返回每个实例变量值的相应方法。相当于依次对每个名称调用“<code>attr</code>”。\\n字符串参数转换为符号。", "name": "attr_reader", "namespace": "Module", "path": "Module#attr_reader", "type": "instance_method", "visibility": "public"}, "Module#attr_writer": {"description": "创建一个访问器方法，以允许分配给属性\\n<i>symbol.<i><code>.id2name</code>。\\n字符串参数转换为符号。", "name": "attr_writer", "namespace": "Module", "path": "Module#attr_writer", "type": "instance_method", "visibility": "public"}, "Module#autoload": {"description": "在mod的命名空间中首次访问模块（可能是<code>String</code>或符号）时，注册要加载的文件名（使用<code>Kernel::require</code>）。\\n \n   module A\n   end\n   A.autoload(:B, \"b\")\n a:：b.doit自动加载“b”", "name": "autoload", "namespace": "Module", "path": "Module#autoload", "type": "instance_method", "visibility": "public"}, "Module#autoload?": {"description": "如果在_mod的名称空间中_name_u注册为+autoload+，则返回要加载的文件名。n \n   module A\n   end\n   A.autoload(:B, \"b\")\n   A.autoload?(:B)            #=> \"b\"", "name": "autoload?", "namespace": "Module", "path": "Module#autoload?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Module#class_eval": {"description": "在“mod”上下文中计算字符串或块，但在给定块时，常量/类变量查找不受影响。这可用于向类添加方法。<code>module_eval</code>返回计算其参数的结果。可选的filename_u和lineno参数设置错误消息的文本。\\n \n   class Thing\n   end\n   a = %q{def hello() \"Hello there!\" end}\n   Thing.module_eval(a)\n   puts Thing.new.hello()\n   Thing.module_eval(\"invalid code\", \"dummy\", 123)\n \\n<em>产生：.<em>\\n \n   Hello there!\n   dummy:123:in `module_eval': undefined local variable\n or method'code'for thing:class", "name": "class_eval", "namespace": "Module", "path": "Module#class_eval", "type": "instance_method", "visibility": "public"}, "Module#class_exec": {"description": "在类/模块的上下文中计算给定的块。\\n块中定义的方法将属于接收器。\\n传递给方法的任何参数都将传递给块。\\n如果块需要访问实例变量，则可以使用此选项。\\n \n   class Thing\n   end\n   Thing.class_exec{\n     def hello() \"Hello there!\" end\n   }\n   puts Thing.new.hello()\n \\n<em>生成：<em>\\n \\n Hello there！", "name": "class_exec", "namespace": "Module", "path": "Module#class_exec", "type": "instance_method", "visibility": "public"}, "Module#class_variable_defined?": {"description": "如果给定的类变量是在obj中定义的，则返回<code>true</code>。\\n字符串参数转换为符号。n \n   class Fred\n     @@foo = 99\n   end\n   Fred.class_variable_defined?(:@@foo)    #=> true\n   Fred.class_variable_defined?(:@@bar)    #=> false", "name": "class_variable_defined?", "namespace": "Module", "path": "Module#class_variable_defined?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Module#class_variable_get": {"description": "返回给定类变量的值（或引发<code>NameError</code>异常）。变量名的<code>@@</code>部分应包含在常规类变量中。\\n字符串参数转换为符号。n \n   class Fred\n     @@foo = 99\n   end\n   Fred.class_variable_get(:@@foo)     #=> 99", "name": "class_variable_get", "namespace": "Module", "path": "Module#class_variable_get", "type": "instance_method", "visibility": "public"}, "Module#class_variable_set": {"description": "将以<i>symbol<i>命名的类变量设置为给定的对象。\\n如果类变量名作为字符串传递，则该字符串将转换为符号。n \n   class Fred\n     @@foo = 99\n     def foo\n       @@foo\n     end\n   end\n   Fred.class_variable_set(:@@foo, 101)     #=> 101\n   Fred.new.foo                             #=> 101", "name": "class_variable_set", "namespace": "Module", "path": "Module#class_variable_set", "type": "instance_method", "visibility": "public"}, "Module#class_variables": {"description": "返回<i>mod>中类变量名称的数组。\\n这包括任何包含模块中的类变量的名称，除非<i>inherit<i>参数设置为<code>false</code>。n \n   class One\n     @@var1 = 1\n   end\n   class Two < One\n     @@var2 = 2\n   end\n   One.class_variables          #=> [:@@var1]\n   Two.class_variables          #=> [:@@var2, :@@var1]\n   Two.class_variables(false)   #=> [:@@var2]", "name": "class_variables", "namespace": "Module", "path": "Module#class_variables", "type": "instance_method", "visibility": "public"}, "Module#const_defined?": {"description": "说明mod或其祖先是否有一个具有给定名称的常量：\\n \n  Float.const_defined?(:EPSILON)      #=> true, found in Float itself\n  Float.const_defined?(\"String\")      #=> true, found in Object (ancestor)\n  BasicObject.const_defined?(:Hash)   #=> false\n \\n如果mod是+Module+，则另外检查+Object+及其祖先：\\n \n  Math.const_defined?(:String)   #=> true, found in Object\n \\n在每个选中的类或模块中，如果常量不存在但有自动加载，则直接返回+true+而不自动加载：\\n \n  module Admin\n    autoload :User, 'admin/user'\n  end\n  Admin.const_defined?(:User)   #=> true\n \\n如果找不到常量未调用回调+const_missing+，方法返回+false+。\\n \\n如果+inherit+为false，则查找仅检查接收器中的常量：\\n \n  IO.const_defined?(:SYNC)          #=> true, found in File::Constants (ancestor)\n  IO.const_defined?(:SYNC, false)   #=> false, not found in IO itself\n \\n在这种情况下，自动加载的相同逻辑也适用。\\n \\n如果参数不是有效的常量名，将引发+NameError+，并显示消息“错误的常量名\\名称\\”：\\n \\n   Hash.const_defined? 'foobar'   #=> NameError: wrong constant name foobar", "name": "const_defined?", "namespace": "Module", "path": "Module#const_defined?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Module#const_get": {"description": "在<i>mod>中检查具有给定名称的常量。\\n如果设置了+inherit+，则查找也将搜索祖先（如果<i>mod<i>is a +Module+，则搜索+Object+）。\\n \\n如果找到定义，将返回常量的值，否则将引发+NameError+。\\n \n   Math.const_get(:PI)   #=> 3.14159265358979\n \\n如果提供命名空间类名，此方法将递归查找常量名。例如：\\n \n   module Foo; class Bar; end end\n   Object.const_get 'Foo::Bar'\n \\n每次查找都要考虑+inherit+标志。例如：\\n \n   module Foo\n     class Bar\n       VAL = 10\n     end\n\n     class Baz < Bar; end\n   end\n\n   Object.const_get 'Foo::Baz::VAL'         # => 10\n   Object.const_get 'Foo::Baz::VAL', false  # => NameError\n \\n如果参数不是有效的常量名，则将引发+NameError+，并发出警告“常量名错误”。\\n n Object.const_get 'foobar' #=> NameError: wrong constant name foobar", "name": "const_get", "namespace": "Module", "path": "Module#const_get", "type": "instance_method", "visibility": "public"}, "Module#const_missing": {"description": "在mod中引用未定义的常量时调用。它被传递给未定义常量的符号，并返回一个用于该常量的值。下面的代码是相同的示例：\\n \n  def Foo.const_missing(name)\n    name # return the constant name as Symbol\n  end\n\n  Foo::UNDEFINED_CONST    #=> :UNDEFINED_CONST: symbol returned\n \\n在下一个示例中，当引用一个未定义的常量时，它试图加载一个文件，该文件的名称是常量的小写版本（因此，假定类<code>Fred</code>在文件<code>fred.rb</code>中）。如果找到，它将返回已加载的类。因此，它实现了类似于内核自动加载和模块自动加载的自动加载功能。N \n  def Object.const_missing(name)\n    @looked_for ||= {}\n    str_name = name.to_s\n    raise \"Class not found: #{name}\" if @looked_for[str_name]\n    @looked_for[str_name] = 1\n    file = str_name.downcase\n    require file\n    klass = const_get(name)\n    return klass if klass\n    raise \"Class not found: #{name}\"\n端", "name": "const_missing", "namespace": "Module", "path": "Module#const_missing", "type": "instance_method", "visibility": "public"}, "Module#const_set": {"description": "将命名常量设置为给定对象，并返回该对象。\\n如果以前不存在具有给定名称的常量，则创建一个新常量。\\n \n   Math.const_set(\"HIGH_SCHOOL_PI\", 22.0/7.0)   #=> 3.14285714285714\n   Math::HIGH_SCHOOL_PI - Math::PI              #=> 0.00126448926734968\n \\n如果+sym+或+str+不是有效的常量名称，将引发+NameError+，并发出警告“常量名称错误”。\\n n Object.const_set('foobar', 42) #=> NameError: wrong constant name foobar", "name": "const_set", "namespace": "Module", "path": "Module#const_set", "type": "instance_method", "visibility": "public"}, "Module#constants": {"description": "返回可在mod中访问的常量名称数组。这包括任何包含模块中常量的名称（例如，在节的开头），除非<i>inherit-\\n参数设置为<code>false</code>。\\n \\n实作无法保证产生常数的顺序。\\n \n  IO.constants.include?(:SYNC)        #=> true\n  IO.constants(false).include?(:SYNC) #=> false\n \\n另请参阅<code>Module::const_defined?</code>。", "name": "constants", "namespace": "Module", "path": "Module#constants", "type": "instance_method", "visibility": "public"}, "Module#define_method": {"description": "在接收器中定义实例方法。方法参数可以是+Proc+、+Method+或+UnboundMethod+对象。\\n如果指定了块，则将其用作方法体。此块使用<code>instance_eval</code>进行评估，这一点很难证明，因为<code>define_method</code>是私有的。\\n（这就是我们在本例中使用+send+黑客的原因。）\\n \n   class A\n     def fred\n       puts \"In Fred\"\n     end\n     def create_method(name, &block)\n       self.class.send(:define_method, name, &block)\n     end\n     define_method(:wilma) { puts \"Charge it!\" }\n   end\n   class B < A\n     define_method(:barney, instance_method(:fred))\n   end\n   a = B.new\n   a.barney\n   a.wilma\n   a.create_method(:betty) { p self }\n   a.betty\n \\n<em>products:-\\n \n   In Fred\n   Charge it!\n<b:0x401B39E8>", "name": "define_method", "namespace": "Module", "path": "Module#define_method", "type": "instance_method", "visibility": "public"}, "Module#deprecate_constant": {"description": "列出已弃用的现有常量。", "name": "deprecate_constant", "namespace": "Module", "path": "Module#deprecate_constant", "type": "instance_method", "visibility": "public"}, "Module#extend_object": {"description": "通过添加此模块的常量和方法（作为singleton方法添加）扩展指定的对象。这是<code>Object#extend</code>使用的回调方法。\\n \n   module Picky\n     def Picky.extend_object(o)\n       if String === o\n         puts \"Can't add Picky to a String\"\n       else\n         puts \"Picky added to #{o.class}\"\n         super\n       end\n     end\n   end\n   (s = Array.new).extend Picky  # Call Object.extend\n   (s = \"quick brown fox\").extend Picky\n \\n<em>生成：.<em>\\n \n   Picky added to Array\n can't add picky to a string", "name": "extend_object", "namespace": "Module", "path": "Module#extend_object", "type": "instance_method", "visibility": "private"}, "Module#extended": {"description": "未记录的", "name": "extended", "namespace": "Module", "path": "Module#extended", "type": "instance_method", "visibility": "private"}, "Module#freeze": {"description": "防止对<i>mod>\\n \\n此方法返回self。", "name": "freeze", "namespace": "Module", "path": "Module#freeze", "type": "instance_method", "visibility": "public"}, "Module#include": {"description": "以相反的顺序对每个参数调用<code>Module.append_features</code>。", "name": "include", "namespace": "Module", "path": "Module#include", "type": "instance_method", "visibility": "public"}, "Module#include?": {"description": "返回<code>true</code>，如果<i>module<i>包含在\\n<i>mod.<i>或其中一个<i>mod.<i>的祖先中。n \n   module A\n   end\n   class B\n     include A\n   end\n   class C < B\n   end\n   B.include?(A)   #=> true\n   C.include?(A)   #=> true\n   A.include?(A)   #=> false", "name": "include?", "namespace": "Module", "path": "Module#include?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Module#included": {"description": "未记录的", "name": "included", "namespace": "Module", "path": "Module#included", "type": "instance_method", "visibility": "private"}, "Module#included_modules": {"description": "返回包含在<i>mod<i>中的模块列表。n \n   module Mixin\n   end\n\n   module Outer\n     include Mixin\n   end\n\n   Mixin.included_modules   #=> []\n   Outer.included_modules   #=> [Mixin]", "name": "included_modules", "namespace": "Module", "path": "Module#included_modules", "type": "instance_method", "visibility": "public"}, "Module#initialize": {"description": "创建新的匿名模块。如果给定了一个块，它将传递给module对象，并在该模块的上下文（如<code>module_eval</code>）中对该块进行计算。\\n \n   fred = Module.new do\n     def meth1\n       \"hello\"\n     end\n     def meth2\n       \"bye\"\n     end\n   end\n   a = \"my string\"\n   a.extend(fred)   #=> \"my string\"\n   a.meth1          #=> \"hello\"\n   a.meth2          #=> \"bye\"\n \\n如果要将模块视为常规模块，请将该模块分配给常量（名称以大写开始）。", "name": "initialize", "namespace": "Module", "path": "Module#initialize", "type": "instance_method", "visibility": "public"}, "Module#initialize_clone": {"description": ":nodoc:", "name": "initialize_clone", "namespace": "Module", "path": "Module#initialize_clone", "type": "instance_method", "visibility": "public"}, "Module#initialize_copy": {"description": ":nodoc:", "name": "initialize_copy", "namespace": "Module", "path": "Module#initialize_copy", "type": "instance_method", "visibility": "public"}, "Module#inspect": {"description": "返回表示此模块或类的字符串。对于基本类和模块，这是名称。对于单件，我们也会显示我们所附的信息。", "name": "inspect", "namespace": "Module", "path": "Module#inspect", "type": "instance_method", "visibility": "public"}, "Module#instance_method": {"description": "返回表示mod中给定实例方法的+UnboundMethod+。\\n +self+91\n   interpreter = Interpreter.new\n   interpreter.interpret('dave')\n \\n<em>生成：.<em>\\n \\n Hello there，Dave！", "name": "instance_method", "namespace": "Module", "path": "Module#instance_method", "type": "instance_method", "visibility": "public"}, "Module#instance_methods": {"description": "返回一个数组，该数组包含接收器中公共和受保护实例方法的名称。对于一个模块，这些是公共的和受保护的methods;类，它们是实例（而不是单例）方法。如果可选参数为<code>false</code>，则不包括任何祖先的方法。n 100<code>String#chomp</code>1003   C.instance_methods.include?(:method2)       #=> true", "name": "instance_methods", "namespace": "Module", "path": "Module#instance_methods", "type": "instance_method", "visibility": "public"}, "Module#method_added": {"description": "未记录的", "name": "method_added", "namespace": "Module", "path": "Module#method_added", "type": "instance_method", "visibility": "private"}, "Module#method_defined?": {"description": "如果命名方法由mod（或其包含的模块）定义，并且mod是类，则返回+true+。公共方法和受保护方法是匹配的。\\n字符串参数转换为符号。n 100+iseq+1008   C.method_defined? \"private_method2\"     #=> false", "name": "method_defined?", "namespace": "Module", "path": "Module#method_defined?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Module#method_removed": {"description": "未记录的", "name": "method_removed", "namespace": "Module", "path": "Module#method_removed", "type": "instance_method", "visibility": "private"}, "Module#method_undefined": {"description": "未记录的", "name": "method_undefined", "namespace": "Module", "path": "Module#method_undefined", "type": "instance_method", "visibility": "private"}, "Module#module_eval": {"description": "在“mod”上下文中计算字符串或块，但在给定块时，常量/类变量查找不受影响。这可用于向类添加方法。<code>module_eval</code>返回计算其参数的结果。可选的filename_u和lineno参数设置错误消息的文本。\\n \n   class Thing\n   end\n   a = %q{def hello() \"Hello there!\" end}\n   Thing.module_eval(a)\n   puts Thing.new.hello()\n   Thing.module_eval(\"invalid code\", \"dummy\", 123)\n \\n<em>产生：.<em>\\n \n   Hello there!\n   dummy:123:in `module_eval': undefined local variable\n or method'code'for thing:class", "name": "module_eval", "namespace": "Module", "path": "Module#module_eval", "type": "instance_method", "visibility": "public"}, "Module#module_exec": {"description": "在类/模块的上下文中计算给定的块。\\n块中定义的方法将属于接收器。\\n传递给方法的任何参数都将传递给块。\\n如果块需要访问实例变量，则可以使用此选项。\\n \n   class Thing\n   end\n   Thing.class_exec{\n     def hello() \"Hello there!\" end\n   }\n   puts Thing.new.hello()\n \\n<em>生成：<em>\\n \\n Hello there！", "name": "module_exec", "namespace": "Module", "path": "Module#module_exec", "type": "instance_method", "visibility": "public"}, "Module#module_function": {"description": "为命名方法创建模块函数。这些函数可以用模块作为接收器来调用，也可以作为混合在模块中的类的实例方法来调用。模块功能是原始功能的副本，因此可以单独更改。实例方法版本变为私有。如果不带参数使用，随后定义的方法将成为模块函数。\\n字符串参数转换为符号。n \n   module Mod\n     def one\n       \"This is one\"\n     end\n     module_function :one\n   end\n   class Cls\n     include Mod\n     def call_one\n       one\n     end\n   end\n   Mod.one     #=> \"This is one\"\n   c = Cls.new\n   c.call_one  #=> \"This is one\"\n   module Mod\n     def one\n       \"This is the new one\"\n     end\n   end\n   Mod.one     #=> \"This is one\"\n   c.call_one  #=> \"This is the new one\"", "name": "module_function", "namespace": "Module", "path": "Module#module_function", "type": "instance_method", "visibility": "private"}, "Module#name": {"description": "返回模块的名称。匿名模块返回nil。", "name": "name", "namespace": "Module", "path": "Module#name", "type": "instance_method", "visibility": "public"}, "Module#prepend": {"description": "以相反的顺序对每个参数调用<code>Module.prepend_features</code>。", "name": "prepend", "namespace": "Module", "path": "Module#prepend", "type": "instance_method", "visibility": "public"}, "Module#prepend_features": {"description": "当这个模块在另一个模块中预先结束时，Ruby在这个模块中调用<code>prepend_features</code>，并将其传递给mod中的接收模块。Ruby的默认实现是将这个模块的常量、方法和模块变量叠加到mod_u中，前提是这个模块还没有添加到mod或其祖先中。另见<code>Module#prepend</code>。", "name": "prepend_features", "namespace": "Module", "path": "Module#prepend_features", "type": "instance_method", "visibility": "private"}, "Module#prepended": {"description": "未记录的", "name": "prepended", "namespace": "Module", "path": "Module#prepended", "type": "instance_method", "visibility": "private"}, "Module#private": {"description": "如果没有参数，则将随后定义的方法的默认可见性设置为private。使用参数，将命名方法设置为具有私有可见性。\\n字符串参数转换为符号。\\n \n   module Mod\n     def a()  end\n     def b()  end\n     private\n     def c()  end\n     private :a\n   end\n   Mod.private_instance_methods   #=> [:a, :c]\n \\n请注意，若要在RDOC上显示私有方法，请使用<code>:doc:</code>。", "name": "private", "namespace": "Module", "path": "Module#private", "type": "instance_method", "visibility": "private"}, "Module#private_class_method": {"description": "使现有类方法成为私有方法。通常用于隐藏默认的构造函数<code>new</code>。\\n \\n字符串参数转换为符号。\\n \n   class SimpleSingleton  # Not thread safe\n     private_class_method :new\n     def SimpleSingleton.create(*args, &block)\n       @me = new(*args, &block) if ! @me\n       @me\n     end\n结束", "name": "private_class_method", "namespace": "Module", "path": "Module#private_class_method", "type": "instance_method", "visibility": "public"}, "Module#private_constant": {"description": "将现有常量的列表设为私有。", "name": "private_constant", "namespace": "Module", "path": "Module#private_constant", "type": "instance_method", "visibility": "public"}, "Module#private_instance_methods": {"description": "返回在mod中定义的私有实例方法的列表。如果可选参数为<code>false</code>，则不包括任何祖先的方法。n \n   module Mod\n     def method1()  end\n     private :method1\n     def method2()  end\n   end\n   Mod.instance_methods           #=> [:method2]\n   Mod.private_instance_methods   #=> [:method1]", "name": "private_instance_methods", "namespace": "Module", "path": "Module#private_instance_methods", "type": "instance_method", "visibility": "public"}, "Module#private_method_defined?": {"description": "如果命名的私有方法由mod_（或其包含的模块）定义，并且如果mod是类，则返回+true+。\\n字符串参数转换为符号。n \n   module A\n     def method1()  end\n   end\n   class B\n     private\n     def method2()  end\n   end\n   class C < B\n     include A\n     def method3()  end\n   end\n\n   A.method_defined? :method1            #=> true\n   C.private_method_defined? \"method1\"   #=> false\n   C.private_method_defined? \"method2\"   #=> true\n   C.method_defined? \"method2\"           #=> false", "name": "private_method_defined?", "namespace": "Module", "path": "Module#private_method_defined?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Module#protected": {"description": "如果没有参数，则将随后定义的方法的默认可见性设置为“受保护”。使用参数，将命名方法设置为具有受保护的可见性。\\n字符串参数转换为符号。\\n \\n如果方法具有受保护的可见性，则只能在上下文的<code>self</code>与该方法相同的情况下调用该方法。\\n（方法定义或实例评估）。这种行为不同于Java的受保护方法。通常应使用<code>private</code>。\\n \\n请注意，受保护的方法速度较慢，因为它不能使用内联缓存。\\n \\n若要在RDOC上显示私有方法，请使用<code>:doc:</code>而不是此方法。", "name": "protected", "namespace": "Module", "path": "Module#protected", "type": "instance_method", "visibility": "private"}, "Module#protected_instance_methods": {"description": "返回在mod中定义的受保护实例方法的列表。如果可选参数为<code>false</code>，则不包括任何祖先的方法。", "name": "protected_instance_methods", "namespace": "Module", "path": "Module#protected_instance_methods", "type": "instance_method", "visibility": "public"}, "Module#protected_method_defined?": {"description": "如果命名的受保护方法由mod（或其包含的模块）定义，并且mod是类，则返回+true+。\\n字符串参数转换为符号。n \n   module A\n     def method1()  end\n   end\n   class B\n     protected\n     def method2()  end\n   end\n   class C < B\n     include A\n     def method3()  end\n   end\n\n   A.method_defined? :method1              #=> true\n   C.protected_method_defined? \"method1\"   #=> false\n   C.protected_method_defined? \"method2\"   #=> true\n   C.method_defined? \"method2\"             #=> true", "name": "protected_method_defined?", "namespace": "Module", "path": "Module#protected_method_defined?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Module#public": {"description": "如果没有参数，则将随后定义的方法的默认可见性设置为public。使用参数，将命名方法设置为具有公共可见性。\\n字符串参数转换为符号。", "name": "public", "namespace": "Module", "path": "Module#public", "type": "instance_method", "visibility": "private"}, "Module#public_class_method": {"description": "将现有类方法的列表设为公共。\\n \\n字符串参数转换为符号。", "name": "public_class_method", "namespace": "Module", "path": "Module#public_class_method", "type": "instance_method", "visibility": "public"}, "Module#public_constant": {"description": "将现有常量的列表公开。", "name": "public_constant", "namespace": "Module", "path": "Module#public_constant", "type": "instance_method", "visibility": "public"}, "Module#public_instance_method": {"description": "类似于实例方法，只搜索公共方法。", "name": "public_instance_method", "namespace": "Module", "path": "Module#public_instance_method", "type": "instance_method", "visibility": "public"}, "Module#public_instance_methods": {"description": "返回在<i>mod>中定义的公共实例方法的列表。\\n如果可选参数为<code>false</code>，则不包括任何祖先的方法。", "name": "public_instance_methods", "namespace": "Module", "path": "Module#public_instance_methods", "type": "instance_method", "visibility": "public"}, "Module#public_method_defined?": {"description": "如果指定的公共方法由mod（或其包含的模块）定义，并且mod是类，则返回+true+。\\n字符串参数转换为符号。n \n   module A\n     def method1()  end\n   end\n   class B\n     protected\n     def method2()  end\n   end\n   class C < B\n     include A\n     def method3()  end\n   end\n\n   A.method_defined? :method1           #=> true\n   C.public_method_defined? \"method1\"   #=> true\n   C.public_method_defined? \"method2\"   #=> false\n   C.method_defined? \"method2\"          #=> true", "name": "public_method_defined?", "namespace": "Module", "path": "Module#public_method_defined?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Module#refine": {"description": "在接收器中优化<i>mod.<i>\\n \\n返回定义了优化方法的模块。", "name": "refine", "namespace": "Module", "path": "Module#refine", "type": "instance_method", "visibility": "private"}, "Module#remove_class_variable": {"description": "删除<i>sym的定义，返回该常量的值。\\n \n   class Dummy\n     @@var = 99\n     puts @@var\n     remove_class_variable(:@@var)\n     p(defined? @@var)\n   end\n \\n<em>产生：.<em>\\n \n   99\n nil", "name": "remove_class_variable", "namespace": "Module", "path": "Module#remove_class_variable", "type": "instance_method", "visibility": "public"}, "Module#remove_const": {"description": "移除给定常量的定义，返回该常量的前一个值。如果该常量引用模块，则不会更改该模块的名称，并可能导致混淆。", "name": "remove_const", "namespace": "Module", "path": "Module#remove_const", "type": "instance_method", "visibility": "private"}, "Module#remove_method": {"description": "从当前类中移除由符号标识的方法。例如，请参见<code>Module.undef_method</code>。\\n字符串参数转换为符号。", "name": "remove_method", "namespace": "Module", "path": "Module#remove_method", "type": "instance_method", "visibility": "public"}, "Module#singleton_class?": {"description": "如果<i>mod<i>is a singleton class or <code>false</code> if it is a normal class or module，则返回<code>true</code>。n \n   class C\n   end\n   C.singleton_class?                  #=> false\n   C.singleton_class.singleton_class?  #=> true", "name": "singleton_class?", "namespace": "Module", "path": "Module#singleton_class?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Module#to_s": {"description": "返回表示此模块或类的字符串。对于基本类和模块，这是名称。对于单件，我们也会显示我们所附的信息。", "name": "inspect", "namespace": "Module", "path": "Module#inspect", "type": "instance_method", "visibility": "public"}, "Module#undef_method": {"description": "阻止当前类响应对命名方法的调用。与<code>remove_method</code>相比，它从特定的class;中删除了该方法，Ruby仍然会搜索超类并在模块中混合查找可能的接收器。\\n字符串参数转换为符号。\\n \n   class Parent\n     def hello\n       puts \"In parent\"\n     end\n   end\n   class Child < Parent\n     def hello\n       puts \"In child\"\n     end\n   end\n \\n \n   c = Child.new\n   c.hello\n \\n \n   class Child\n     remove_method :hello  # remove from child, still in parent\n   end\n   c.hello\n \\n \n   class Child\n     undef_method :hello   # prevent any calls to 'hello'\n   end\n   c.hello\n \\n<em>products:-<em>\\n \n   In child\n   In parent\n prog.rb:23:Undefined method`hello'for<child:0x401b3bb4>（NoMethodError）", "name": "undef_method", "namespace": "Module", "path": "Module#undef_method", "type": "instance_method", "visibility": "public"}, "Module#using": {"description": "将类优化从模块导入到当前类或模块定义中。", "name": "using", "namespace": "Module", "path": "Module#using", "type": "instance_method", "visibility": "private"}, "Module.constants": {"description": "在第一个窗体中，返回从调用点可访问的所有常量的名称数组。\\n此列表包括全局范围中定义的所有模块和类的名称。\\n \n   Module.constants.first(4)\n      # => [:ARGF, :ARGV, :ArgumentError, :Array]\n\n   Module.constants.include?(:SEEK_SET)   # => false\n\n   class IO\n     Module.constants.include?(:SEEK_SET) # => true\n   end\n \\n第二个窗体调用实例方法+constants+。", "name": "constants", "namespace": "Module", "path": "Module.constants", "type": "class_method", "visibility": "public"}, "Module.nesting": {"description": "返回嵌套在调用点的+Modules+列表。n \n   module M1\n     module M2\n       $a = Module.nesting\n     end\n   end\n   $a           #=> [M1::M2, M1]\n   $a[0].name   #=> \"M1::M2\"", "name": "nesting", "namespace": "Module", "path": "Module.nesting", "type": "class_method", "visibility": "public"}, "Module.used_modules": {"description": "返回当前作用域中使用的所有模块的数组。未定义结果数组中模块的顺序。\\n \n   module A\n     refine Object do\n     end\n   end\n100169\n   using A\n   using B\n   p Module.used_modules\n \\n<em>products:-\\n \\n[b，a]", "name": "used_modules", "namespace": "Module", "path": "Module.used_modules", "type": "class_method", "visibility": "public"}, "Class": {"description": "Ruby中的类是第一类对象——每个都是类<code>Class</code>的一个实例。\\n \\n通常，您使用以下命令创建新类：创建新类时，将初始化一个class类型的对象并将其分配给全局常量（本例中为<code>Name</code>）。\\n \\n当调用<code>Name.new</code>创建新对象时，默认情况下会运行<code>Class</code>中的<code>new</code>方法。\\n这可以通过重写<code>Class</code>中的<code>new</code>来演示：\\n \n   class Class\n     alias old_new new\n     def new(*args)\n       print \"Creating a new \", self.name, \"\\n\"\n       old_new(*args)\n     end\n   end\n+true+73\n   n = Name.new\n \\n<em>products:-\\n \n   Creating a new Name\n \\n classes，modules，and objects are interrelated.在下面的图表中，垂直箭头表示继承，括号表示元类。所有元类都是类“class”的实例。\n                           +---------+             +-...\n                           |         |             |\n           BasicObject-----|-->(BasicObject)-------|-...\n               ^           |         ^             |\n               |           |         |             |\n            Object---------|----->(Object)---------|-...\n               ^           |         ^             |\n               |           |         |             |\n               +-------+   |         +--------+    |\n               |       |   |         |        |    |\n               |    Module-|---------|--->(Module)-|-...\n               |       ^   |         |        ^    |\n               |       |   |         |        |    |\n               |     Class-|---------|---->(Class)-|-...\n               |       ^   |         |        ^    |\n               |       +---+         |        +----+\n               |                     |\n对象--->OtherClass----->（OtherClass）------…", "name": "Class", "namespace": "", "path": "Class", "type": "class", "visibility": "public"}, "Class#allocate": {"description": "为<i>类的新对象分配空间，并且不在新实例上调用initialize。返回的对象必须是<i>类的\\n实例。\\n \n    klass = Class.new do\n      def initialize(*args)\n        @initialized = true\n      end\n\n      def initialized?\n        @initialized || false\n      end\n    end\n \\n     klass.allocate.initialized? #=> false", "name": "allocate", "namespace": "Class", "path": "Class#allocate", "type": "instance_method", "visibility": "public"}, "Class#inherited": {"description": "未记录的", "name": "inherited", "namespace": "Class", "path": "Class#inherited", "type": "instance_method", "visibility": "private"}, "Class#initialize": {"description": "使用给定的超类（如果没有给定参数，则为<code>Object</code>）创建一个新的匿名（未命名）类。通过将类对象分配给常量，可以为类命名。\\n \\n如果给定了块，则会将其传递给Class对象，并在类（如<code>class_eval</code>）的上下文中对该块进行计算。\\n \n   fred = Class.new do\n     def meth1\n       \"hello\"\n     end\n     def meth2\n       \"bye\"\n     end\n   end\n\n   a = fred.new     #=> #<#<Class:0xSignal.trap90>:0x100376b98>\n   a.meth1          #=> \"hello\"\n   a.meth2          #=> \"bye\"\n \\n如果要将类视为常规类，请将该类分配给常量（名称以大写开始）。", "name": "initialize", "namespace": "Class", "path": "Class#initialize", "type": "instance_method", "visibility": "public"}, "Class#new": {"description": "调用<code>allocate</code>以创建\\n<i>类的新对象，然后调用该对象的<code>initialize</code>方法，并将其传递给<i>args。\\n每当使用.new构造对象时，都会调用此方法。", "name": "new", "namespace": "Class", "path": "Class#new", "type": "instance_method", "visibility": "public"}, "Class#superclass": {"description": "返回<i>class<i>或<code>nil</code>的超类。\\n \n   File.superclass          #=> IO\n   IO.superclass            #=> Object\n   Object.superclass        #=> BasicObject\n   class Foo; end\n   class Bar < Foo; end\n   Bar.superclass           #=> Foo\n \\n当给定的类没有父类时返回nil:\\n \\n    BasicObject.superclass   #=> nil", "name": "superclass", "namespace": "Class", "path": "Class#superclass", "type": "instance_method", "visibility": "public"}, "Comparable": {"description": "<code>Comparable</code> mixin由其对象可以排序的类使用。类必须定义<code><=></code>运算符，该运算符将接收器与另一个对象进行比较，返回-1、0、n或+1，具体取决于接收器是否小于、等于或大于另一个对象。如果另一个对象不可比较，则<code><=></code>运算符应返回nil。\\n <code>Comparable</code>使用<code><=></code>实现常规比较运算符（<code><</code>, <code><=</code>、<code>==</code>、<code>>=</code>、\\n和<code>></code>）和方法<code>between?</code>。n \n   class SizeMatters\n     include Comparable\n     attr :str\n     def <=>(other)\n       str.size <=> other.str.size\n     end\n     def initialize(str)\n       @str = str\n     end\n     def inspect\n       @str\n     end\n   end\n1001+UnboundMethod+101   [ s3, s2, s5, s4, s1 ].sort   #=> [Z, YY, XXX, WWWW, VVVVV]", "name": "Comparable", "namespace": "", "path": "Comparable", "type": "module", "visibility": "public"}, "Comparable#<": {"description": "基于接收器的<code><=></code>方法比较两个对象，如果返回-1，则返回true。", "name": "<", "namespace": "Comparable", "path": "Comparable#<", "type": "module_function", "visibility": "public"}, "Comparable#<=": {"description": "基于接收器的<code><=></code>方法比较两个对象，如果返回-1或0，则返回true。", "name": "<=", "namespace": "Comparable", "path": "Comparable#<=", "type": "module_function", "visibility": "public"}, "Comparable#==": {"description": "基于接收器的<code><=></code>方法比较两个对象，如果返回0，则返回true。如果obj_u和其他对象是同一对象，则返回true。", "name": "==", "namespace": "Comparable", "path": "Comparable#==", "type": "module_function", "visibility": "public"}, "Comparable#>": {"description": "基于接收器的<code><=></code>方法比较两个对象，如果返回1，则返回true。", "name": ">", "namespace": "Comparable", "path": "Comparable#>", "type": "module_function", "visibility": "public"}, "Comparable#>=": {"description": "基于接收器的<code><=></code>方法比较两个对象，如果返回0或1，则返回true。", "name": ">=", "namespace": "Comparable", "path": "Comparable#>=", "type": "module_function", "visibility": "public"}, "Comparable#between?": {"description": "如果<i>obj，返回<code>false</code>；如果<i><code><=></code>，返回<code>false</code>；如果<i>min，返回<code>false</code>；如果<i>anobject，返回<code><=></code>；如果<i>max，返回<code>false</code>；否则返回<code>true</code>。n \n   3.between?(1, 5)               #=> true\n   6.between?(1, 5)               #=> false\n   'cat'.between?('ant', 'dog')   #=> true\n   'gnu'.between?('ant', 'dog')   #=> false", "name": "between?", "namespace": "Comparable", "path": "Comparable#between?", "type": "module_function", "visibility": "public", "return": [["Boolean"], ""]}, "Comparable#clamp": {"description": "返回<i>min</i>if<i>obj</i><code><=></code><i>min</i>is less than zero，<i>max</i>if<i>obj</i><code><=></code><i>max</i>is greater than zero and<i>obj</i>otherwise.n \n   12.clamp(0, 100)         #=> 12\n   523.clamp(0, 100)        #=> 100\n   -3.123.clamp(0, 100)     #=> 0\n\n   'd'.clamp('a', 'f')      #=> 'd'\n   'z'.clamp('a', 'f')      #=> 'f'", "name": "clamp", "namespace": "Comparable", "path": "Comparable#clamp", "type": "module_function", "visibility": "public"}, "Complex": {"description": "复数可以用虚数unit; A+Bi表示为成对实数。其中a是实部，b是虚部，i是虚部。实数a在数学上等于复数a+0i。\\n \\n复杂对象可以以文字形式创建，也可以使用kernel complex、complex:：rect、complex:：polar或to_c方法创建。\\n \n   2+1i                 #=> (2+1i)\n   Complex(1)           #=> (1+0i)\n   Complex(2, 3)        #=> (2+3i)\n   Complex.polar(2, 3)  #=> (-1.9799849932008908+0.2822400161197344i)\n   3.to_c               #=> (3+0i)\n \\n您也可以从浮点数或字符串创建复杂对象。\\n \n   Complex(0.3)         #=> (0.3+0i)\n   Complex('0.3-0.5i')  #=> (0.3-0.5i)\n   Complex('2/3+3/4i')  #=> ((2/3)+(3/4)*i)\n   Complex('1@2')       #=> (-0.4161468365471424+0.9092974268256817i)\n\n   0.3.to_c             #=> (0.3+0i)\n   '0.3-0.5i'.to_c      #=> (0.3-0.5i)\n   '2/3+3/4i'.to_c      #=> ((2/3)+(3/4)*i)\n   '1@2'.to_c           #=> (-0.4161468365471424+0.9092974268256817i)\n \\n复杂对象是精确的或不精确的数字。n \n   Complex(1, 1) / 2    #=> ((1/2)+(1/2)*i)\n   Complex(1, 1) / 2.0  #=> (0.5+0.5i)", "name": "Complex", "namespace": "", "path": "Complex", "type": "class", "visibility": "public"}, "Complex#*": {"description": "", "name": "*", "namespace": "Complex", "path": "Complex#*", "type": "instance_method", "visibility": "public"}, "Complex#**": {"description": "执行求幂。n \n   Complex('i') ** 2              #=> (-1+0i)\n   Complex(-8) ** Rational(1, 3)  #=> (1.0000000000000002+1.7320508075688772i)", "name": "**", "namespace": "Complex", "path": "Complex#**", "type": "instance_method", "visibility": "public"}, "Complex#+": {"description": "执行加法。n \n   Complex(2, 3)  + Complex(2, 3)   #=> (4+6i)\n   Complex(900)   + Complex(1)      #=> (901+0i)\n   Complex(-2, 9) + Complex(-9, 2)  #=> (-11+11i)\n   Complex(9, 8)  + 4               #=> (13+8i)\n   Complex(20, 9) + 9.8             #=> (29.8+9i)", "name": "+", "namespace": "Complex", "path": "Complex#+", "type": "instance_method", "visibility": "public"}, "Complex#-": {"description": "执行减法。n \n   Complex(2, 3)  - Complex(2, 3)   #=> (0+0i)\n   Complex(900)   - Complex(1)      #=> (899+0i)\n   Complex(-2, 9) - Complex(-9, 2)  #=> (7+7i)\n   Complex(9, 8)  - 4               #=> (5+8i)\n   Complex(20, 9) - 9.8             #=> (10.2+9i)", "name": "-", "namespace": "Complex", "path": "Complex#-", "type": "instance_method", "visibility": "public"}, "Complex#-@": {"description": "返回值的负数。\\n n    -Complex(1, 2)  #=> (-1-2i)", "name": "-@", "namespace": "Complex", "path": "Complex#-@", "type": "instance_method", "visibility": "public"}, "Complex#/": {"description": "执行除法。n \n   Complex(2, 3)  / Complex(2, 3)   #=> ((1/1)+(0/1)*i)\n   Complex(900)   / Complex(1)      #=> ((900/1)+(0/1)*i)\n   Complex(-2, 9) / Complex(-9, 2)  #=> ((36/85)-(77/85)*i)\n   Complex(9, 8)  / 4               #=> ((9/4)+(2/1)*i)\n   Complex(20, 9) / 9.8             #=> (2.0408163265306123+0.9183673469387754i)", "name": "/", "namespace": "Complex", "path": "Complex#/", "type": "instance_method", "visibility": "public"}, "Complex#==": {"description": "如果cmp在数字上等于对象，则返回true。n \n   Complex(2, 3)  == Complex(2, 3)   #=> true\n   Complex(5)     == 5               #=> true\n   Complex(0)     == 0.0             #=> true\n   Complex('1/3') == 0.33            #=> false\n   Complex('1/2') == '1/2'           #=> false", "name": "==", "namespace": "Complex", "path": "Complex#==", "type": "instance_method", "visibility": "public"}, "Complex#abs": {"description": "返回其极性形式的绝对部分。n \n   Complex(-1).abs         #=> 1\n   Complex(3.0, -4.0).abs  #=> 5.0", "name": "abs", "namespace": "Complex", "path": "Complex#abs", "type": "instance_method", "visibility": "public"}, "Complex#abs2": {"description": "返回绝对值的平方。n \n   Complex(-1).abs2         #=> 1\n   Complex(3.0, -4.0).abs2  #=> 25.0", "name": "abs2", "namespace": "Complex", "path": "Complex#abs2", "type": "instance_method", "visibility": "public"}, "Complex#angle": {"description": "返回其极性形式的角度部分。\\n n    Complex.polar(3, Math::PI/2).arg  #=> 1.5707963267948966", "name": "angle", "namespace": "Complex", "path": "Complex#angle", "type": "instance_method", "visibility": "public"}, "Complex#arg": {"description": "返回其极性形式的角度部分。\\n n    Complex.polar(3, Math::PI/2).arg  #=> 1.5707963267948966", "name": "arg", "namespace": "Complex", "path": "Complex#arg", "type": "instance_method", "visibility": "public"}, "Complex#coerce": {"description": ":nodoc:", "name": "coerce", "namespace": "Complex", "path": "Complex#coerce", "type": "instance_method", "visibility": "public"}, "Complex#complex?": {"description": ":nodoc:", "name": "complex?", "namespace": "Complex", "path": "Complex#complex?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Complex#conj": {"description": "返回复共轭。\\n n    Complex(1, 2).conjugate  #=> (1-2i)", "name": "conj", "namespace": "Complex", "path": "Complex#conj", "type": "instance_method", "visibility": "public"}, "Complex#conjugate": {"description": "返回复共轭。\\n n    Complex(1, 2).conjugate  #=> (1-2i)", "name": "conjugate", "namespace": "Complex", "path": "Complex#conjugate", "type": "instance_method", "visibility": "public"}, "Complex#denominator": {"description": "返回分母（分母的LCM-real和imag）。\\n \\n请参阅分子。", "name": "denominator", "namespace": "Complex", "path": "Complex#denominator", "type": "instance_method", "visibility": "public"}, "Complex#eql?": {"description": ":nodoc:", "name": "eql?", "namespace": "Complex", "path": "Complex#eql?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Complex#exact?": {"description": ":nodoc:", "name": "exact?", "namespace": "Complex", "path": "Complex#exact?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Complex#fdiv": {"description": "执行除法，因为每个部分都是一个浮点，永远不要返回浮点。\\n n    Complex(11, 22).fdiv(3)  #=> (3.6666666666666665+7.333333333333333i)", "name": "fdiv", "namespace": "Complex", "path": "Complex#fdiv", "type": "instance_method", "visibility": "public"}, "Complex#finite?": {"description": "如果+cmp+的震级是有限的数字，则返回+true+，否则返回+false+。", "name": "finite?", "namespace": "Complex", "path": "Complex#finite?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Complex#hash": {"description": ":nodoc:", "name": "hash", "namespace": "Complex", "path": "Complex#hash", "type": "instance_method", "visibility": "public"}, "Complex#imag": {"description": "返回虚部。n \n   Complex(7).imaginary      #=> 0\n   Complex(9, -4).imaginary  #=> -4", "name": "imag", "namespace": "Complex", "path": "Complex#imag", "type": "instance_method", "visibility": "public"}, "Complex#imaginary": {"description": "返回虚部。n \n   Complex(7).imaginary      #=> 0\n   Complex(9, -4).imaginary  #=> -4", "name": "imaginary", "namespace": "Complex", "path": "Complex#imaginary", "type": "instance_method", "visibility": "public"}, "Complex#inexact?": {"description": ":nodoc:", "name": "inexact?", "namespace": "Complex", "path": "Complex#inexact?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Complex#infinite?": {"description": "返回与+cmp+的大小值对应的值：\\n \\n+有限+：：+nil+ \\n+无限+：++1+\\n \\n例如：\\n \n    (1+1i).infinite?                   #=> nil\n    (Float::INFINITY + 1i).infinite?   #=> 1", "name": "infinite?", "namespace": "Complex", "path": "Complex#infinite?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Complex#inspect": {"description": "以字符串形式返回值以供检查。n \n   Complex(2).inspect                       #=> \"(2+0i)\"\n   Complex('-8/6').inspect                  #=> \"((-4/3)+0i)\"\n   Complex('1/2i').inspect                  #=> \"(0+(1/2)*i)\"\n   Complex(0, Float::INFINITY).inspect      #=> \"(0+Infinity*i)\"\n   Complex(Float::NAN, Float::NAN).inspect  #=> \"(NaN+NaN*i)\"", "name": "inspect", "namespace": "Complex", "path": "Complex#inspect", "type": "instance_method", "visibility": "public"}, "Complex#magnitude": {"description": "返回其极性形式的绝对部分。n \n   Complex(-1).abs         #=> 1\n   Complex(3.0, -4.0).abs  #=> 5.0", "name": "magnitude", "namespace": "Complex", "path": "Complex#magnitude", "type": "instance_method", "visibility": "public"}, "Complex#marshal_dump": {"description": ":nodoc:", "name": "marshal_dump", "namespace": "Complex", "path": "Complex#marshal_dump", "type": "instance_method", "visibility": "private"}, "Complex#numerator": {"description": "返回分子。\\n \n       1   2       3+4i  <-  numerator\n       - + -i  ->  ----\n       2   3        6    <-  denominator\n\n   c = Complex('1/2+2/3i')  #=> ((1/2)+(2/3)*i)\n   n = c.numerator          #=> (3+4i)\n   d = c.denominator        #=> 6\n   n / d                    #=> ((1/2)+(2/3)*i)\n   Complex(Rational(n.real, d), Rational(n.imag, d))\n                            #=> ((1/2)+(2/3)*i)\n请参阅分母。", "name": "numerator", "namespace": "Complex", "path": "Complex#numerator", "type": "instance_method", "visibility": "public"}, "Complex#phase": {"description": "返回其极性形式的角度部分。\\n n    Complex.polar(3, Math::PI/2).arg  #=> 1.5707963267948966", "name": "phase", "namespace": "Complex", "path": "Complex#phase", "type": "instance_method", "visibility": "public"}, "Complex#polar": {"description": "返回array;[cmp.abs，cmp.arg]。\\n n    Complex(1, 2).polar  #=> [2.23606797749979, 1.1071487177940904]", "name": "polar", "namespace": "Complex", "path": "Complex#polar", "type": "instance_method", "visibility": "public"}, "Complex#quo": {"description": "", "name": "quo", "namespace": "Complex", "path": "Complex#quo", "type": "instance_method", "visibility": "public"}, "Complex#rationalize": {"description": "如果可能，将值作为有理数返回（虚部应正好为零）。\\n \n   Complex(1.0/3, 0).rationalize  #=> (1/3)\n   Complex(1, 0.0).rationalize    # RangeError\n   Complex(1, 2).rationalize      # RangeError\n \\n请参阅to_r。", "name": "rationalize", "namespace": "Complex", "path": "Complex#rationalize", "type": "instance_method", "visibility": "public"}, "Complex#real": {"description": "返回实际部分。n \n   Complex(7).real      #=> 7\n   Complex(9, -4).real  #=> 9", "name": "real", "namespace": "Complex", "path": "Complex#real", "type": "instance_method", "visibility": "public"}, "Complex#real?": {"description": "返回false。", "name": "real?", "namespace": "Complex", "path": "Complex#real?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Complex#rect": {"description": "返回array;[cmp.real，cmp.imag]。\\n n    Complex(1, 2).rectangular  #=> [1, 2]", "name": "rect", "namespace": "Complex", "path": "Complex#rect", "type": "instance_method", "visibility": "public"}, "Complex#rectangular": {"description": "返回array;[cmp.real，cmp.imag]。\\n n    Complex(1, 2).rectangular  #=> [1, 2]", "name": "rectangular", "namespace": "Complex", "path": "Complex#rectangular", "type": "instance_method", "visibility": "public"}, "Complex#to_c": {"description": "返回自我。n \n   Complex(2).to_c      #=> (2+0i)\n   Complex(-8, 6).to_c  #=> (-8+6i)", "name": "to_c", "namespace": "Complex", "path": "Complex#to_c", "type": "instance_method", "visibility": "public"}, "Complex#to_f": {"description": "如果可能，以浮点形式返回值（虚部应正好为零）。\\n \n   Complex(1, 0).to_f    #=> 1.0\n   Complex(1, 0.0).to_f  # RangeError\n复杂（1，2）。到范围错误", "name": "to_f", "namespace": "Complex", "path": "Complex#to_f", "type": "instance_method", "visibility": "public"}, "Complex#to_i": {"description": "如果可能，将值作为整数返回（虚部应正好为零）。\\n \n   Complex(1, 0).to_i    #=> 1\n   Complex(1, 0.0).to_i  # RangeError\n复杂（1，2）。到范围错误", "name": "to_i", "namespace": "Complex", "path": "Complex#to_i", "type": "instance_method", "visibility": "public"}, "Complex#to_r": {"description": "如果可能，将值作为有理数返回（虚部应正好为零）。\\n \n   Complex(1, 0).to_r    #=> (1/1)\n   Complex(1, 0.0).to_r  # RangeError\n   Complex(1, 2).to_r    # RangeError\n \\n请参阅合理化。", "name": "to_r", "namespace": "Complex", "path": "Complex#to_r", "type": "instance_method", "visibility": "public"}, "Complex#to_s": {"description": "以字符串形式返回值。n \n   Complex(2).to_s                       #=> \"2+0i\"\n   Complex('-8/6').to_s                  #=> \"-4/3+0i\"\n   Complex('1/2i').to_s                  #=> \"0+1/2i\"\n   Complex(0, Float::INFINITY).to_s      #=> \"0+Infinity*i\"\n   Complex(Float::NAN, Float::NAN).to_s  #=> \"NaN+NaN*i\"", "name": "to_s", "namespace": "Complex", "path": "Complex#to_s", "type": "instance_method", "visibility": "public"}, "Complex#~": {"description": "返回复共轭。\\n n    Complex(1, 2).conjugate  #=> (1-2i)", "name": "~", "namespace": "Complex", "path": "Complex#~", "type": "instance_method", "visibility": "public"}, "Complex.polar": {"description": "返回表示给定极坐标形式的复杂对象。n \n   Complex.polar(3, 0)            #=> (3.0+0.0i)\n   Complex.polar(3, Math::PI/2)   #=> (1.836909530733566e-16+3.0i)\n   Complex.polar(3, Math::PI)     #=> (-3.0+3.673819061467132e-16i)\n   Complex.polar(3, -Math::PI/2)  #=> (1.836909530733566e-16-3.0i)", "name": "polar", "namespace": "Complex", "path": "Complex.polar", "type": "class_method", "visibility": "public"}, "Complex.rect": {"description": "返回表示给定矩形形式的复杂对象。\\n n    Complex.rectangular(1, 2)  #=> (1+2i)", "name": "rect", "namespace": "Complex", "path": "Complex.rect", "type": "class_method", "visibility": "public"}, "Complex.rectangular": {"description": "返回表示给定矩形形式的复杂对象。\\n n    Complex.rectangular(1, 2)  #=> (1+2i)", "name": "rectangular", "namespace": "Complex", "path": "Complex.rectangular", "type": "class_method", "visibility": "public"}, "Complex::I": {"description": "虚数单位。", "name": "I", "namespace": "Complex", "path": "Complex::I", "type": "constant", "return": ["Complex", ""], "visibility": "public"}, "Complex::compatible": {"description": "", "name": "compatible", "namespace": "Complex", "path": "Complex::compatible", "type": "class", "visibility": "public"}, "Complex::compatible#marshal_load": {"description": ":nodoc:", "name": "marshal_load", "namespace": "Complex::compatible", "path": "Complex::compatible#marshal_load", "type": "instance_method", "visibility": "private"}, "Kernel": {"description": "内核模块由类对象包含，因此它的方法在每个Ruby对象中都可用。\\n \\n内核实例方法记录在类对象中，而模块方法记录在此处。这些方法在没有接收器的情况下被调用，因此可以以函数形式调用：\\n\\n   sprintf \"%.1f\", 1.234 #=> \"1.2\"", "name": "Kernel", "namespace": "", "path": "Kernel", "type": "module", "visibility": "public"}, "Kernel#Array": {"description": "以数组形式返回+arg+。\\n \\n首先尝试拨打+arg+的<code>to_ary</code>，然后拨打<code>to_a</code>。\\n如果+arg+不响应<code>to_ary</code>或<code>to_a</code>，则返回包含+arg+的长度为1的数组。\\n \\n如果<code>to_ary</code>或<code>to_a</code>返回的不是数组，则引发一个<code>TypeError</code>。n \n   Array([\"a\", \"b\"])  #=> [\"a\", \"b\"]\n   Array(1..5)        #=> [1, 2, 3, 4, 5]\n   Array(key: :value) #=> [[:key, :value]]\n   Array(nil)         #=> []\n   Array(1)           #=> [1]", "name": "Array", "namespace": "Kernel", "path": "Kernel#Array", "type": "module_function", "visibility": "public"}, "Kernel#Complex": {"description": "返回x+i*y；\\n \n   Complex(1, 2)    #=> (1+2i)\n   Complex('1+2i')  #=> (1+2i)\n   Complex(nil)     #=> TypeError\n   Complex(1, nil)  #=> TypeError\n\\n字符串形式的语法：\\n \n  string form = extra spaces , complex , extra spaces ;\n  complex = real part | [ sign ] , imaginary part\n          | real part , sign , imaginary part\n          | rational , \"@\" , rational ;\n  real part = rational ;\n  imaginary part = imaginary unit | unsigned rational , imaginary unit ;\n  rational = [ sign ] , unsigned rational ;\n  unsigned rational = numerator | numerator , \"/\" , denominator ;\n  numerator = integer part | fractional part | integer part , fractional part ;\n  denominator = digits ;\n  integer part = digits ;\n  fractional part = \".\" , digits , [ ( \"e\" | \"E\" ) , [ sign ] , digits ] ;\n  imaginary unit = \"i\" | \"I\" | \"j\" | \"J\" ;\n  sign = \"-\" | \"+\" ;\n  digits = digit , { digit | \"_\" , digit };\n  digit = \"0\" | \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" | \"8\" | \"9\" ;\n  extra spaces = ? \\s* ? ;\n\\n请参阅字符串to_c。", "name": "Complex", "namespace": "Kernel", "path": "Kernel#Complex", "type": "module_function", "visibility": "public"}, "Kernel#Float": {"description": "返回<i>arg->i>转换为float。数字类型是直接转换的，除了字符串和nil之外，其余的都是使用<i>arg.-.to_f.\\n使用无效字符转换<code>string</code>将导致<code>ArgumentError</code>。\\n转换<code>nil</code>会产生<code>TypeError</code>。n \n   Float(1)                 #=> 1.0\n   Float(\"123.456\")         #=> 123.456\n   Float(\"123.0_badstring\") #=> ArgumentError: invalid value for Float(): \"123.0_badstring\"\n   Float(nil)               #=> TypeError: can't convert nil into Float", "name": "Float", "namespace": "Kernel", "path": "Kernel#Float", "type": "module_function", "visibility": "public"}, "Kernel#Hash": {"description": "通过调用将<i>arg<i>转换为<code>Hash</code>\\n<i>arg<i><code>.to_hash</code>。返回空的<code>Hash</code>，当\\n<i>arg</i>is<tt>nil<tt>or<tt>[]<tt>。n \n   Hash([])          #=> {}\n   Hash(nil)         #=> {}\n   Hash(key: :value) #=> {:key => :value}\n   Hash([1, 2, 3])   #=> TypeError", "name": "Hash", "namespace": "Kernel", "path": "Kernel#Hash", "type": "module_function", "visibility": "public"}, "Kernel#Integer": {"description": "将<i>arg->i>转换为<code>Integer</code>。\\n数字类型直接转换（浮点数被截断）。<i>base（0，or between 2 and 36）is a base for integer string representation.如果arg<i>is a <code>String</code>，\\n when<i>base<i>is省略or equals zero，基数指示符\\n（<code>0</code>，<code>0b</code>，and <code>0x</code>）are golden.\\n在任何情况下，字符串都应严格遵守数字表示法。这种行为与<code>String#to_i</code>不同。首先尝试<code>to_int</code>，然后尝试<code>to_i</code>，将转换非字符串值。通过<code>nil</code> \\n将引发TypeError。n \n   Integer(123.999)    #=> 123\n   Integer(\"0x1a\")     #=> 26\n   Integer(Time.new)   #=> 1204973019\n   Integer(\"0930\", 10) #=> 930\n   Integer(\"111\", 2)   #=> 7\n   Integer(nil)        #=> TypeError", "name": "Integer", "namespace": "Kernel", "path": "Kernel#Integer", "type": "module_function", "visibility": "public"}, "Kernel#Rational": {"description": "以有理数形式返回+x/y+或+arg+。\\n \n   Rational(2, 3)   #=> (2/3)\n   Rational(5)      #=> (5/1)\n   Rational(0.5)    #=> (1/2)\n   Rational(0.3)    #=> (5404319552844595/18014398509481984)\n\n   Rational(\"2/3\")  #=> (2/3)\n   Rational(\"0.3\")  #=> (3/10)\n\n   Rational(\"10 cents\")  #=> ArgumentError\n   Rational(nil)         #=> TypeError\n   Rational(1, nil)      #=> TypeError\n \\n字符串形式的语法：\\n \n  string form = extra spaces , rational , extra spaces ;\n  rational = [ sign ] , unsigned rational ;\n  unsigned rational = numerator | numerator , \"/\" , denominator ;\n  numerator = integer part | fractional part | integer part , fractional part ;\n  denominator = digits ;\n  integer part = digits ;\n  fractional part = \".\" , digits , [ ( \"e\" | \"E\" ) , [ sign ] , digits ] ;\n  sign = \"-\" | \"+\" ;\n  digits = digit , { digit | \"_\" , digit } ;\n  digit = \"0\" | \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" | \"8\" | \"9\" ;\n  extra spaces = ? \\s* ? ;\n \\n另请参阅字符串to_r。", "name": "Rational", "namespace": "Kernel", "path": "Kernel#Rational", "type": "module_function", "visibility": "public"}, "Kernel#String": {"description": "作为<code>String</code>返回<i>arg。\\n \\n首先尝试调用其<code>to_str</code>方法，然后调用其<code>to_s</code>方法。n \n   String(self)        #=> \"main\"\n   String(self.class)  #=> \"Object\"\n   String(123456)      #=> \"123456\"", "name": "String", "namespace": "Kernel", "path": "Kernel#String", "type": "module_function", "visibility": "public"}, "Kernel#__callee__": {"description": "以符号形式返回当前方法的调用名称。\\n如果在方法外部调用，则返回<code>nil</code>。", "name": "__callee__", "namespace": "Kernel", "path": "Kernel#__callee__", "type": "module_function", "visibility": "public"}, "Kernel#__dir__": {"description": "返回从中调用此方法的文件的目录的规范化绝对路径。这意味着路径中的符号链接被解析。\\n如果<code>__FILE__</code>是<code>nil</code>，则返回<code>nil</code>。\\n返回值等于<code>File.dirname(File.realpath(__FILE__))</code>。", "name": "__dir__", "namespace": "Kernel", "path": "Kernel#__dir__", "type": "module_function", "visibility": "public"}, "Kernel#__method__": {"description": "以符号形式返回当前方法定义处的名称。\\n如果在方法外部调用，则返回<code>nil</code>。", "name": "__method__", "namespace": "Kernel", "path": "Kernel#__method__", "type": "module_function", "visibility": "public"}, "Kernel#`": {"description": "返回在子shell中运行cmd的标准输出。\\n内置语法<code>%x{...}</code>使用此方法。将<code>$?</code>设置为进程状态。n \n   `date`                   #=> \"Wed Apr  9 08:56:30 CDT 2003\\n\"\n   `ls testdir`.split[1]    #=> \"main.rb\"\n   `echo oops && exit 99`   #=> \"oops\\n\"\n   $?.exitstatus            #=> 99", "name": "`", "namespace": "Kernel", "path": "Kernel#`", "type": "module_function", "visibility": "public"}, "Kernel#abort": {"description": "返回此进程的进程ID。并非所有平台都可用。\\n n    Process.pid   #=> 27415", "name": "abort", "namespace": "Kernel", "path": "Kernel#abort", "type": "module_function", "visibility": "public"}, "Kernel#at_exit": {"description": "将块转换为+Proc+对象（因此在调用点绑定它），并在程序退出时注册它以执行。如果注册了多个处理程序，它们将按注册的相反顺序执行。\\n \n   def do_at_exit(str1)\n     at_exit { print str1 }\n   end\n   at_exit { puts \"cruel world\" }\n   do_at_exit(\"goodbye \")\n   exit\n \\n<em>产生：.<em>\\n \\n再见，残酷的世界", "name": "at_exit", "namespace": "Kernel", "path": "Kernel#at_exit", "type": "module_function", "visibility": "public"}, "Kernel#autoload": {"description": "注册首次访问模块（可能是<code>String</code>或符号）时要加载的文件名（使用<code>Kernel::require</code>）。\\n \\n自动加载（：MyModule，“/usr/local/lib/modules/my_module.rb”）", "name": "autoload", "namespace": "Kernel", "path": "Kernel#autoload", "type": "module_function", "visibility": "public"}, "Kernel#autoload?": {"description": "返回要加载的文件名，如果\\名称注册为+autoload+。n \n   autoload(:B, \"b\")\n   autoload?(:B)            #=> \"b\"", "name": "autoload?", "namespace": "Kernel", "path": "Kernel#autoload?", "type": "module_function", "visibility": "public", "return": [["Boolean"], ""]}, "Kernel#binding": {"description": "返回一个+Binding+对象，描述调用点的变量和方法绑定。当调用+eval+在此环境中执行评估的命令时，可以使用此对象。另见+Binding+类的说明。n \n   def get_binding(param)\n     binding\n   end\n   b = get_binding(\"hello\")\n   eval(\"param\", b)   #=> \"hello\"", "name": "binding", "namespace": "Kernel", "path": "Kernel#binding", "type": "module_function", "visibility": "public"}, "Kernel#block_given?": {"description": "如果<code>yield</code>将在当前上下文中执行块，则返回<code>true</code>。<code>iterator?</code>表格稍微有些不赞成。\\n \n   def try\n     if block_given?\n       yield\n     else\n       \"no block\"\n     end\n   end\n   try                  #=> \"no block\"\n   try { \"hello\" }      #=> \"hello\"\n   try do \"hello\" end   #=> \"hello\"号", "name": "block_given?", "namespace": "Kernel", "path": "Kernel#block_given?", "type": "module_function", "visibility": "public", "return": [["Boolean"], ""]}, "Kernel#callcc": {"description": "生成一个延续对象，并将其传递给关联的块。在使用此方法之前需要<code>require\n'continuation'</code>。执行一个\\n<em>cont</em><code>.call</code>将导致callcc返回（就像将从块的末尾落下一样）。callcc返回的值是块的值，或传递给<em>cont的值。有关详细信息，请参阅类继续。另请参阅kernel throw以了解用于展开调用堆栈的替代机制。", "name": "callcc", "namespace": "Kernel", "path": "Kernel#callcc", "type": "module_function", "visibility": "public"}, "Kernel#caller": {"description": "返回当前执行堆栈-一个数组，其中包含形式为<code>file:line</code>或<code>file:line: in\n`method'</code>的字符串。\\n \\n可选的start参数决定要从堆栈顶部忽略的初始堆栈条目数。\\n \\n第二个可选+length+参数可用于限制从堆栈返回的条目数。\\n \\n如果start大于当前执行堆栈的大小，则返回+nil+。\\n \\n您可以选择传递一个范围，该范围将返回一个包含指定范围内的条目的数组。n \n   def a(skip)\n     caller(skip)\n   end\n   def b(skip)\n     a(skip)\n   end\n   def c(skip)\n     b(skip)\n   end\n   c(0)   #=> [\"prog:2:in `a'\", \"prog:5:in `b'\", \"prog:8:in `c'\", \"prog:10:in `<main>'\"]\n   c(1)   #=> [\"prog:5:in `b'\", \"prog:8:in `c'\", \"prog:11:in `<main>'\"]\n   c(2)   #=> [\"prog:8:in `c'\", \"prog:12:in `<main>'\"]\n   c(3)   #=> [\"prog:13:in `<main>'\"]\n   c(4)   #=> []\n   c(5)   #=> nil", "name": "caller", "namespace": "Kernel", "path": "Kernel#caller", "type": "module_function", "visibility": "public"}, "Kernel#caller_locations": {"description": "返回当前执行堆栈-包含回溯位置对象的数组。\\n \\n有关详细信息，请参阅thread:：backtrace:：location。\\n \\n可选的start参数决定要从堆栈顶部忽略的初始堆栈条目数。\\n \\n第二个可选+length+参数可用于限制从堆栈返回的条目数。\\n \\n如果start大于当前执行堆栈的大小，则返回+nil+。\\n \\n您可以选择传递一个范围，该范围将返回一个包含指定范围内的条目的数组。", "name": "caller_locations", "namespace": "Kernel", "path": "Kernel#caller_locations", "type": "module_function", "visibility": "public"}, "Kernel#catch": {"description": "+catch+执行其块。如果未调用+throw+，则块正常执行，并且+catch+返回最后一个计算表达式的值。\\n \n   catch(1) { 123 }            # => 123\n \\n如果调用<code>throw(tag2, val)</code>，ruby将在其堆栈中搜索+catch+块，该块的+tag+与tag2具有相同的+object_id+。找到后，块停止执行并返回val（如果没有给+throw+提供第二个参数，则返回+nil+）。\\n \n   catch(1) { throw(1, 456) }  # => 456\n   catch(1) { throw(1) }       # => nil\n \\n当+tag+作为第一个参数传递时，+catch+生成它作为块的参数。\\n \n   catch(1) {|x| x + 2 }       # => 3\n \\n如果没有给定+tag+，+catch+将生成一个新的唯一对象（从\\n+object.new+开始）作为块参数。然后可以将此对象用作+throw+的参数，并将与正确的+catch+块匹配。\\n \n   catch do |obj_A|\n     catch do |obj_B|\n       throw(obj_B, 123)\n       puts \"This puts is not reached\"\n     end\n\n     puts \"This puts is displayed\"\n     456\n   end\n\n   # => 456\n\n   catch do |obj_A|\n     catch do |obj_B|\n       throw(obj_A, 123)\n       puts \"This puts is still not reached\"\n     end\n\n     puts \"Now this puts is also not reached\"\n     456\n   end\n\\n    # => 123", "name": "catch", "namespace": "Kernel", "path": "Kernel#catch", "type": "module_function", "visibility": "public"}, "Kernel#eval": {"description": "计算字符串中的ruby表达式。如果给定了\\n<em>binding</em>，它必须是<code>Binding</code>对象，则在其上下文中执行评估。如果存在可选的<em>filename<em>和<em>lineno<em>参数，则在报告语法错误时将使用这些参数。n \n   def get_binding(str)\n     return binding\n   end\n   str = \"hello\"\n   eval \"str + ' Fred'\"                      #=> \"hello Fred\"\n   eval \"str + ' Fred'\", get_binding(\"bye\")  #=> \"bye Fred\"", "name": "eval", "namespace": "Kernel", "path": "Kernel#eval", "type": "module_function", "visibility": "public"}, "Kernel#exec": {"description": "返回此进程的（实际）用户ID。\\n n    Process.uid   #=> 501", "name": "exec", "namespace": "Kernel", "path": "Kernel#exec", "type": "module_function", "visibility": "public"}, "Kernel#exit": {"description": "设置此进程的（用户）用户ID。并非所有平台都可用。", "name": "exit", "namespace": "Kernel", "path": "Kernel#exit", "type": "module_function", "visibility": "public"}, "Kernel#exit!": {"description": "等待子进程退出，返回其进程ID，并将<code>$?</code>设置为包含该进程信息的<code>Process::Status</code>对象。它等待的子级\\n取决于\\n PID\\n \\n>0的值：：等待进程ID等于PID的子级。\\n\\n 0：：等待进程组ID等于the\n        calling process.\n的任何子进程\\n- 1：：等待任何子进程（如果没有PID is\n        given).\n，则默认值为\\n<-1：：等待进程组ID等于absolute\n        value of _pid_.\n的任何子进程\\n flags参数可以是逻辑或标志值<code>Process::WNOHANG</code>（如果没有可用的子进程，则不阻止）的逻辑或标志值的逻辑或\\n或<code>Process::WUNTRACED</code>（retuRN阻止了尚未报告的儿童）。并非所有的标志都可以在所有平台上使用，但是标志值为零可以在所有平台上使用。\\n \\n如果没有子进程，则调用此方法将引发SystemCallError。并非所有平台都可用。n \n   include Process\n   fork { exit 99 }                 #=> 27429\n   wait                             #=> 27429\n   $?.exitstatus                    #=> 99\n\n   pid = fork { sleep 3 }           #=> 27440\n   Time.now                         #=> 2008-03-08 19:56:16 +0900\n   waitpid(pid, Process::WNOHANG)   #=> nil\n   Time.now                         #=> 2008-03-08 19:56:16 +0900\n   waitpid(pid, 0)                  #=> 27440\n   Time.now                         #=> 2008-03-08 19:56:19 +0900", "name": "exit!", "namespace": "Kernel", "path": "Kernel#exit!", "type": "module_function", "visibility": "public"}, "Kernel#fail": {"description": "如果<code>$!</code>是+nil+，则在没有参数的情况下引发<code>$!</code>中的异常或引发<code>RuntimeError</code>。\\n使用单个+String+参数，将字符串作为消息引发+RuntimeError+。否则，第一个参数应该是+Exception+类的名称（或者在发送+exception+消息时返回+Exception+对象的对象）。可选的第二个参数设置与异常相关联的消息，第三个参数是回调信息数组。异常由<code>begin...end</code>块的+rescue+子句捕获。\\n \n   raise \"Failed to create socket\"\n引发ArgumentError，“无参数”，调用方", "name": "fail", "namespace": "Kernel", "path": "Kernel#fail", "type": "module_function", "visibility": "public"}, "Kernel#fork": {"description": "等待子进程退出（请参阅process:：waitpid了解确切的语义），并返回包含进程ID和该子进程的退出状态（<code>Process::Status</code>对象）的数组。如果没有子进程，则引发SystemCallError。n \n   Process.fork { exit 99 }   #=> 27437\n   pid, status = Process.wait2\n   pid                        #=> 27437\n   status.exitstatus          #=> 99", "name": "fork", "namespace": "Kernel", "path": "Kernel#fork", "type": "module_function", "visibility": "public"}, "Kernel#format": {"description": "返回将<i>format_string<i>应用于任何其他参数所产生的字符串。在格式字符串中，除格式序列之外的任何字符都将复制到结果中。\\n \\n格式序列的语法如下。\\n \n  %[flags][width][.precision]type\n \\n格式序列由百分号、可选标志、宽度和精度指示器组成，然后以字段类型字符结尾。字段类型控制如何解释对应的<code>sprintf</code>参数，而标志则修改该解释。\\n \\n栏位类型的字元为：\\n \n    Field |  Integer Format\n    ------+--------------------------------------------------------------\n      b   | Convert argument as a binary number.\n          | Negative numbers will be displayed as a two's complement\n          | prefixed with `..1'.\n      B   | Equivalent to `b', but uses an uppercase 0B for prefix\n          | in the alternative format by #.\n      d   | Convert argument as a decimal number.\n      i   | Identical to `d'.\n      o   | Convert argument as an octal number.\n          | Negative numbers will be displayed as a two's complement\n          | prefixed with `..7'.\n      u   | Identical to `d'.\n      x   | Convert argument as a hexadecimal number.\n          | Negative numbers will be displayed as a two's complement\n          | prefixed with `..f' (representing an infinite string of\n          | leading 'ff's).\n      X   | Equivalent to `x', but uses uppercase letters.\n\n    Field |  Float Format\n    ------+--------------------------------------------------------------\n      e   | Convert floating point argument into exponential notation\n          | with one digit before the decimal point as [-]d.dddddde[+-]dd.\n          | The precision specifies the number of digits after the decimal\n          | point (defaulting to six).\n      E   | Equivalent to `e', but uses an uppercase E to indicate\n          | the exponent.\n      f   | Convert floating point argument as [-]ddd.dddddd,\n          | where the precision specifies the number of digits after\n          | the decimal point.\n      g   | Convert a floating point number using exponential form\n          | if the exponent is less than -4 or greater than or\n          | equal to the precision, or in dd.dddd form otherwise.\n          | The precision specifies the number of significant digits.\n      G   | Equivalent to `g', but use an uppercase `E' in exponent form.\n      a   | Convert floating point argument as [-]0xh.hhhhp[+-]dd,\n          | which is consisted from optional sign, \"0x\", fraction part\n          | as hexadecimal, \"p\", and exponential part as decimal.\n      A   | Equivalent to `a', but use uppercase `X' and `P'.\n\n    Field |  Other Format\n    ------+--------------------------------------------------------------\n      c   | Argument is the numeric code for a single character or\n          | a single character string itself.\n      p   | The valuing of argument.inspect.\n      s   | Argument is a string to be substituted.  If the format\n          | sequence contains a precision, at most that many characters\n          | will be copied.\n      %   | A percent sign itself will be displayed.  No argument taken.\n \\n标记会修改格式的行为。\\n标志字符为：\\n \n  Flag     | Applies to    | Meaning\n  ---------+---------------+-----------------------------------------\n  space    | bBdiouxX      | Leave a space at the start of\n           | aAeEfgG       | non-negative numbers.\n           | (numeric fmt) | For `o', `x', `X', `b' and `B', use\n           |               | a minus sign with absolute value for\n           |               | negative values.\n  ---------+---------------+-----------------------------------------\n  (digit)$ | all           | Specifies the absolute argument number\n           |               | for this field.  Absolute and relative\n           |               | argument numbers cannot be mixed in a\n           |               | sprintf string.\n  ---------+---------------+-----------------------------------------\n   #       | bBoxX         | Use an alternative format.\n           | aAeEfgG       | For the conversions `o', increase the precision\n           |               | until the first digit will be `0' if\n           |               | it is not formatted as complements.\n           |               | For the conversions `x', `X', `b' and `B'\n           |               | on non-zero, prefix the result with ``0x'',\n           |               | ``0X'', ``0b'' and ``0B'', respectively.\n           |               | For `a', `A', `e', `E', `f', `g', and 'G',\n           |               | force a decimal point to be added,\n           |               | even if no digits follow.\n           |               | For `g' and 'G', do not remove trailing zeros.\n  ---------+---------------+-----------------------------------------\n  +        | bBdiouxX      | Add a leading plus sign to non-negative\n           | aAeEfgG       | numbers.\n           | (numeric fmt) | For `o', `x', `X', `b' and `B', use\n           |               | a minus sign with absolute value for\n           |               | negative values.\n  ---------+---------------+-----------------------------------------\n  -        | all           | Left-justify the result of this conversion.\n  ---------+---------------+-----------------------------------------\n  0 (zero) | bBdiouxX      | Pad with zeros, not spaces.\n           | aAeEfgG       | For `o', `x', `X', `b' and `B', radix-1\n           | (numeric fmt) | is used for negative numbers formatted as\n           |               | complements.\n  ---------+---------------+-----------------------------------------\n  *        | all           | Use the next argument as the field width.\n           |               | If negative, left-justify the result. If the\n           |               | asterisk is followed by a number and a dollar\n           |               | sign, use the indicated argument as the width.\n \\n标志示例为：\\n \\n `+，空格标志指定非负数的符号。\\n  sprintf(\"%d\", 123)  #=> \"123\" \\n  sprintf(\"%+d\", 123) #=> \"+123\" \\n  sprintf(\"% d\", 123) #=> \" 123\" \\n \\n'o'标志增加数字位数以显示'0'。\\n `+'和空格标记更改负数的格式。\\n  sprintf(\"%o\", 123)   #=> \"173\" \\n  sprintf(\"%#o\", 123)  #=> \"0173\" \\n  sprintf(\"%+o\", -123) #=> \"-173\" \\n  sprintf(\"%o\", -123)  #=> \"..7605\" \\n  sprintf(\"%#o\", -123) #=> \"..7605\" \\n \\n `标记“x”为非零数字添加前缀“0x”。\\n `+'和空格标记禁用负数的补码。\\n  sprintf(\"%x\", 123)   #=> \"7b\" \\n  sprintf(\"%#x\", 123)  #=> \"0x7b\" \\n  sprintf(\"%+x\", -123) #=> \"-7b\" \\n  sprintf(\"%x\", -123)  #=> \"..f85\" \\n  sprintf(\"%#x\", -123) #=> \"0x..f85\" \\n  sprintf(\"%#x\", 0)    #=> \"0\" \\n \\n ` for'x'使用前缀'0x'。\\n  sprintf(\"%X\", 123)  #=> \"7B\" \\n  sprintf(\"%#X\", 123) #=> \"0X7B\" \\n \\n标记“b”为非零数字添加前缀“0b”。\\n `+'和空格标记禁用负数的补码。\\n  sprintf(\"%b\", 123)   #=> \"1111011\" \\n  sprintf(\"%#b\", 123)  #=> \"0b1111011\" \\n  sprintf(\"%+b\", -123) #=> \"-1111011\" \\n  sprintf(\"%b\", -123)  #=> \"..\n  browsers = ['Chrome', 'Firefox', 'Safari', 'Opera', 'IE']\n  browsers.length #=> 5\n  browsers.count #=> 5\n1\" \\n  sprintf(\"%#b\", -123) #=> \"0b..\n  browsers = ['Chrome', 'Firefox', 'Safari', 'Opera', 'IE']\n  browsers.length #=> 5\n  browsers.count #=> 5\n1\" \\n  sprintf(\"%#b\", 0)    #=> \"0\" \\n \\n `表示“b”使用前缀“0b”。\\n  sprintf(\"%B\", 123)  #=> \"1111011\" \\n  sprintf(\"%#B\", 123) #=> \"0B1111011\" \\n \\n表示“e”的力来显示小数点。\\n  sprintf(\"%.0e\", 1)  #=> \"1e+00\" \\n  sprintf(\"%#.0e\", 1) #=> \"1.e+00\" \\n \\n，'f'力显示小数点。\\n  sprintf(\"%.0f\", 1234)  #=> \"1234\" \\n  sprintf(\"%#.0f\", 1234) #=> \"1234.\" \\n \\n，'g'力显示小数点。\\n它还禁用剥离最低零。\\n  sprintf(\"%g\", 123.4)   #=> \"123.4\" \\n  sprintf(\"%#g\", 123.4)  #=> \"123.400\" \\n  sprintf(\"%g\", 123456)  #=> \"123456\" \\n  sprintf(\"%#g\", 123456) #=> \"123456.\" \\n \\n栏位宽度是可选的整数，后面可以是句点和精度。宽度指定将写入此字段结果的最小字符数。\\n \\n width的示例：\\n \\n padding由空格完成，width=20 \\n 0或基数-1。<-------------------\\n  sprintf(\"%20d\", 123)   #=> \"                 123\" \\n  sprintf(\"%+20d\", 123)  #=> \"                +123\" \\n  sprintf(\"%020d\", 123)  #=> \"00000000000000000123\" \\n  sprintf(\"%+020d\", 123) #=> \"+0000000000000000123\" \\n  sprintf(\"% 020d\", 123) #=> \" 0000000000000000123\" \\n  sprintf(\"%-20d\", 123)  #=> \"123                 \" \\n  sprintf(\"%-+20d\", 123) #=> \"+123                \" \\n  sprintf(\"%- 20d\", 123) #=> \" 123                \" \\n  sprintf(\"%020x\", -123) #=> \"..ffffffffffffffff85\" \\n \\n对于数字字段，精度控制显示的小数位数。对于字符串字段，精度决定要从字符串复制的最大字符数。（因此，格式序列<code>%10.10s</code>将始终为结果贡献10个\\n字符。）\\n \\n精度示例：\\n \\n“d”、“o”、“x”和“b”的精度是\\n最小位数<------>\\n  sprintf(\"%20.8d\", 123)  #=> \"            00000123\" \\n  sprintf(\"%20.8o\", 123)  #=> \"            00000173\" \\n  sprintf(\"%20.8x\", 123)  #=> \"            0000007b\" \\n  sprintf(\"%20.8b\", 123)  #=> \"            01111011\" \\n  sprintf(\"%20.8d\", -123) #=> \"           -00000123\" \\n  sprintf(\"%20.8o\", -123) #=> \"            ..777605\" \\n  sprintf(\"%20.8x\", -123) #=> \"            ..ffff85\" \\n  sprintf(\"%20.8b\", -11)  #=> \"            ..110101\" \\n \\n“0x”和“0”对于“x”和“B”，不计算\\n精度，但“0”表示“O”。<------>\\n  sprintf(\"%#20.8d\", 123)  #=> \"            00000123\" \\n  sprintf(\"%#20.8o\", 123)  #=> \"            00000173\" \\n  sprintf(\"%#20.8x\", 123)  #=> \"          0x0000007b\" \\n  sprintf(\"%#20.8b\", 123)  #=> \"          0b01111011\" \\n  sprintf(\"%#20.8d\", -123) #=> \"           -00000123\" \\n  sprintf(\"%#20.8o\", -123) #=> \"            ..777605\" \\n  sprintf(\"%#20.8x\", -123) #=> \"          0x..ffff85\" \\n  sprintf(\"%#20.8b\", -11)  #=> \"          0b..110101\" \\n \\n precision for'e'is number of \\n digits after the decimal point<------>\\n  sprintf(\"%20.8e\", 1234.56789) #=> \"      1.23456789e+03\" \\n \\n precision for'f'is number of \\n digits after the decimal point<------>\\n  sprintf(\"%20.8f\", 1234.56789) #=> \"       1234.56789000\" \\n \\n precision for'g'is n“s”的\\n有效数字的数量<------>\\n  sprintf(\"%20.8g\", 1234.56789) #=> \"           1234.5679\" \\n \\n<------>\\n  sprintf(\"%20.8g\", 123456789)  #=> \"       1.2345679e+08\" \\n \\n精度是\\n最大字符数<------>\\n  sprintf(\"%20.8s\", \"string test\") #=> \"            string t\" \\n \\n示例：\\n \n   sprintf(\"%d %04x\", 123, 123)               #=> \"123 007b\"\n   sprintf(\"%08b '%4s'\", 123, 123)            #=> \"01111011 ' 123'\"\n   sprintf(\"%1$*2$s %2$d %1$s\", \"hello\", 8)   #=> \"   hello 8 hello\"\n   sprintf(\"%1$*2$s %2$d\", \"hello\", -8)       #=> \"hello    -8\"\n   sprintf(\"%+g:% g:%-g\", 1.23, 1.23, 1.23)   #=> \"+1.23: 1.23:1.23\"\n   sprintf(\"%u\", -123)                        #=> \"-123\"\n \\n对于更复杂的格式，Ruby支持按名称引用.\\n%<name>s style使用格式样式，但%{name} style不使用格式样式。\\n\\n Examples:\n  sprintf(\"%<foo>d : %<bar>f\", { :foo => 1, :bar => 2 })\n    #=> 1 : 2.000000\n  sprintf(\"%{foo}f\", { :foo => 1 })\n    # => \"1f\"", "name": "format", "namespace": "Kernel", "path": "Kernel#format", "type": "module_function", "visibility": "public"}, "Kernel#gets": {"description": "返回（并分配给<code>$_</code>）+ARGV+（或<code>$*</code>）中文件列表的下一行，如果命令行中没有文件，则从标准输入返回。在文件末尾返回+nil+。可选参数指定记录分隔符。分隔符包含在每个记录的内容中。+nil+分隔符读取整个内容，零长度分隔符一次读取输入的一个段落，其中段落被两个连续的换行符分隔。如果第一个参数是整数，或者给定了可选的第二个参数，返回的字符串将不会长于给定的字节值。如果+ARGV+中存在多个文件名，<code>gets(nil)</code>将一次读取一个文件的内容。\\n \n   ARGV << \"testfile\"\n   print while gets\n \\n<em>产生：.-\\n \n   This is line one\n   This is line two\n   This is line three\n   And so on...\n \\n The style of programming using <code>$_</code> as an implicit parameter is already losing favorite in the Ruby community.", "name": "gets", "namespace": "Kernel", "path": "Kernel#gets", "type": "module_function", "visibility": "public"}, "Kernel#global_variables": {"description": "返回全局变量名称的数组。\\n\\n    global_variables.grep /std/   #=> [:$stdin, :$stdout, :$stderr]", "name": "global_variables", "namespace": "Kernel", "path": "Kernel#global_variables", "type": "module_function", "visibility": "public"}, "Kernel#iterator?": {"description": "如果<code>yield</code>将在当前上下文中执行块，则返回<code>true</code>。<code>iterator?</code>表格稍微有些不赞成。\\n \n   def try\n     if block_given?\n       yield\n     else\n       \"no block\"\n     end\n   end\n   try                  #=> \"no block\"\n   try { \"hello\" }      #=> \"hello\"\n   try do \"hello\" end   #=> \"hello\"号", "name": "iterator?", "namespace": "Kernel", "path": "Kernel#iterator?", "type": "module_function", "visibility": "public", "return": [["Boolean"], ""]}, "Kernel#lambda": {"description": "相当于<code>Proc.new</code>，除了生成的proc对象，检查调用时传递的参数数量。", "name": "lambda", "namespace": "Kernel", "path": "Kernel#lambda", "type": "module_function", "visibility": "public"}, "Kernel#load": {"description": "加载并执行文件名中的Ruby程序。如果文件名不能解析为绝对路径，将在<code>$:</code>中列出的库目录中搜索该文件。如果可选的wrap参数是+true+，则加载的脚本将在匿名模块下执行，以保护调用程序的全局命名空间。在任何情况下，加载文件中的任何局部变量都不会传播到加载环境中。", "name": "load", "namespace": "Kernel", "path": "Kernel#load", "type": "module_function", "visibility": "public"}, "Kernel#local_variables": {"description": "返回当前局部变量的名称。n \n   fred = 1\n   for i in 1..10\n      # ...\n   end\n   local_variables   #=> [:fred, :i]", "name": "local_variables", "namespace": "Kernel", "path": "Kernel#local_variables", "type": "module_function", "visibility": "public"}, "Kernel#loop": {"description": "重复执行块。\\n \\n如果没有给定块，则返回枚举器。\\n \n   loop do\n     print \"Input: \"\n     line = gets\n     break if !line or line =~ /^qQ/\n     # ...\n   end\n \\n在块中引发的StopIteration中断循环。在这种情况下，loop返回存储在异常中的“result”值。n \n   enum = Enumerator.new { |y|\n     y << \"one\"\n     y << \"two\"\n     :ok\n   }\n\n   result = loop {\n     puts enum.next\n   } #=> :ok", "name": "loop", "namespace": "Kernel", "path": "Kernel#loop", "type": "module_function", "visibility": "public"}, "Kernel#open": {"description": "创建连接到给定流、文件或子进程的IO对象。\\n \\n如果+path+不是以管道字符（<code>|</code>）开头，请将其视为使用指定模式打开的文件名（默认为\\n“r”）。\\n \\n +mode+是字符串或整数。如果它是一个整数，则它必须是位或打开（2）标志，如文件：：RDWR或文件：：EXCL。如果是字符串，则它可以是“fmode”、“fmode:ext_enc”或\\n“fmode:ext_enc:int_enc”。\\n \\n有关+mode+字符串指令的完整文档，请参阅IO.new的文档。\\n \\n如果正在创建文件，则可以使用+perm+参数设置其初始权限。有关权限的描述，请参阅File.new和open（2）和chmod（2）手册页。\\n \\n如果指定了块，将以IO对象作为参数调用它，并且在块终止时IO将自动关闭。调用返回块的值。\\n \\n如果+path+以管道字符（<code>\"|\"</code>）开头，将创建一个子进程，并通过一对管道连接到调用方。返回的IO对象可用于写入标准输入并从此子进程的标准输出中读取。\\n \\n如果管道后面的命令是单减号（<code>\"|-\"</code>），则ruby forks，并且此子进程连接到父进程。如果命令不是<code>\"-\"</code>，则子进程运行该命令。\\n \\n当子进程为ruby（通过<code>\"|-\"</code>打开）时，+open+ \\n调用返回+nil+。如果一个块与open调用关联，则该块将运行两次-一次在父块中，一次在子块中。\\n \\n block参数将是父级中的IO对象，子级中的+nil+。父级的+IO+对象将连接到子级的$stdin\\n和$stdout。子进程将在块的末尾终止。\\n \\n===examples \\n \\n reading from“testfile”：\\n \n   open(\"testfile\") do |f|\n     print f.gets\n   end\n \\n products:\\n \n   This is line one\n \\n打开子进程并读取其输出：\\n \n   cmd = open(\"|date\")\n   print cmd.gets\n   cmd.close\n \\n products:\\n \n   Wed Apr  9 08:56:31 CDT 2003\n \\n打开运行相同ruby程序的子进程：\\n \n   f = open(\"|-\", \"w+\")\n   if f.nil?\n     puts \"in Child\"\n     exit\n   else\n     puts \"Got: #{f.gets}\"\n   end\n \\n products:\\n \n   Got: in Child\n \\n使用块打开子进程以接收IO对象：\\n \n   open \"|-\" do |f|\n     if f then\n       # parent process\n       puts \"Got: #{f.gets}\"\n     else\n       # child process\n       puts \"in Child\"\n     end\n   end\n \\n products:\\n \\n got：在孩子", "name": "open", "namespace": "Kernel", "path": "Kernel#open", "type": "module_function", "visibility": "public"}, "Kernel#p": {"description": "对于每个对象，直接将obj.+inspect+和换行符写入程序的标准输出。\\n \n   S = Struct.new(:name, :state)\n   s = S['dave', 'TX']\n   p s\n \\n<em>产生：.<em>\\n \\n<s name=“Dave”，state=“tx”>", "name": "p", "namespace": "Kernel", "path": "Kernel#p", "type": "module_function", "visibility": "public"}, "Kernel#print": {"description": "依次打印每个对象到<code>$stdout</code>。如果输出字段分隔符（<code>$,</code>）不是+nil+，则其内容将显示在每个字段之间。如果输出记录分隔符（<code>$\\\\</code>）不是+nil+，它将附加到输出中。如果没有给出参数，打印<code>$_</code>。非字符串的对象将通过调用其<code>to_s</code>方法进行转换。\\n \n   print \"cat\", [1,2,3], 99, \"\\n\"\n   $, = \", \"\n   $\\ = \"\\n\"\n   print \"cat\", [1,2,3], 99\n \\n<em>产生：.<em>\\n \n   cat12399\n cat，1，2，3，99", "name": "print", "namespace": "Kernel", "path": "Kernel#print", "type": "module_function", "visibility": "public"}, "Kernel#printf": {"description": "相当于：\n   io.write(sprintf(string, obj, ...))\n或\\n$stdout.write（sprintf（string，obj，…）", "name": "printf", "namespace": "Kernel", "path": "Kernel#printf", "type": "module_function", "visibility": "public"}, "Kernel#proc": {"description": "相当于<code>Proc.new</code>。", "name": "proc", "namespace": "Kernel", "path": "Kernel#proc", "type": "module_function", "visibility": "public"}, "Kernel#putc": {"description": "相当于：\\n \n  $stdout.putc(int)\n \\n有关多字节字符的重要信息，请参阅IO PUTC文档。", "name": "putc", "namespace": "Kernel", "path": "Kernel#putc", "type": "module_function", "visibility": "public"}, "Kernel#puts": {"description": "相当于\\n \\n$stdout.puts（obj，…）", "name": "puts", "namespace": "Kernel", "path": "Kernel#puts", "type": "module_function", "visibility": "public"}, "Kernel#raise": {"description": "如果<code>$!</code>是+nil+，则在没有参数的情况下引发<code>$!</code>中的异常或引发<code>RuntimeError</code>。\\n使用单个+String+参数，将字符串作为消息引发+RuntimeError+。否则，第一个参数应该是+Exception+类的名称（或者在发送+exception+消息时返回+Exception+对象的对象）。可选的第二个参数设置与异常相关联的消息，第三个参数是回调信息数组。异常由<code>begin...end</code>块的+rescue+子句捕获。\\n \n   raise \"Failed to create socket\"\n引发ArgumentError，“无参数”，调用方", "name": "raise", "namespace": "Kernel", "path": "Kernel#raise", "type": "module_function", "visibility": "public"}, "Kernel#rand": {"description": "如果在没有参数的情况下调用，或者如果<tt>max.to_i.abs==0<tt>，rand返回一个介于0.0和1.0之间的伪随机浮点数，包括0.0和排除1.0。\\n \n  rand        #=> 0.2725926052826416\n \\n当+max.abs+大于或等于1时，+rand+会将大于或等于0且小于+max的伪随机整数返回给\\u i.abs+。\\n \n  rand(100)   #=> 12\n \\n当+max+是一个范围时，+rand+返回一个随机数range.member？（数字）==真。\\n \\n允许+max+的负值或浮点值，但可能会产生令人惊讶的结果。\\n \n  rand(-100) # => 87\n  rand(-0.5) # => 0.8130921818028143\n  rand(1.9)  # equivalent to rand(1), which is always 0\n \\n Kernel.srand可用于确保随机数序列在程序的不同运行之间是可重复的。\\n \\n另见random.rand。", "name": "rand", "namespace": "Kernel", "path": "Kernel#rand", "type": "module_function", "visibility": "public"}, "Kernel#readline": {"description": "相当于<code>Kernel::gets</code>，除了+readline+在文件末尾引发+EOFError+。", "name": "readline", "namespace": "Kernel", "path": "Kernel#readline", "type": "module_function", "visibility": "public"}, "Kernel#readlines": {"description": "返回一个数组，其中包含通过调用返回的行\\n<code>kernel.gets（<i>sep<i>）<code>until the end of file.", "name": "readlines", "namespace": "Kernel", "path": "Kernel#readlines", "type": "module_function", "visibility": "public"}, "Kernel#require": {"description": "加载给定的+name+，如果成功则返回+true+，如果已加载功能则返回+false+。\\n \\n如果文件名未解析为绝对路径，将在<code>$LOAD_PATH</code>（<code>$:</code>）中列出的目录中搜索该文件名。\\n \\n如果文件名的扩展名为“.rb”，则将其作为源file;加载，如果扩展名为“.so”、“.o”或“.dll”，或者当前平台上的默认共享库扩展名，则Ruby将共享库作为Ruby扩展名加载。否则，ruby会尝试在名称中添加“.rb”、“.so”等，直到找到为止。如果找不到名为的文件，将引发LoadError\\n。\\n \\n对于ruby扩展，给定的文件名可以使用任何共享库扩展。例如，在Linux上，套接字扩展名为“socket.so”，<code>require 'socket.dll'</code>将加载套接字扩展名。\\n \\n将加载文件的绝对路径添加到<code>$LOADED_FEATURES</code>（<code>$\"</code>）。如果文件路径已出现在<code>$\"</code>中，则不会再次加载该文件。例如，<code>require 'a'; require './a'</code>将不再加载<code>a.rb</code>。\\n \n  require \"my-library.rb\"\n  require \"db-driver\"\n \\n加载的源文件中的任何常量或全局将在调用程序的全局命名空间中可用。但是，局部变量不会传播到加载环境。", "name": "require", "namespace": "Kernel", "path": "Kernel#require", "type": "module_function", "visibility": "public"}, "Kernel#require_relative": {"description": "Ruby尝试相对于所需文件的路径加载名为string的库。如果无法确定文件路径，则引发LoadError。\\n如果加载了文件，则返回+true+，否则返回false。", "name": "require_relative", "namespace": "Kernel", "path": "Kernel#require_relative", "type": "module_function", "visibility": "public"}, "Kernel#select": {"description": "返回<em>ios的当前偏移量（以字节为单位）。n \n   f = File.new(\"testfile\")\n   f.pos    #=> 0\n   f.gets   #=> \"This is line one\\n\"\n   f.pos    #=> 17", "name": "select", "namespace": "Kernel", "path": "Kernel#select", "type": "module_function", "visibility": "public"}, "Kernel#set_trace_func": {"description": "将proc建立为跟踪处理程序，或者如果参数为+nil+，则禁用跟踪。\\n\\n*注：*此方法已过时，请改用TracePoint。\\n \\n proc最多包含六个参数：\\n \\n*事件名\\n*文件名\\n*行号\\n*对象ID \\n*绑定\\n*每次发生事件时都会调用类的名称\\n \\n proc。\\n \\n事件为：\\n \\n+c-call+：：调用C语言例程\\n+c-return+：：从C语言例程返回\\n+call+：：调用Ruby方法\\n+class+：：启动类或模块定义\\n+end+：：完成类或模块定义\\n+line+：：在新行上执行代码\\n+raise+：：引发异常\\n+return+：：从Ruby方法返回\\n \\n在proc的上下文中禁用跟踪。\\n \n    class Test\ndef test \\n a=1 \\n b=2 \\n end\n    end\n\n    set_trace_func proc { |event, file, line, id, binding, classname|\n  printf \"%8s %s:%-2d %10s %8s\\n\", event, file, line, id, classname\n    }\n    t = Test.new\n    t.test\n \\n line prog.rb:11 false\n    c-call prog.rb:11        new    Class\n    c-call prog.rb:11 initialize   Object\n  c-return prog.rb:11 initialize   Object\n  c-return prog.rb:11        new    Class\n line prog.rb:12 false \\n调用prog.rb:2 test test \\n line prog.rb:3 test \\n line prog.rb:4 test test \\n返回prog.rb:4 test test test", "name": "set_trace_func", "namespace": "Kernel", "path": "Kernel#set_trace_func", "type": "module_function", "visibility": "public"}, "Kernel#sleep": {"description": "将当前线程挂起持续秒（可以是任何数字，包括+Float+和小数秒）。返回休眠（四舍五入）的实际秒数，该值可能小于另一线程是否调用<code>Thread#run</code>所要求的秒数。调用时不带参数，sleep（）\\n将永远休眠。n \n   Time.new    #=> 2008-03-08 19:56:19 +0900\n   sleep 1.2   #=> 1\n   Time.new    #=> 2008-03-08 19:56:20 +0900\n   sleep 1.9   #=> 2\n   Time.new    #=> 2008-03-08 19:56:22 +0900", "name": "sleep", "namespace": "Kernel", "path": "Kernel#sleep", "type": "module_function", "visibility": "public"}, "Kernel#spawn": {"description": "设置此进程的组ID。", "name": "spawn", "namespace": "Kernel", "path": "Kernel#spawn", "type": "module_function", "visibility": "public"}, "Kernel#sprintf": {"description": "返回将<i>format_string<i>应用于任何其他参数所产生的字符串。在格式字符串中，除格式序列之外的任何字符都将复制到结果中。\\n \\n格式序列的语法如下。\\n \n  %[flags][width][.precision]type\n \\n格式序列由百分号、可选标志、宽度和精度指示器组成，然后以字段类型字符结尾。字段类型控制如何解释对应的<code>sprintf</code>参数，而标志则修改该解释。\\n \\n栏位类型的字元为：\\n \n    Field |  Integer Format\n    ------+--------------------------------------------------------------\n      b   | Convert argument as a binary number.\n          | Negative numbers will be displayed as a two's complement\n          | prefixed with `..1'.\n      B   | Equivalent to `b', but uses an uppercase 0B for prefix\n          | in the alternative format by #.\n      d   | Convert argument as a decimal number.\n      i   | Identical to `d'.\n      o   | Convert argument as an octal number.\n          | Negative numbers will be displayed as a two's complement\n          | prefixed with `..7'.\n      u   | Identical to `d'.\n      x   | Convert argument as a hexadecimal number.\n          | Negative numbers will be displayed as a two's complement\n          | prefixed with `..f' (representing an infinite string of\n          | leading 'ff's).\n      X   | Equivalent to `x', but uses uppercase letters.\n\n    Field |  Float Format\n    ------+--------------------------------------------------------------\n      e   | Convert floating point argument into exponential notation\n          | with one digit before the decimal point as [-]d.dddddde[+-]dd.\n          | The precision specifies the number of digits after the decimal\n          | point (defaulting to six).\n      E   | Equivalent to `e', but uses an uppercase E to indicate\n          | the exponent.\n      f   | Convert floating point argument as [-]ddd.dddddd,\n          | where the precision specifies the number of digits after\n          | the decimal point.\n      g   | Convert a floating point number using exponential form\n          | if the exponent is less than -4 or greater than or\n          | equal to the precision, or in dd.dddd form otherwise.\n          | The precision specifies the number of significant digits.\n      G   | Equivalent to `g', but use an uppercase `E' in exponent form.\n      a   | Convert floating point argument as [-]0xh.hhhhp[+-]dd,\n          | which is consisted from optional sign, \"0x\", fraction part\n          | as hexadecimal, \"p\", and exponential part as decimal.\n      A   | Equivalent to `a', but use uppercase `X' and `P'.\n\n    Field |  Other Format\n    ------+--------------------------------------------------------------\n      c   | Argument is the numeric code for a single character or\n          | a single character string itself.\n      p   | The valuing of argument.inspect.\n      s   | Argument is a string to be substituted.  If the format\n          | sequence contains a precision, at most that many characters\n          | will be copied.\n      %   | A percent sign itself will be displayed.  No argument taken.\n \\n标记会修改格式的行为。\\n标志字符为：\\n \n  Flag     | Applies to    | Meaning\n  ---------+---------------+-----------------------------------------\n  space    | bBdiouxX      | Leave a space at the start of\n           | aAeEfgG       | non-negative numbers.\n           | (numeric fmt) | For `o', `x', `X', `b' and `B', use\n           |               | a minus sign with absolute value for\n           |               | negative values.\n  ---------+---------------+-----------------------------------------\n  (digit)$ | all           | Specifies the absolute argument number\n           |               | for this field.  Absolute and relative\n           |               | argument numbers cannot be mixed in a\n           |               | sprintf string.\n  ---------+---------------+-----------------------------------------\n   #       | bBoxX         | Use an alternative format.\n           | aAeEfgG       | For the conversions `o', increase the precision\n           |               | until the first digit will be `0' if\n           |               | it is not formatted as complements.\n           |               | For the conversions `x', `X', `b' and `B'\n           |               | on non-zero, prefix the result with ``0x'',\n           |               | ``0X'', ``0b'' and ``0B'', respectively.\n           |               | For `a', `A', `e', `E', `f', `g', and 'G',\n           |               | force a decimal point to be added,\n           |               | even if no digits follow.\n           |               | For `g' and 'G', do not remove trailing zeros.\n  ---------+---------------+-----------------------------------------\n  +        | bBdiouxX      | Add a leading plus sign to non-negative\n           | aAeEfgG       | numbers.\n           | (numeric fmt) | For `o', `x', `X', `b' and `B', use\n           |               | a minus sign with absolute value for\n           |               | negative values.\n  ---------+---------------+-----------------------------------------\n  -        | all           | Left-justify the result of this conversion.\n  ---------+---------------+-----------------------------------------\n  0 (zero) | bBdiouxX      | Pad with zeros, not spaces.\n           | aAeEfgG       | For `o', `x', `X', `b' and `B', radix-1\n           | (numeric fmt) | is used for negative numbers formatted as\n           |               | complements.\n  ---------+---------------+-----------------------------------------\n  *        | all           | Use the next argument as the field width.\n           |               | If negative, left-justify the result. If the\n           |               | asterisk is followed by a number and a dollar\n           |               | sign, use the indicated argument as the width.\n \\n标志示例为：\\n \\n `+，空格标志指定非负数的符号。\\n  sprintf(\"%d\", 123)  #=> \"123\" \\n  sprintf(\"%+d\", 123) #=> \"+123\" \\n  sprintf(\"% d\", 123) #=> \" 123\" \\n \\n'o'标志增加数字位数以显示'0'。\\n `+'和空格标记更改负数的格式。\\n  sprintf(\"%o\", 123)   #=> \"173\" \\n  sprintf(\"%#o\", 123)  #=> \"0173\" \\n  sprintf(\"%+o\", -123) #=> \"-173\" \\n  sprintf(\"%o\", -123)  #=> \"..7605\" \\n  sprintf(\"%#o\", -123) #=> \"..7605\" \\n \\n `标记“x”为非零数字添加前缀“0x”。\\n `+'和空格标记禁用负数的补码。\\n  sprintf(\"%x\", 123)   #=> \"7b\" \\n  sprintf(\"%#x\", 123)  #=> \"0x7b\" \\n  sprintf(\"%+x\", -123) #=> \"-7b\" \\n  sprintf(\"%x\", -123)  #=> \"..f85\" \\n  sprintf(\"%#x\", -123) #=> \"0x..f85\" \\n  sprintf(\"%#x\", 0)    #=> \"0\" \\n \\n ` for'x'使用前缀'0x'。\\n  sprintf(\"%X\", 123)  #=> \"7B\" \\n  sprintf(\"%#X\", 123) #=> \"0X7B\" \\n \\n标记“b”为非零数字添加前缀“0b”。\\n `+'和空格标记禁用负数的补码。\\n  sprintf(\"%b\", 123)   #=> \"1111011\" \\n  sprintf(\"%#b\", 123)  #=> \"0b1111011\" \\n  sprintf(\"%+b\", -123) #=> \"-1111011\" \\n  sprintf(\"%b\", -123)  #=> \"..\n  browsers = ['Chrome', 'Firefox', 'Safari', 'Opera', 'IE']\n  browsers.length #=> 5\n  browsers.count #=> 5\n1\" \\n  sprintf(\"%#b\", -123) #=> \"0b..\n  browsers = ['Chrome', 'Firefox', 'Safari', 'Opera', 'IE']\n  browsers.length #=> 5\n  browsers.count #=> 5\n1\" \\n  sprintf(\"%#b\", 0)    #=> \"0\" \\n \\n `表示“b”使用前缀“0b”。\\n  sprintf(\"%B\", 123)  #=> \"1111011\" \\n  sprintf(\"%#B\", 123) #=> \"0B1111011\" \\n \\n表示“e”的力来显示小数点。\\n  sprintf(\"%.0e\", 1)  #=> \"1e+00\" \\n  sprintf(\"%#.0e\", 1) #=> \"1.e+00\" \\n \\n，'f'力显示小数点。\\n  sprintf(\"%.0f\", 1234)  #=> \"1234\" \\n  sprintf(\"%#.0f\", 1234) #=> \"1234.\" \\n \\n，'g'力显示小数点。\\n它还禁用剥离最低零。\\n  sprintf(\"%g\", 123.4)   #=> \"123.4\" \\n  sprintf(\"%#g\", 123.4)  #=> \"123.400\" \\n  sprintf(\"%g\", 123456)  #=> \"123456\" \\n  sprintf(\"%#g\", 123456) #=> \"123456.\" \\n \\n栏位宽度是可选的整数，后面可以是句点和精度。宽度指定将写入此字段结果的最小字符数。\\n \\n width的示例：\\n \\n padding由空格完成，width=20 \\n 0或基数-1。<-------------------\\n  sprintf(\"%20d\", 123)   #=> \"                 123\" \\n  sprintf(\"%+20d\", 123)  #=> \"                +123\" \\n  sprintf(\"%020d\", 123)  #=> \"00000000000000000123\" \\n  sprintf(\"%+020d\", 123) #=> \"+0000000000000000123\" \\n  sprintf(\"% 020d\", 123) #=> \" 0000000000000000123\" \\n  sprintf(\"%-20d\", 123)  #=> \"123                 \" \\n  sprintf(\"%-+20d\", 123) #=> \"+123                \" \\n  sprintf(\"%- 20d\", 123) #=> \" 123                \" \\n  sprintf(\"%020x\", -123) #=> \"..ffffffffffffffff85\" \\n \\n对于数字字段，精度控制显示的小数位数。对于字符串字段，精度决定要从字符串复制的最大字符数。（因此，格式序列<code>%10.10s</code>将始终为结果贡献10个\\n字符。）\\n \\n精度示例：\\n \\n“d”、“o”、“x”和“b”的精度是\\n最小位数<------>\\n  sprintf(\"%20.8d\", 123)  #=> \"            00000123\" \\n  sprintf(\"%20.8o\", 123)  #=> \"            00000173\" \\n  sprintf(\"%20.8x\", 123)  #=> \"            0000007b\" \\n  sprintf(\"%20.8b\", 123)  #=> \"            01111011\" \\n  sprintf(\"%20.8d\", -123) #=> \"           -00000123\" \\n  sprintf(\"%20.8o\", -123) #=> \"            ..777605\" \\n  sprintf(\"%20.8x\", -123) #=> \"            ..ffff85\" \\n  sprintf(\"%20.8b\", -11)  #=> \"            ..110101\" \\n \\n“0x”和“0”对于“x”和“B”，不计算\\n精度，但“0”表示“O”。<------>\\n  sprintf(\"%#20.8d\", 123)  #=> \"            00000123\" \\n  sprintf(\"%#20.8o\", 123)  #=> \"            00000173\" \\n  sprintf(\"%#20.8x\", 123)  #=> \"          0x0000007b\" \\n  sprintf(\"%#20.8b\", 123)  #=> \"          0b01111011\" \\n  sprintf(\"%#20.8d\", -123) #=> \"           -00000123\" \\n  sprintf(\"%#20.8o\", -123) #=> \"            ..777605\" \\n  sprintf(\"%#20.8x\", -123) #=> \"          0x..ffff85\" \\n  sprintf(\"%#20.8b\", -11)  #=> \"          0b..110101\" \\n \\n precision for'e'is number of \\n digits after the decimal point<------>\\n  sprintf(\"%20.8e\", 1234.56789) #=> \"      1.23456789e+03\" \\n \\n precision for'f'is number of \\n digits after the decimal point<------>\\n  sprintf(\"%20.8f\", 1234.56789) #=> \"       1234.56789000\" \\n \\n precision for'g'is n“s”的\\n有效数字的数量<------>\\n  sprintf(\"%20.8g\", 1234.56789) #=> \"           1234.5679\" \\n \\n<------>\\n  sprintf(\"%20.8g\", 123456789)  #=> \"       1.2345679e+08\" \\n \\n精度是\\n最大字符数<------>\\n  sprintf(\"%20.8s\", \"string test\") #=> \"            string t\" \\n \\n示例：\\n \n   sprintf(\"%d %04x\", 123, 123)               #=> \"123 007b\"\n   sprintf(\"%08b '%4s'\", 123, 123)            #=> \"01111011 ' 123'\"\n   sprintf(\"%1$*2$s %2$d %1$s\", \"hello\", 8)   #=> \"   hello 8 hello\"\n   sprintf(\"%1$*2$s %2$d\", \"hello\", -8)       #=> \"hello    -8\"\n   sprintf(\"%+g:% g:%-g\", 1.23, 1.23, 1.23)   #=> \"+1.23: 1.23:1.23\"\n   sprintf(\"%u\", -123)                        #=> \"-123\"\n \\n对于更复杂的格式，Ruby支持按名称引用.\\n%<name>s style使用格式样式，但%{name} style不使用格式样式。\\n\\n Examples:\n  sprintf(\"%<foo>d : %<bar>f\", { :foo => 1, :bar => 2 })\n    #=> 1 : 2.000000\n  sprintf(\"%{foo}f\", { :foo => 1 })\n    # => \"1f\"", "name": "sprintf", "namespace": "Kernel", "path": "Kernel#sprintf", "type": "module_function", "visibility": "public"}, "Kernel#srand": {"description": "创建绑定到当前上下文的新<code>Proc</code>对象。<code>Proc::new</code>只能在具有附加块的方法中调用而不调用块，在这种情况下，该块将转换为<code>Proc</code>对象。n \n   def proc_from\n     Proc.new\n   end\n   proc = proc_from { \"hello\" }\n   proc.call   #=> \"hello\"", "name": "srand", "namespace": "Kernel", "path": "Kernel#srand", "type": "module_function", "visibility": "public"}, "Kernel#syscall": {"description": "调用由num标识的操作系统函数，并返回该函数的结果，如果失败则引发SystemCallError。\\n \\n函数的参数可以跟在num后面。它们必须是+String+对象或+Integer+对象。+String+对象作为指向字节序列的指针传递。+Integer+对象作为一个整数传递，其位大小与指针相同。\\n最多可以传递九个参数。\\n \\n由num标识的函数依赖于系统。在某些Unix系统上，可以从名为<code>syscall.h</code>的头文件中获得数字。\\n \n   syscall 4, 1, \"hello\\n\", 6   # '4' is write(2) on our box\n \\n<em>生成：.<em>\\n \n   hello\n \\n在平台上调用+syscall+，该平台不具有任何方法来实现任意系统功能，但使用NotImplementedError失败。\\n \\n*注：*\\n +syscall+本质上不安全且不可移动。\\n自由射门。\\n为了更安全和更便携的编程，首选使用dl（fiddle）库。", "name": "syscall", "namespace": "Kernel", "path": "Kernel#syscall", "type": "module_function", "visibility": "public"}, "Kernel#system": {"description": "在子shell中执行\\命令…\\。\\n\\u command…\\u是以下表单之一。\\n \n  commandline                 : command line string which is passed to the standard shell\n  cmdname, arg1, ...          : command name and one or more arguments (no shell)\n  [cmdname, argv0], arg1, ... : command name, argv[0] and zero or more arguments (no shell)\n \\n如果命令给出零退出状态，则系统返回+true+，对于非零退出状态，则返回+false+。\\n如果命令执行失败，则返回+nil+。\\n <code>$?</code>中有一个错误状态。\\n参数的处理方式与<code>Kernel.spawn</code>相同。\\n \\n散列参数env和options与<code>exec</code>和<code>spawn</code>相同。\\n有关详细信息，请参阅<code>Kernel.spawn</code>。\\n \n   system(\"echo *\")\n   system(\"echo\", \"*\")\n \\n<em>products:-\\n \n   config.h main.rb\n   *\n \\n see <code>Kernel.exec</code> for the standard shell.", "name": "system", "namespace": "Kernel", "path": "Kernel#system", "type": "module_function", "visibility": "public"}, "Kernel#test": {"description": "使用字符+cmd+在+file1+（下表1）或+file1+和+file2+（下表2）上执行各种测试。\\n \\n单个文件上的文件测试：\\n \n  Cmd    Returns   Meaning\n  \"A\"  | Time    | Last access time for file1\n  \"b\"  | boolean | True if file1 is a block device\n  \"c\"  | boolean | True if file1 is a character device\n  \"C\"  | Time    | Last change time for file1\n  \"d\"  | boolean | True if file1 exists and is a directory\n  \"e\"  | boolean | True if file1 exists\n  \"f\"  | boolean | True if file1 exists and is a regular file\n  \"g\"  | boolean | True if file1 has the \\CF{setgid} bit\n       |         | set (false under NT)\n  \"G\"  | boolean | True if file1 exists and has a group\n       |         | ownership equal to the caller's group\n  \"k\"  | boolean | True if file1 exists and has the sticky bit set\n  \"l\"  | boolean | True if file1 exists and is a symbolic link\n  \"M\"  | Time    | Last modification time for file1\n  \"o\"  | boolean | True if file1 exists and is owned by\n       |         | the caller's effective uid\n  \"O\"  | boolean | True if file1 exists and is owned by\n       |         | the caller's real uid\n  \"p\"  | boolean | True if file1 exists and is a fifo\n  \"r\"  | boolean | True if file1 is readable by the effective\n       |         | uid/gid of the caller\n  \"R\"  | boolean | True if file is readable by the real\n       |         | uid/gid of the caller\n  \"s\"  | int/nil | If file1 has nonzero size, return the size,\n       |         | otherwise return nil\n  \"S\"  | boolean | True if file1 exists and is a socket\n  \"u\"  | boolean | True if file1 has the setuid bit set\n  \"w\"  | boolean | True if file1 exists and is writable by\n       |         | the effective uid/gid\n  \"W\"  | boolean | True if file1 exists and is writable by\n       |         | the real uid/gid\n  \"x\"  | boolean | True if file1 exists and is executable by\n       |         | the effective uid/gid\n  \"X\"  | boolean | True if file1 exists and is executable by\n       |         | the real uid/gid\n  \"z\"  | boolean | True if file1 exists and has a zero length\n \\n接受两个文件的测试：\\n \n  \"-\"  | boolean | True if file1 and file2 are identical\n  \"=\"  | boolean | True if the modification times of file1\n       |         | and file2 are equal\n  \"<\"  | boolean | True if the modification time of file1\n       |         | is prior to that of file2\n  \">\"  | boolean | True if the modification time of file1\n在文件2的测试之后", "name": "test", "namespace": "Kernel", "path": "Kernel#test", "type": "module_function", "visibility": "public"}, "Kernel#throw": {"description": "将控制权转移到活动+catch+块的末尾，等待标记。如果标记没有+catch+块，则引发+UncaughtThrowError+。可选的第二个参数为+catch+块提供返回值，否则默认为+nil+。有关示例，请参见<code>Kernel::catch</code>。", "name": "throw", "namespace": "Kernel", "path": "Kernel#throw", "type": "module_function", "visibility": "public"}, "Kernel#trace_var": {"description": "控制对全局变量分配的跟踪。参数+symbol+标识变量（字符串名称或符号标识符）。无论何时分配变量，都会执行cmd（可以是字符串或+Proc+对象）或块。块或+Proc+对象接收变量的新值作为参数。另见<code>Kernel::untrace_var</code>。\\n \n   trace_var :$_, proc {|v| puts \"$_ is now '#{v}'\" }\n   $_ = \"hello\"\n   $_ = ' there'\n \\n<em>产生：.<em>\\n \n   $_ is now 'hello'\n$u is now'there'", "name": "trace_var", "namespace": "Kernel", "path": "Kernel#trace_var", "type": "module_function", "visibility": "public"}, "Kernel#trap": {"description": "如果stat因未捕获信号而终止，则返回+true+。", "name": "trap", "namespace": "Kernel", "path": "Kernel#trap", "type": "module_function", "visibility": "public"}, "Kernel#untrace_var": {"description": "删除对给定全局变量的指定命令的跟踪，并返回+nil+。如果未指定命令，则删除该变量的所有跟踪，并返回包含实际删除的命令的数组。", "name": "untrace_var", "namespace": "Kernel", "path": "Kernel#untrace_var", "type": "module_function", "visibility": "public"}, "Kernel#warn": {"description": "如果已禁用警告（例如使用<code>-W0</code>标志），则不执行任何操作。否则，将每条消息转换为字符串，如果字符串不是以换行符结尾，则将换行符追加到字符串，然后用该字符串调用<code>Warning.warn</code>。\\n \n   warn(\"warning 1\", \"warning 2\")\n \\n<em>产生：.<em>\\n \n   warning 1\n warning 2", "name": "warn", "namespace": "Kernel", "path": "Kernel#warn", "type": "module_function", "visibility": "public"}, "NilClass": {"description": "singleton对象<code>nil</code>的类。", "name": "NilClass", "namespace": "", "path": "NilClass", "type": "class", "visibility": "public"}, "NilClass#&": {"description": "returns +int+ truncated（对零）到一个precision的+ndigits+（decimal地点安装默认：0）。是的。当precision是负的，返回的是一个价值integer与至少<code>ndigits.abs</code> trailing文件。的returns +self+ ---当+ndigits+是零或正相关。\n   1.truncate           #=> 1\n   1.truncate(2)        #=> 1\n   18.truncate(-1)      #=> 10\n   (-18).truncate(-1)   #=> -10。", "name": "&", "namespace": "NilClass", "path": "NilClass#&", "type": "instance_method", "visibility": "public"}, "NilClass#===": {"description": "iterates的给定的块，通过在integer价值从+int+到和包括+limit+。是的。如果没有布拉克是给定的，而enumerator是安全返回。   5.upto(10) {|i| print i, \" \" }   #=> 5 6 7 8 9 10 ---。", "name": "===", "namespace": "NilClass", "path": "NilClass#===", "type": "instance_method", "visibility": "public"}, "NilClass#^": {"description": "bitwise或。", "name": "^", "namespace": "NilClass", "path": "NilClass#^", "type": "instance_method", "visibility": "public"}, "NilClass#inspect": {"description": "始终返回字符串“nil”。", "name": "inspect", "namespace": "NilClass", "path": "NilClass#inspect", "type": "instance_method", "visibility": "public"}, "NilClass#nil?": {"description": "只有对象<i>nil</i>响应<code>true</code>到<code>nil?</code>。", "name": "nil?", "namespace": "NilClass", "path": "NilClass#nil?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "NilClass#rationalize": {"description": "以有理数形式返回零。可选参数+eps+始终被忽略。", "name": "rationalize", "namespace": "NilClass", "path": "NilClass#rationalize", "type": "instance_method", "visibility": "public"}, "NilClass#to_a": {"description": "call seq:\n    nil.to_a    -> []\n \\n始终返回空数组。\\n\\n     nil.to_a   #=> []", "name": "to_a", "namespace": "NilClass", "path": "NilClass#to_a", "type": "instance_method", "visibility": "public"}, "NilClass#to_c": {"description": "以复数形式返回零。", "name": "to_c", "namespace": "NilClass", "path": "NilClass#to_c", "type": "instance_method", "visibility": "public"}, "NilClass#to_f": {"description": "总是返回零。\\n\\n    nil.to_f   #=> 0.0", "name": "to_f", "namespace": "NilClass", "path": "NilClass#to_f", "type": "instance_method", "visibility": "public"}, "NilClass#to_h": {"description": "call seq:\n    nil.to_h    -> {}\n \\n始终返回空哈希。\\n\\n     nil.to_h   #=> {}", "name": "to_h", "namespace": "NilClass", "path": "NilClass#to_h", "type": "instance_method", "visibility": "public"}, "NilClass#to_i": {"description": "总是返回零。\\n\\n    nil.to_i   #=> 0", "name": "to_i", "namespace": "NilClass", "path": "NilClass#to_i", "type": "instance_method", "visibility": "public"}, "NilClass#to_r": {"description": "以有理数形式返回零。", "name": "to_r", "namespace": "NilClass", "path": "NilClass#to_r", "type": "instance_method", "visibility": "public"}, "NilClass#to_s": {"description": "始终返回空字符串。", "name": "to_s", "namespace": "NilClass", "path": "NilClass#to_s", "type": "instance_method", "visibility": "public"}, "NilClass#|": {"description": "loaded gmp的版本。", "name": "|", "namespace": "NilClass", "path": "NilClass#|", "type": "instance_method", "visibility": "public"}, "Numeric": {"description": "numeric是所有高级数值类都应该从中继承的类。\\n \\n numeric允许实例化堆分配的对象。其他核心数值类（如integer）实现为immediates，这意味着每个integer都是一个单一的不可变对象，并且总是按值传递。\\n \n  a = 1\n  1.object_id == a.object_id   #=> true\n \\n例如，整数+1+只能有一个实例。Ruby通过阻止实例化来确保这一点。如果尝试复制，则返回相同的实例。\\n \n  Integer.new(1)                   #=> NoMethodError: undefined method `new' for Integer:Class\n  1.dup                            #=> 1\n  1.object_id == 1.dup.object_id   #=> true\n \\n因此，在定义其他数值类时，应使用数值。\\n \\n从numeric继承的类必须实现+coerce+，它返回一个包含一个对象的两成员数组，该对象已被强制转换为新类和+self+的实例（请参见强制）。\\n \\n继承类还应实现算术运算符方法（<code>+</code>、\\n <code>-</code>、<code>*</code>和<code>/</code>）和<code><=></code>运算符（请参阅可比较的）。这些方法可能依赖于+coerce+来确保与其他数值类的实例的互操作性。n \n  class Tally < Numeric\n    def initialize(string)\n      @string = string\n    end\n\n    def to_s\n      @string\n    end\n\n    def to_i\n      @string.size\n    end\n\n    def coerce(other)\n      [self.class.new('|' * other.to_i), self]\n    end\n\n    def <=>(other)\n      to_i <=> other.to_i\n    end\n\n    def +(other)\n      self.class.new('|' * (to_i + other.to_i))\n    end\n\n    def -(other)\n      self.class.new('|' * (to_i - other.to_i))\n    end\n\n    def *(other)\n      self.class.new('|' * (to_i * other.to_i))\n    end\n\n    def /(other)\n      self.class.new('|' * (to_i / other.to_i))\n    end\n  end\n\n  tally = Tally.new('||')\n  puts tally * 2            #=> \"||||\"\n  puts tally > 1            #=> true", "name": "Numeric", "namespace": "", "path": "Numeric", "type": "class", "visibility": "public"}, "Numeric#%": {"description": "<code>x.modulo(y)</code>表示<code>x-y*(x/y).floor</code>。\\n \\n相当于<code>num.divmod(numeric)[1]</code>。\\n \\n请参阅numeric divmod。", "name": "%", "namespace": "Numeric", "path": "Numeric#%", "type": "instance_method", "visibility": "public"}, "Numeric#+@": {"description": "一元加号-返回接收器。", "name": "+@", "namespace": "Numeric", "path": "Numeric#+@", "type": "instance_method", "visibility": "public"}, "Numeric#-@": {"description": "一元减号-返回接收者，负数。", "name": "-@", "namespace": "Numeric", "path": "Numeric#-@", "type": "instance_method", "visibility": "public"}, "Numeric#<=>": {"description": "如果+number+等于+other+，则返回零，否则返回+nil+。", "name": "<=>", "namespace": "Numeric", "path": "Numeric#<=>", "type": "instance_method", "visibility": "public"}, "Numeric#abs": {"description": "返回绝对值+num+。\\n \n   12.abs         #=> 12\n   (-34.56).abs   #=> 34.56\n   -34.56.abs     #=> 34.56\n \\n numeric Magnitude是numeric abs的别名。", "name": "abs", "namespace": "Numeric", "path": "Numeric#abs", "type": "instance_method", "visibility": "public"}, "Numeric#abs2": {"description": "返回自身的平方。", "name": "abs2", "namespace": "Numeric", "path": "Numeric#abs2", "type": "instance_method", "visibility": "public"}, "Numeric#angle": {"description": "返回大于或等于+float+的最小数字，精度为+ndigits+位十进制数字（默认值：0）。\\n \\n如果精度为负，则返回的值是一个整数，后面至少有<code>ndigits.abs</code>个零。\\n \\n当+ndigits+为正数时返回浮点数，否则返回整数。\\n \n   1.2.ceil      #=> 2\n   2.0.ceil      #=> 2\n   (-1.2).ceil   #=> -1\n   (-2.0).ceil   #=> -2\n\n   1.234567.ceil(2)   #=> 1.24\n   1.234567.ceil(3)   #=> 1.235\n   1.234567.ceil(4)   #=> 1.2346\n   1.234567.ceil(5)   #=> 1.23457\n\n   34567.89.ceil(-5)  #=> 100000\n   34567.89.ceil(-4)  #=> 40000\n   34567.89.ceil(-3)  #=> 35000\n   34567.89.ceil(-2)  #=> 34600\n   34567.89.ceil(-1)  #=> 34570\n   34567.89.ceil(0)   #=> 34568\n   34567.89.ceil(1)   #=> 34567.9\n   34567.89.ceil(2)   #=> 34567.89\n   34567.89.ceil(3)   #=> 34567.89\n \\n请注意，浮点运算的有限精度可能会导致令人惊讶的结果：\\n \\n    (2.1 / 0.7).ceil  #=> 4 (!)", "name": "angle", "namespace": "Numeric", "path": "Numeric#angle", "type": "instance_method", "visibility": "public"}, "Numeric#arg": {"description": "返回大于或等于+float+的最小数字，精度为+ndigits+位十进制数字（默认值：0）。\\n \\n如果精度为负，则返回的值是一个整数，后面至少有<code>ndigits.abs</code>个零。\\n \\n当+ndigits+为正数时返回浮点数，否则返回整数。\\n \n   1.2.ceil      #=> 2\n   2.0.ceil      #=> 2\n   (-1.2).ceil   #=> -1\n   (-2.0).ceil   #=> -2\n\n   1.234567.ceil(2)   #=> 1.24\n   1.234567.ceil(3)   #=> 1.235\n   1.234567.ceil(4)   #=> 1.2346\n   1.234567.ceil(5)   #=> 1.23457\n\n   34567.89.ceil(-5)  #=> 100000\n   34567.89.ceil(-4)  #=> 40000\n   34567.89.ceil(-3)  #=> 35000\n   34567.89.ceil(-2)  #=> 34600\n   34567.89.ceil(-1)  #=> 34570\n   34567.89.ceil(0)   #=> 34568\n   34567.89.ceil(1)   #=> 34567.9\n   34567.89.ceil(2)   #=> 34567.89\n   34567.89.ceil(3)   #=> 34567.89\n \\n请注意，浮点运算的有限精度可能会导致令人惊讶的结果：\\n \\n    (2.1 / 0.7).ceil  #=> 4 (!)", "name": "arg", "namespace": "Numeric", "path": "Numeric#arg", "type": "instance_method", "visibility": "public"}, "Numeric#ceil": {"description": "返回大于或等于+num+的最小数字，精度为+ndigits+位小数（默认值：0）。\\n \\n numeric通过将其值转换为float并调用float_ceil来实现此功能。", "name": "ceil", "namespace": "Numeric", "path": "Numeric#ceil", "type": "instance_method", "visibility": "public"}, "Numeric#clone": {"description": "返回接收器。+freeze+不能是+false+。", "name": "clone", "namespace": "Numeric", "path": "Numeric#clone", "type": "instance_method", "visibility": "public"}, "Numeric#coerce": {"description": "", "name": "coerce", "namespace": "Numeric", "path": "Numeric#coerce", "type": "instance_method", "visibility": "public"}, "Numeric#conj": {"description": "返回以+base+为基数的+int+的位值表示形式的数字（默认值：10）。\\n这些数字作为数组返回，其中最低有效数字作为第一个数组元素。\\n \\n +base+必须大于或等于2。\\n \n   12345.digits      #=> [5, 4, 3, 2, 1]\n   12345.digits(7)   #=> [4, 6, 6, 0, 5]\n   12345.digits(100) #=> [45, 23, 1]\n \\n    -12345.digits(7)  #=> Math::DomainError", "name": "conj", "namespace": "Numeric", "path": "Numeric#conj", "type": "instance_method", "visibility": "public"}, "Numeric#conjugate": {"description": "返回以+base+为基数的+int+的位值表示形式的数字（默认值：10）。\\n这些数字作为数组返回，其中最低有效数字作为第一个数组元素。\\n \\n +base+必须大于或等于2。\\n \n   12345.digits      #=> [5, 4, 3, 2, 1]\n   12345.digits(7)   #=> [4, 6, 6, 0, 5]\n   12345.digits(100) #=> [45, 23, 1]\n \\n    -12345.digits(7)  #=> Math::DomainError", "name": "conjugate", "namespace": "Numeric", "path": "Numeric#conjugate", "type": "instance_method", "visibility": "public"}, "Numeric#denominator": {"description": "返回分母（始终为正）。", "name": "denominator", "namespace": "Numeric", "path": "Numeric#denominator", "type": "instance_method", "visibility": "public"}, "Numeric#div": {"description": "使用+/+执行除法，然后将结果转换为整数。\\n numeric没有定义+/+operator;，这是留给子类的。\\n \\n相当于<code>num.divmod(numeric)[0]</code>。\\n \\n请参阅numeric divmod。", "name": "div", "namespace": "Numeric", "path": "Numeric#div", "type": "instance_method", "visibility": "public"}, "Numeric#divmod": {"description": "返回一个数组，该数组包含用+num+除以+numeric+得到的商和模。\\n \\n如果是<code>q, r = x.divmod(y)</code>，则\\n \n    q = floor(x/y)\n    x = q*y + r\n \\n商被四舍五入为负无穷大，如下表所示：\\n \n   a    |  b  |  a.divmod(b)  |   a/b   | a.modulo(b) | a.remainder(b)\n  ------+-----+---------------+---------+-------------+---------------\n   13   |  4  |   3,    1     |   3     |    1        |     1\n  ------+-----+---------------+---------+-------------+---------------\n   13   | -4  |  -4,   -3     |  -4     |   -3        |     1\n  ------+-----+---------------+---------+-------------+---------------\n  -13   |  4  |  -4,    3     |  -4     |    3        |    -1\n  ------+-----+---------------+---------+-------------+---------------\n  -13   | -4  |   3,   -1     |   3     |   -1        |    -1\n  ------+-----+---------------+---------+-------------+---------------\n   11.5 |  4  |   2,    3.5   |   2.875 |    3.5      |     3.5\n  ------+-----+---------------+---------+-------------+---------------\n   11.5 | -4  |  -3,   -0.5   |  -2.875 |   -0.5      |     3.5\n  ------+-----+---------------+---------+-------------+---------------\n  -11.5 |  4  |  -3,    0.5   |  -2.875 |    0.5      |    -3.5\n  ------+-----+---------------+---------+-------------+---------------\n  -11.5 | -4  |   2,   -3.5   |   2.875 |   -3.5      |    -3.5\n \\n \\n示例\n   11.divmod(3)        #=> [3, 2]\n   11.divmod(-3)       #=> [-4, -1]\n   11.divmod(3.5)      #=> [3, 0.5]\n   (-11).divmod(3.5)   #=> [-4, 3.0]\n   11.5.divmod(3.5)    #=> [3, 1.0]", "name": "divmod", "namespace": "Numeric", "path": "Numeric#divmod", "type": "instance_method", "visibility": "public"}, "Numeric#dup": {"description": "返回接收器。", "name": "dup", "namespace": "Numeric", "path": "Numeric#dup", "type": "instance_method", "visibility": "public"}, "Numeric#eql?": {"description": "如果+num+和+numeric+是同一类型且值相等，则返回+true+。将其与执行类型转换的numeric==进行对比。n \n   1 == 1.0        #=> true\n   1.eql?(1.0)     #=> false\n   1.0.eql?(1.0)   #=> true", "name": "eql?", "namespace": "Numeric", "path": "Numeric#eql?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Numeric#fdiv": {"description": "返回浮点除法。", "name": "fdiv", "namespace": "Numeric", "path": "Numeric#fdiv", "type": "instance_method", "visibility": "public"}, "Numeric#finite?": {"description": "如果+num+是有限数，则返回+true+，否则返回+false+。", "name": "finite?", "namespace": "Numeric", "path": "Numeric#finite?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Numeric#floor": {"description": "返回小于或等于+num+的最大数字，精度为+ndigits+位十进制数字（默认值：0）。\\n \\n numeric通过将其值转换为float并调用float floor来实现此功能。", "name": "floor", "namespace": "Numeric", "path": "Numeric#floor", "type": "instance_method", "visibility": "public"}, "Numeric#i": {"description": "返回相应的虚数。\\n不适用于复数。n \n   -42.i  #=> (0-42i)\n   2.0.i  #=> (0+2.0i)", "name": "i", "namespace": "Numeric", "path": "Numeric#i", "type": "instance_method", "visibility": "public"}, "Numeric#imag": {"description": "返回零。", "name": "imag", "namespace": "Numeric", "path": "Numeric#imag", "type": "instance_method", "visibility": "public"}, "Numeric#imaginary": {"description": "返回零。", "name": "imaginary", "namespace": "Numeric", "path": "Numeric#imaginary", "type": "instance_method", "visibility": "public"}, "Numeric#infinite?": {"description": "根据值是有限的、<code>-Infinity</code>还是<code>+Infinity</code>，返回+nil+、-1或1。", "name": "infinite?", "namespace": "Numeric", "path": "Numeric#infinite?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Numeric#integer?": {"description": "如果+num+是整数，则返回+true+。n \n    1.0.integer?   #=> false\n    1.integer?     #=> true", "name": "integer?", "namespace": "Numeric", "path": "Numeric#integer?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Numeric#magnitude": {"description": "返回绝对值+num+。\\n \n   12.abs         #=> 12\n   (-34.56).abs   #=> 34.56\n   -34.56.abs     #=> 34.56\n \\n numeric Magnitude是numeric abs的别名。", "name": "magnitude", "namespace": "Numeric", "path": "Numeric#magnitude", "type": "instance_method", "visibility": "public"}, "Numeric#modulo": {"description": "<code>x.modulo(y)</code>表示<code>x-y*(x/y).floor</code>。\\n \\n相当于<code>num.divmod(numeric)[1]</code>。\\n \\n请参阅numeric divmod。", "name": "modulo", "namespace": "Numeric", "path": "Numeric#modulo", "type": "instance_method", "visibility": "public"}, "Numeric#negative?": {"description": "如果+num+小于0，则返回+true+。", "name": "negative?", "namespace": "Numeric", "path": "Numeric#negative?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Numeric#nonzero?": {"description": "如果+num+不是零，则返回+self+，否则返回+nil+。\\n \\n链接比较时此行为很有用：\\n \n   a = %w( z Bb bB bb BB a aA Aa AA A )\n   b = a.sort {|a,b| (a.downcase <=> b.downcase).nonzero? || a <=> b }\n   b   #=> [\"A\", \"a\", \"AA\", \"Aa\", \"aA\", \"BB\", \"Bb\", \"bB\", \"bb\", \"z\"]", "name": "nonzero?", "namespace": "Numeric", "path": "Numeric#nonzero?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Numeric#numerator": {"description": "返回分子。", "name": "numerator", "namespace": "Numeric", "path": "Numeric#numerator", "type": "instance_method", "visibility": "public"}, "Numeric#phase": {"description": "返回大于或等于+float+的最小数字，精度为+ndigits+位十进制数字（默认值：0）。\\n \\n如果精度为负，则返回的值是一个整数，后面至少有<code>ndigits.abs</code>个零。\\n \\n当+ndigits+为正数时返回浮点数，否则返回整数。\\n \n   1.2.ceil      #=> 2\n   2.0.ceil      #=> 2\n   (-1.2).ceil   #=> -1\n   (-2.0).ceil   #=> -2\n\n   1.234567.ceil(2)   #=> 1.24\n   1.234567.ceil(3)   #=> 1.235\n   1.234567.ceil(4)   #=> 1.2346\n   1.234567.ceil(5)   #=> 1.23457\n\n   34567.89.ceil(-5)  #=> 100000\n   34567.89.ceil(-4)  #=> 40000\n   34567.89.ceil(-3)  #=> 35000\n   34567.89.ceil(-2)  #=> 34600\n   34567.89.ceil(-1)  #=> 34570\n   34567.89.ceil(0)   #=> 34568\n   34567.89.ceil(1)   #=> 34567.9\n   34567.89.ceil(2)   #=> 34567.89\n   34567.89.ceil(3)   #=> 34567.89\n \\n请注意，浮点运算的有限精度可能会导致令人惊讶的结果：\\n \\n    (2.1 / 0.7).ceil  #=> 4 (!)", "name": "phase", "namespace": "Numeric", "path": "Numeric#phase", "type": "instance_method", "visibility": "public"}, "Numeric#polar": {"description": "返回array;[num.abs，num.arg]。", "name": "polar", "namespace": "Numeric", "path": "Numeric#polar", "type": "instance_method", "visibility": "public"}, "Numeric#positive?": {"description": "如果+num+大于0，则返回+true+。", "name": "positive?", "namespace": "Numeric", "path": "Numeric#positive?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Numeric#quo": {"description": "返回最精确的除法（整型有理，浮点型浮点）。", "name": "quo", "namespace": "Numeric", "path": "Numeric#quo", "type": "instance_method", "visibility": "public"}, "Numeric#real": {"description": "返回以+base+为基数的+int+的位值表示形式的数字（默认值：10）。\\n这些数字作为数组返回，其中最低有效数字作为第一个数组元素。\\n \\n +base+必须大于或等于2。\\n \n   12345.digits      #=> [5, 4, 3, 2, 1]\n   12345.digits(7)   #=> [4, 6, 6, 0, 5]\n   12345.digits(100) #=> [45, 23, 1]\n \\n    -12345.digits(7)  #=> Math::DomainError", "name": "real", "namespace": "Numeric", "path": "Numeric#real", "type": "instance_method", "visibility": "public"}, "Numeric#real?": {"description": "如果+num+是实数（即不复杂），则返回+true+。", "name": "real?", "namespace": "Numeric", "path": "Numeric#real?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Numeric#rect": {"description": "返回array;[num，0]。", "name": "rect", "namespace": "Numeric", "path": "Numeric#rect", "type": "instance_method", "visibility": "public"}, "Numeric#rectangular": {"description": "返回array;[num，0]。", "name": "rectangular", "namespace": "Numeric", "path": "Numeric#rectangular", "type": "instance_method", "visibility": "public"}, "Numeric#remainder": {"description": "<code>x.remainder(y)</code>表示<code>x-y*(x/y).truncate</code>。\\n \\n请参阅numeric divmod。", "name": "remainder", "namespace": "Numeric", "path": "Numeric#remainder", "type": "instance_method", "visibility": "public"}, "Numeric#round": {"description": "返回+num+，四舍五入到最接近的值，精度为+ndigits+位十进制数字（默认值：0）。\\n \\n numeric通过将其值转换为float并调用float round来实现此功能。", "name": "round", "namespace": "Numeric", "path": "Numeric#round", "type": "instance_method", "visibility": "public"}, "Numeric#singleton_method_added": {"description": ":nodoc:\n\nTrap attempts to add methods to Numeric objects. Always raises a TypeError.\n\nNumerics should be values; singleton_methods should not be added to them.", "name": "singleton_method_added", "namespace": "Numeric", "path": "Numeric#singleton_method_added", "type": "instance_method", "visibility": "public"}, "Numeric#step": {"description": "Invokes the given block with the sequence of numbers starting at +num+, \\n incremented by +step+ (defaulted to +1+) on each call. \\n  \\n The loop finishes when the value to be passed to the block is greater than \\n +limit+ (if +step+ is positive) or less than +limit+ (if +step+ is negative), where +limit+ is defaulted to infinity. \\n  \\n In the recommended keyword argument style, either or both of +step+ and +limit+ (default infinity) can be omitted.  In the fixed position argument style, zero as a step \\n (i.e. <code>num.step(limit, 0)</code>) is not allowed for historical compatibility reasons. \\n  \\n If all the arguments are integers, the loop operates using an integer counter. \\n  \\n If any of the arguments are floating point numbers, all are converted to floats, and the loop is executed \\n <i>floor(n + n*Float::EPSILON) + 1</i> times, \\n where <i>n = (limit - num)/step</i>. \\n  \\n Otherwise, the loop starts at +num+, uses either the less-than (<code><</code>) or greater-than (<code>></code>) operator to compare the counter against +limit+, \\n and increments itself using the <code>+</code> operator. \\n  \\n If no block is given, an Enumerator is returned instead. \\n  \\n For example: \\n \n   p 1.step.take(4)\n   p 10.step(by: -1).take(4)\n   3.step(to: 5) {|i| print i, \" \" }\n   1.step(10, 2) {|i| print i, \" \" }\n   Math::E.step(to: Math::PI, by: 0.2) {|f| print f, \" \" }\n \\n Will produce: \\n \n   [1, 2, 3, 4]\n   [10, 9, 8, 7]\n   3 4 5\n   1 3 5 7 9\n   2.718281828459045 2.9182818284590453 3.118281828459045", "name": "step", "namespace": "Numeric", "path": "Numeric#step", "type": "instance_method", "visibility": "public"}, "Numeric#to_c": {"description": "Returns the value as a complex.", "name": "to_c", "namespace": "Numeric", "path": "Numeric#to_c", "type": "instance_method", "visibility": "public"}, "Numeric#to_int": {"description": "Invokes the child class's +to_i+ method to convert +num+ to an integer. \\n \n    1.0.class          #=> Float\n    1.0.to_int.class   #=> Integer\n    1.0.to_i.class     #=> Integer", "name": "to_int", "namespace": "Numeric", "path": "Numeric#to_int", "type": "instance_method", "visibility": "public"}, "Numeric#truncate": {"description": "Returns +num+ truncated (toward zero) to a precision of +ndigits+ decimal digits (default: 0). \\n  \\n Numeric implements this by converting its value to a Float and invoking Float#truncate.", "name": "truncate", "namespace": "Numeric", "path": "Numeric#truncate", "type": "instance_method", "visibility": "public"}, "Numeric#zero?": {"description": "Returns +true+ if +num+ has a zero value.", "name": "zero?", "namespace": "Numeric", "path": "Numeric#zero?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "String": {"description": "A <code>String</code> object holds and manipulates an arbitrary sequence of bytes, typically representing characters. String objects may be created using <code>String::new</code> or as literals. \\n  \\n Because of aliasing issues, users of strings should be aware of the methods that modify the contents of a <code>String</code> object.  Typically, \\n methods with names ending in ``!'' modify their receiver, while those without a ``!'' return a new <code>String</code>.  However, there are exceptions, such as <code>String#[]=</code>.", "name": "String", "namespace": "", "path": "String", "type": "class", "visibility": "public"}, "String#%": {"description": "Format — Uses <i>str</i> as a format specification, and returns the result of applying it to <i>arg</i>. If the format specification contains more than \\n one substitution, then <i>arg</i> must be an <code>Array</code> or <code>Hash</code> \\n containing the values to be substituted. See <code>Kernel::sprintf</code> for details of the format string. \\n \n   \"%05d\" % 123                              #=> \"00123\"\n   \"%-5s: %08x\" % [ \"ID\", self.object_id ]   #=> \"ID   : 200e14d6\"\n   \"foo = %{foo}\" % { :foo => 'bar' }        #=> \"foo = bar\"", "name": "%", "namespace": "String", "path": "String#%", "type": "instance_method", "visibility": "public"}, "String#*": {"description": "Copy — Returns a new String containing +integer+ copies of the receiver. \\n +integer+ must be greater than or equal to 0. \\n \n   \"Ho! \" * 3   #=> \"Ho! Ho! Ho! \"\n   \"Ho! \" * 0   #=> \"\"", "name": "*", "namespace": "String", "path": "String#*", "type": "instance_method", "visibility": "public"}, "String#+": {"description": "Concatenation — Returns a new <code>String</code> containing \\n <i>other_str</i> concatenated to <i>str</i>. \\n  \\n    \"Hello from \" + self.to_s   #=> \"Hello from main\"", "name": "+", "namespace": "String", "path": "String#+", "type": "instance_method", "visibility": "public"}, "String#+@": {"description": "If the string is frozen, then return duplicated mutable string. \\n  \\n If the string is not frozen, then return the string itself.", "name": "+@", "namespace": "String", "path": "String#+@", "type": "instance_method", "visibility": "public"}, "String#-@": {"description": "If the string is frozen, then return the string itself. \\n  \\n If the string is not frozen, return a frozen, possibly pre-existing copy of it.", "name": "-@", "namespace": "String", "path": "String#-@", "type": "instance_method", "visibility": "public"}, "String#<<": {"description": "Appends the given object to <i>str</i>. If the object is an \\n <code>Integer</code>, it is considered a codepoint and converted to a character before being appended. \\n \n   a = \"hello \"\n   a << \"world\"   #=> \"hello world\"\n   a << 33        #=> \"hello world!\"\n \\n See also String#concat, which takes multiple arguments.", "name": "<<", "namespace": "String", "path": "String#<<", "type": "instance_method", "visibility": "public"}, "String#<=>": {"description": "Comparison — Returns -1, 0, +1, or +nil+ depending on whether +string+ is less than, equal to, or greater than +other_string+. \\n  \\n +nil+ is returned if the two values are incomparable. \\n  \\n If the strings are of different lengths, and the strings are equal when \\n compared up to the shortest length, then the longer string is considered greater than the shorter one. \\n  \\n <code><=></code> is the basis for the methods <code><</code>,\n<code><=</code>, <code>></code>, <code>>=</code>, and <code>between?</code>, included from module Comparable. The method String#== does not use Comparable#==. \\n \n   \"abcdef\" <=> \"abcde\"     #=> 1\n   \"abcdef\" <=> \"abcdef\"    #=> 0\n   \"abcdef\" <=> \"abcdefg\"   #=> -1\n   \"abcdef\" <=> \"ABCDEF\"    #=> 1\n   \"abcdef\" <=> 1           #=> nil", "name": "<=>", "namespace": "String", "path": "String#<=>", "type": "instance_method", "visibility": "public"}, "String#==": {"description": "Equality — Returns whether +str+ == +obj+, similar to Object#==. \\n  \\n If +obj+ is not an instance of String but responds to +to_str+, then the two strings are compared using <code>obj.==</code>. \\n  \\n Otherwise, returns similarly to String#eql?, comparing length and content.", "name": "==", "namespace": "String", "path": "String#==", "type": "instance_method", "visibility": "public"}, "String#===": {"description": "Equality — Returns whether +str+ == +obj+, similar to Object#==. \\n  \\n If +obj+ is not an instance of String but responds to +to_str+, then the two strings are compared using <code>obj.==</code>. \\n  \\n Otherwise, returns similarly to String#eql?, comparing length and content.", "name": "===", "namespace": "String", "path": "String#===", "type": "instance_method", "visibility": "public"}, "String#=~": {"description": "Match — If <i>obj</i> is a <code>Regexp</code>, use it as a pattern to match against <i>str</i>,and returns the position the match starts, or <code>nil</code> if there is no match. Otherwise, invokes \\n <i>obj.=~</i>, passing <i>str</i> as an argument. The default <code>=~</code> in <code>Object</code> returns <code>nil</code>. \\n  \\n Note: <code>str =~ regexp</code> is not the same as <code>regexp =~ str</code>. Strings captured from named capture groups are assigned to local variables only in the second case. \\n \n   \"cat o' 9 tails\" =~ /\\d/   #=> 7\n   \"cat o' 9 tails\" =~ 9      #=> nil", "name": "=~", "namespace": "String", "path": "String#=~", "type": "instance_method", "visibility": "public"}, "String#[]": {"description": "返回一个字符串的<code>Integer</code>序数。\\n n    \"a\".ord         #=> 97", "name": "[]", "namespace": "String", "path": "String#[]", "type": "instance_method", "visibility": "public"}, "String#[]=": {"description": "Element Assignment — Replaces some or all of the content of <i>str</i>. The portion of the string affected is determined using the same criteria as <code>String#[]</code>. If the replacement string is not the same length as the text it is replacing, the string will be adjusted accordingly. If the regular expression or string is used as the index doesn't match a position \\n in the string, <code>IndexError</code> is raised. If the regular expression \\n form is used, the optional second <code>Integer</code> allows you to specify which portion of the match to replace (effectively using the <code>MatchData</code> indexing rules. The forms that take an \\n <code>Integer</code> will raise an <code>IndexError</code> if the value is out of range; the <code>Range</code> form will raise a <code>RangeError</code>, and the <code>Regexp</code> and <code>String</code> \\n will raise an <code>IndexError</code> on negative match.", "name": "[]=", "namespace": "String", "path": "String#[]=", "type": "instance_method", "visibility": "public"}, "String#ascii_only?": {"description": "Returns true for a string which has only ASCII characters. \\n \n  \"abc\".force_encoding(\"UTF-8\").ascii_only?          #=> true\n  \"abc\\u{6666}\".force_encoding(\"UTF-8\").ascii_only?  #=> false", "name": "ascii_only?", "namespace": "String", "path": "String#ascii_only?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "String#b": {"description": "Returns a copied string whose encoding is ASCII-8BIT.", "name": "b", "namespace": "String", "path": "String#b", "type": "instance_method", "visibility": "public"}, "String#bytes": {"description": "Returns an array of bytes in <i>str</i>.  This is a shorthand for <code>str.each_byte.to_a</code>. \\n  \\n If a block is given, which is a deprecated form, works the same as <code>each_byte</code>.", "name": "bytes", "namespace": "String", "path": "String#bytes", "type": "instance_method", "visibility": "public"}, "String#bytesize": {"description": "Returns the length of +str+ in bytes. \\n \n  \"\\x80\\u3042\".bytesize  #=> 4\n  \"hello\".bytesize       #=> 5", "name": "bytesize", "namespace": "String", "path": "String#bytesize", "type": "instance_method", "visibility": "public"}, "String#byteslice": {"description": "Byte Reference — If passed a single <code>Integer</code>, returns a substring of one byte at that position. If passed two <code>Integer</code> \\n objects, returns a substring starting at the offset given by the first, and a length given by the second. If given a <code>Range</code>, a substring containing bytes at offsets given by the range is returned. In all three cases, if an offset is negative, it is counted from the end of <i>str</i>. Returns <code>nil</code> if the initial offset falls outside the string, the length is negative, or the beginning of the range is greater than the end. \\n The encoding of the resulted string keeps original encoding. \\n \n   \"hello\".byteslice(1)     #=> \"e\"\n   \"hello\".byteslice(-1)    #=> \"o\"\n   \"hello\".byteslice(1, 2)  #=> \"el\"\n   \"\\x80\\u3042\".byteslice(1, 3) #=> \"\\u3042\"\n   \"\\x03\\u3042\\xff\".byteslice(1..3) #=> \"\\u3042\"", "name": "byteslice", "namespace": "String", "path": "String#byteslice", "type": "instance_method", "visibility": "public"}, "String#capitalize": {"description": "Returns a copy of <i>str</i> with the first character converted to uppercase and the remainder to lowercase. \\n  \\n See String#downcase for meaning of +options+ and use with different encodings. \\n \n   \"hello\".capitalize    #=> \"Hello\"\n   \"HELLO\".capitalize    #=> \"Hello\"\n   \"123ABC\".capitalize   #=> \"123abc\"", "name": "capitalize", "namespace": "String", "path": "String#capitalize", "type": "instance_method", "visibility": "public"}, "String#capitalize!": {"description": "Modifies <i>str</i> by converting the first character to uppercase and the remainder to lowercase. Returns <code>nil</code> if no changes are made. \\n  \\n See String#downcase for meaning of +options+ and use with different encodings. \\n \n   a = \"hello\"\n   a.capitalize!   #=> \"Hello\"\n   a               #=> \"Hello\"\n   a.capitalize!   #=> nil", "name": "capitalize!", "namespace": "String", "path": "String#capitalize!", "type": "instance_method", "visibility": "public"}, "String#casecmp": {"description": "Case-insensitive version of <code>String#<=></code>. \\n Currently, case-insensitivity only works on characters A-Z/a-z, \\n not all of Unicode. This is different from String#casecmp?. \\n \n   \"aBcDeF\".casecmp(\"abcde\")     #=> 1\n   \"aBcDeF\".casecmp(\"abcdef\")    #=> 0\n   \"aBcDeF\".casecmp(\"abcdefg\")   #=> -1\n   \"abcdef\".casecmp(\"ABCDEF\")    #=> 0\n \\n +nil+ is returned if the two strings have incompatible encodings, \\n or if +other_str+ is not a string. \\n \n   \"foo\".casecmp(2)   #=> nil\n   \"\\u{e4 f6 fc}\".encode(\"ISO-8859-1\").casecmp(\"\\u{c4 d6 dc}\")   #=> nil", "name": "casecmp", "namespace": "String", "path": "String#casecmp", "type": "instance_method", "visibility": "public"}, "String#casecmp?": {"description": "Returns +true+ if +str+ and +other_str+ are equal after Unicode case folding, +false+ if they are not equal. \\n \n   \"aBcDeF\".casecmp?(\"abcde\")     #=> false\n   \"aBcDeF\".casecmp?(\"abcdef\")    #=> true\n   \"aBcDeF\".casecmp?(\"abcdefg\")   #=> false\n   \"abcdef\".casecmp?(\"ABCDEF\")    #=> true\n   \"\\u{e4 f6 fc}\".casecmp?(\"\\u{c4 d6 dc}\")   #=> true\n \\n +nil+ is returned if the two strings have incompatible encodings, \\n or if +other_str+ is not a string. \\n \n   \"foo\".casecmp?(2)   #=> nil\n   \"\\u{e4 f6 fc}\".encode(\"ISO-8859-1\").casecmp?(\"\\u{c4 d6 dc}\")   #=> nil", "name": "casecmp?", "namespace": "String", "path": "String#casecmp?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "String#center": {"description": "Centers +str+ in +width+.  If +width+ is greater than the length of +str+, \\n returns a new String of length +width+ with +str+ centered and padded with \\n +padstr+; otherwise, returns +str+. \\n \n   \"hello\".center(4)         #=> \"hello\"\n   \"hello\".center(20)        #=> \"       hello        \"\n   \"hello\".center(20, '123') #=> \"1231231hello12312312\"", "name": "center", "namespace": "String", "path": "String#center", "type": "instance_method", "visibility": "public"}, "String#chars": {"description": "Returns an array of characters in <i>str</i>.  This is a shorthand for <code>str.each_char.to_a</code>. \\n  \\n If a block is given, which is a deprecated form, works the same as <code>each_char</code>.", "name": "chars", "namespace": "String", "path": "String#chars", "type": "instance_method", "visibility": "public"}, "String#chomp": {"description": "Returns a new <code>String</code> with the given record separator removed from the end of <i>str</i> (if present). If <code>$/</code> has not been \\n changed from the default Ruby record separator, then <code>chomp</code> also removes carriage return characters (that is it will remove <code>\\n</code>, \\n <code>\\r</code>, and <code>\\r\\n</code>). If <code>$/</code> is an empty string, \\n it will remove all trailing newlines from the string. \\n \n   \"hello\".chomp                #=> \"hello\"\n   \"hello\\n\".chomp              #=> \"hello\"\n   \"hello\\r\\n\".chomp            #=> \"hello\"\n   \"hello\\n\\r\".chomp            #=> \"hello\\n\"\n   \"hello\\r\".chomp              #=> \"hello\"\n   \"hello \\n there\".chomp       #=> \"hello \\n there\"\n   \"hello\".chomp(\"llo\")         #=> \"he\"\n   \"hello\\r\\n\\r\\n\".chomp('')    #=> \"hello\"\n   \"hello\\r\\n\\r\\r\\n\".chomp('')  #=> \"hello\\r\\n\\r\"", "name": "chomp", "namespace": "String", "path": "String#chomp", "type": "instance_method", "visibility": "public"}, "String#chomp!": {"description": "Modifies <i>str</i> in place as described for <code>String#chomp</code>, \\n returning <i>str</i>, or <code>nil</code> if no modifications were made.", "name": "chomp!", "namespace": "String", "path": "String#chomp!", "type": "instance_method", "visibility": "public"}, "String#chop": {"description": "调用给定的块，每个调用的数字序列从+num+开始，递增+step+（默认为+1+）。\\n \\n当要传递给块的值大于\\n +limit+（如果+step+为正）或小于+limit+（如果+step+为负）时，循环结束，其中+limit+默认为无穷大。\\n \\n在建议的关键字参数样式中，可以省略+step+和+limit+（默认无穷大）中的一个或两个。在固定位置参数样式中，由于历史兼容性原因，不允许将零作为步骤\\n（即<code>num.step(limit, 0)</code>）。\\n \\n如果所有参数都是整数，则循环使用整数计数器进行操作。\\n \\n如果任何参数是浮点数，则所有参数都转换为浮点数，并执行循环\\n<i>floor（n+n*float:：EPSILON）+1</i>times，\\n where<i>n=（limit-num）/step</i>。\\n \\n否则，循环从+num+开始，使用小于（<code><</code>) or greater-than (<code>></code>）运算符将计数器与+limit+进行比较，并使用<code>+</code>运算符递增自身。\\n \\n如果没有给定块，则返回枚举器。\\n \\n例如：\\n \n   p 1.step.take(4)\n   p 10.step(by: -1).take(4)\n   3.step(to: 5) {|i| print i, \" \" }\n   1.step(10, 2) {|i| print i, \" \" }\n   Math::E.step(to: Math::PI, by: 0.2) {|f| print f, \" \" }\n \\n将生成：\\n \n   [1, 2, 3, 4]\n   [10, 9, 8, 7]\n   3 4 5\n   1 3 5 7 9\n 2.718281828459045 2.9182818284590453 3.118281828459045", "name": "chop", "namespace": "String", "path": "String#chop", "type": "instance_method", "visibility": "public"}, "String#chop!": {"description": "以复数形式返回值。", "name": "chop!", "namespace": "String", "path": "String#chop!", "type": "instance_method", "visibility": "public"}, "String#chr": {"description": "调用子类的+to_i+方法将+num+转换为整数。n \n    1.0.class          #=> Float\n    1.0.to_int.class   #=> Integer\n    1.0.to_i.class     #=> Integer", "name": "chr", "namespace": "String", "path": "String#chr", "type": "instance_method", "visibility": "public"}, "String#clear": {"description": "返回+num+截断（朝零）到+ndigits+十进制数字的精度（默认值：0）。\\n \\n numeric通过将其值转换为float并调用float truncate来实现此功能。", "name": "clear", "namespace": "String", "path": "String#clear", "type": "instance_method", "visibility": "public"}, "String#codepoints": {"description": "如果+num+的值为零，则返回+true+。", "name": "codepoints", "namespace": "String", "path": "String#codepoints", "type": "instance_method", "visibility": "public"}, "String#concat": {"description": "<code>String</code>对象保存和操作任意字节序列，通常表示字符。可以使用<code>String::new</code>或作为文本创建字符串对象。\\n \\n由于别名问题，字符串用户应该知道修改<code>String</code>对象内容的方法。通常，名称以“`！”结尾的方法修改他们的接收者，而那些没有```的返回新的<code>String</code>。但是，也有例外情况，如<code>String#[]=</code>。", "name": "concat", "namespace": "String", "path": "String#concat", "type": "instance_method", "visibility": "public"}, "String#count": {"description": "FORMAT-将<i>str用作格式规范，并返回将其应用于<i>arg的结果。如果格式规范包含一个以上的替换，则包含要替换的值的<i>arg</i>必须是<code>Array</code>或<code>Hash</code>。有关格式字符串的详细信息，请参阅<code>Kernel::sprintf</code>。n \n   \"%05d\" % 123                              #=> \"00123\"\n   \"%-5s: %08x\" % [ \"ID\", self.object_id ]   #=> \"ID   : 200e14d6\"\n   \"foo = %{foo}\" % { :foo => 'bar' }        #=> \"foo = bar\"", "name": "count", "namespace": "String", "path": "String#count", "type": "instance_method", "visibility": "public"}, "String#crypt": {"description": "copy-返回包含+integer+个收件人副本的新字符串。\\n +integer+必须大于或等于0。n \n   \"Ho! \" * 3   #=> \"Ho! Ho! Ho! \"\n   \"Ho! \" * 0   #=> \"\"", "name": "crypt", "namespace": "String", "path": "String#crypt", "type": "instance_method", "visibility": "public"}, "String#delete": {"description": "concatenation-返回一个新的<code>String</code>，其中包含\\n<i>other_str</i>concatenated to<i>str</i>。\\n n    \"Hello from \" + self.to_s   #=> \"Hello from main\"", "name": "delete", "namespace": "String", "path": "String#delete", "type": "instance_method", "visibility": "public"}, "String#delete!": {"description": "如果字符串被冻结，则返回重复的可变字符串。\\n \\n如果字符串未冻结，则返回字符串本身。", "name": "delete!", "namespace": "String", "path": "String#delete!", "type": "instance_method", "visibility": "public"}, "String#delete_prefix": {"description": "如果字符串被冻结，则返回字符串本身。\\n \\n如果字符串未被冻结，则返回该字符串的已冻结（可能是已存在的）副本。", "name": "delete_prefix", "namespace": "String", "path": "String#delete_prefix", "type": "instance_method", "visibility": "public"}, "String#delete_prefix!": {"description": "将给定的对象附加到<i>str<i>。如果对象是\\n <code>Integer</code>，则将其视为代码点，并在附加之前转换为字符。\\n \n   a = \"hello \"\n   a << \"world\"   #=> \"hello world\"\n   a << 33        #=> \"hello world!\"\n \\n另请参阅字符串concat，它接受多个参数。", "name": "delete_prefix!", "namespace": "String", "path": "String#delete_prefix!", "type": "instance_method", "visibility": "public"}, "String#delete_suffix": {"description": "比较-返回-1、0、+1或+nil+，具体取决于+string+是小于、等于还是大于+other_string+。\\n \\n如果这两个值不可比较，则返回+nil+。\\n \\n如果字符串的长度不同，并且字符串与最短长度相比是相等的，则认为较长的字符串大于较短的字符串。\\n \\n <code><=></code>是方法<code><</code>,\n<code><=</code>、<code>></code>、<code>>=</code>和<code>between?</code>的基础，这些方法包含在可比模块中。方法字符串==不使用Comparable==。n \n   \"abcdef\" <=> \"abcde\"     #=> 1\n   \"abcdef\" <=> \"abcdef\"    #=> 0\n   \"abcdef\" <=> \"abcdefg\"   #=> -1\n   \"abcdef\" <=> \"ABCDEF\"    #=> 1\n   \"abcdef\" <=> 1           #=> nil", "name": "delete_suffix", "namespace": "String", "path": "String#delete_suffix", "type": "instance_method", "visibility": "public"}, "String#delete_suffix!": {"description": "equality-返回是否+str+==+obj+，类似于对象==。\\n \\n如果+obj+不是字符串的实例，但响应+to_str+，则使用<code>obj.==</code>比较这两个字符串。\\n \\n否则，返回类似于string eql的值？，比较长度和内容。", "name": "delete_suffix!", "namespace": "String", "path": "String#delete_suffix!", "type": "instance_method", "visibility": "public"}, "String#downcase": {"description": "equality-返回是否+str+==+obj+，类似于object==。\\n \\n如果+obj+不是字符串的实例，但响应+to_str+，则使用<code>obj.==</code>比较这两个字符串。\\n \\n否则，返回类似于string eql的值？，比较长度和内容。", "name": "downcase", "namespace": "String", "path": "String#downcase", "type": "instance_method", "visibility": "public"}, "String#downcase!": {"description": "match-如果<i>obj<i>is a <code>Regexp</code>，则将其用作与<i>str<i>匹配的模式，并返回匹配开始的位置，如果没有匹配则返回<code>nil</code>。否则，调用\\n<i>obj.=~-<i>，passing<i>str.->i>as an argument.<code>Object</code>中的默认<code>=~</code>返回<code>nil</code>。\\n \\n注意：<code>str =~ regexp</code>与<code>regexp =~ str</code>不同。从命名捕获组捕获的字符串仅在第二种情况下分配给局部变量。n \n   \"cat o' 9 tails\" =~ /\\d/   #=> 7\n   \"cat o' 9 tails\" =~ 9      #=> nil", "name": "downcase!", "namespace": "String", "path": "String#downcase!", "type": "instance_method", "visibility": "public"}, "String#dump": {"description": "返回删除最后一个字符的新<code>String</code>。如果字符串以<code>\\r\\n</code>结尾，则删除这两个字符。将<code>chop</code>应用于空字符串将返回空字符串。<code>String#chomp</code>通常是一个更安全的选择，因为如果字符串不以记录分隔符结尾，它将保持字符串不变。n \n   \"string\\r\\n\".chop   #=> \"string\"\n   \"string\\n\\r\".chop   #=> \"string\\n\"\n   \"string\\n\".chop     #=> \"string\"\n   \"string\".chop       #=> \"strin\"\n   \"x\".chop.chop       #=> \"\"", "name": "dump", "namespace": "String", "path": "String#dump", "type": "instance_method", "visibility": "public"}, "String#each_byte": {"description": "processes<i>str<i>as for <code>String#chop</code>，returning<i>str<i>，\\n or <code>nil</code> if<i>str<i>is the empty string.另见<code>String#chomp!</code>。", "name": "each_byte", "namespace": "String", "path": "String#each_byte", "type": "instance_method", "visibility": "public"}, "String#each_char": {"description": "返回字符串开头的一个字符串。n \n   a = \"abcde\"\n   a.chr    #=> \"a\"", "name": "each_char", "namespace": "String", "path": "String#each_char", "type": "instance_method", "visibility": "public"}, "String#each_codepoint": {"description": "使字符串为空。n \n   a = \"abcde\"\n   a.clear    #=> \"\"", "name": "each_codepoint", "namespace": "String", "path": "String#each_codepoint", "type": "instance_method", "visibility": "public"}, "String#each_grapheme_cluster": {"description": "返回<i>str中字符顺序为<code>Integer</code>的数组。这是<code>str.each_codepoint.to_a</code>的简写。\\n \\n如果给定的块（已弃用的形式）的工作方式与<code>each_codepoint</code>相同。", "name": "each_grapheme_cluster", "namespace": "String", "path": "String#each_grapheme_cluster", "type": "instance_method", "visibility": "public"}, "String#each_line": {"description": "将给定的对象连接到<i>str。如果一个对象是一个\\n <code>Integer</code>，它将被视为一个代码点，并在连接之前转换为一个字符。\\n \\n +concat+可以接受多个参数，并且所有参数都按顺序连接。\\n \n   a = \"hello \"\n   a.concat(\"world\", 33)      #=> \"hello world!\"\n   a                          #=> \"hello world!\"\n100219 \\n另请参阅字符串<，它采用单个参数。", "name": "each_line", "namespace": "String", "path": "String#each_line", "type": "instance_method", "visibility": "public"}, "String#empty?": {"description": "每个+other_str+参数定义一组要计数的字符。这些集合的交集定义了要在+str+中计数的字符。以插入符号<code>^</code>开头的任何+other_str+都将被否定。序列<code>c1-c2</code>表示c1和c2之间的所有字符。反斜杠字符<code>\\\\</code>可用于转义<code>^</code>或<code>-</code>，否则将被忽略，除非它出现在序列末尾或+other_str+的末尾。n \n   a = \"hello world\"\n   a.count \"lo\"                   #=> 5\n   a.count \"lo\", \"o\"              #=> 2\n   a.count \"hello\", \"^l\"          #=> 4\n   a.count \"ej-m\"                 #=> 4\n\n   \"hello^world\".count \"\\\\^aeiou\" #=> 4\n   \"hello-world\".count \"a\\\\-eo\"   #=> 4\n\n   c = \"hello world\\\\r\\\\n\"\n   c.count \"\\\\\"                   #=> 2\n   c.count \"\\\\A\"                  #=> 0\n   c.count \"X-\\\\w\"                #=> 3", "name": "empty?", "namespace": "String", "path": "String#empty?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "String#encode": {"description": "通过使用给定的salt字符串调用标准库函数<code>crypt(3)</code>，将单向加密哈希应用到<i>str.<i>虽然格式和结果取决于系统和实现，但是使用与正则表达式<code>\\A[a-zA-Z0-9./]{2}</code>匹配的salt在任何平台上都应该是有效和安全的，其中只有前两个字符是显著的。\\n \\n此方法用于特定于系统的脚本，因此，如果要使用跨平台哈希函数，请考虑改用Digest或OpenSSL。", "name": "encode", "namespace": "String", "path": "String#encode", "type": "instance_method", "visibility": "public"}, "String#encode!": {"description": "返回一个<i>str<i>的副本，删除其参数交叉点中的所有字符。使用与<code>String#count</code>相同的规则来构建字符集。n \n   \"hello\".delete \"l\",\"lo\"        #=> \"heo\"\n   \"hello\".delete \"lo\"            #=> \"he\"\n   \"hello\".delete \"aeiou\", \"^e\"   #=> \"hell\"\n   \"hello\".delete \"ej-m\"          #=> \"ho\"", "name": "encode!", "namespace": "String", "path": "String#encode!", "type": "instance_method", "visibility": "public"}, "String#encoding": {"description": "以字符串数组形式返回捕获的名称列表。\\n它与mtch.regexp.names相同。n \n    /(?<foo>.)(?<bar>.)(?<baz>.)/.match(\"hoge\").names\n    #=> [\"foo\", \"bar\", \"baz\"]\n\n    m = /(?<x>.)(?<y>.)?/.match(\"a\") #=> #<MatchData \"a\" x:\"a\" y:nil>\n    m.names                          #=> [\"x\", \"y\"]", "name": "encoding", "namespace": "String", "path": "String#encoding", "type": "instance_method", "visibility": "public"}, "String#end_with?": {"description": "返回一个删除了前导字符<code>prefix</code>的<i>str<i>n \n   \"hello\".delete_prefix(\"hel\") #=> \"lo\"\n   \"hello\".delete_prefix(\"llo\") #=> \"hello\"", "name": "end_with?", "namespace": "String", "path": "String#end_with?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "String#eql?": {"description": "从<i>str<i>中删除前导的<code>prefix</code>，如果未做任何更改，则返回<code>nil</code>。n \n   \"hello\".delete_prefix!(\"hel\") #=> \"lo\"\n   \"hello\".delete_prefix!(\"llo\") #=> nil", "name": "eql?", "namespace": "String", "path": "String#eql?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "String#force_encoding": {"description": "返回一个删除了<code>suffix</code>后的<i>str.<i>n \n   \"hello\".delete_suffix(\"llo\") #=> \"he\"\n   \"hello\".delete_suffix(\"hel\") #=> \"hello\"", "name": "force_encoding", "namespace": "String", "path": "String#force_encoding", "type": "instance_method", "visibility": "public"}, "String#freeze": {"description": "", "name": "freeze", "namespace": "String", "path": "String#freeze", "type": "instance_method", "visibility": "public"}, "String#getbyte": {"description": "将后面的<code>suffix</code>从<i>str<i>中删除，如果未做任何更改，则返回<code>nil</code>。n \n   \"hello\".delete_suffix!(\"llo\") #=> \"he\"\n   \"hello\".delete_suffix!(\"hel\") #=> nil", "name": "getbyte", "namespace": "String", "path": "String#getbyte", "type": "instance_method", "visibility": "public"}, "String#grapheme_clusters": {"description": "返回<i>str的副本，将所有大写字母替换为小写字母。哪些字母被替换，哪些字母被替换，取决于选项的存在或不存在，以及字符串的+encoding+。\\n \\n +options+的含义如下：\\n \\n no option:：\n  Full Unicode case mapping, suitable for most languages\n  (see :turkic and :lithuanian options below for exceptions).\n  Context-dependent case mapping as described in Table 3-14 of the\n  Unicode standard is currently not supported.\n:ascii:：\n  Only the ASCII region, i.e. the characters ``A'' to ``Z'' and\n  ``a'' to ``z'', are affected.\n  This option cannot be combined with any other option.\n:turkic:：\n  Full Unicode case mapping, adapted for Turkic languages\n  (Turkish, Aserbaijani,...). This means that upper case I is mapped to\n  lower case dotless i, and so on.\n:lithuanian:：\n  Currently, just full Unicode case mapping. In the future, full Unicode\n  case mapping adapted for Lithuanian (keeping the dot on the lower case\n  i even if there is an accent on top).\n:fold:：\n  Only available on +downcase+ and +downcase!+. Unicode case <b>folding</b>,\n  which is more far-reaching than Unicode case mapping.\n  This option currently cannot be combined with any other option\n  (i.e. there is currenty no variant for turkic languages).\n \\n请注意，对于ASCII仅案例转换有效的几个假设不适用于更一般的案例转换。例如，结果的长度可能与输入的长度不同（既不以字符也不以字节为单位），一些往返假设可能不适用（例如，str.downcase==str.upcase.downcase），并且Unicode规范化（即，字符串Unicode 35u规范化）不一定由事例映射操作维护。\\n \\n utf-8、\\n utf-16be/le、utf-32be/le和iso-8859-1~16个字符串/符号目前支持非ASCII大小写映射/折叠。\\n此支持将扩展到其他编码。\\n n    \"hEllO\".downcase   #=> \"hello\"", "name": "grapheme_clusters", "namespace": "String", "path": "String#grapheme_clusters", "type": "instance_method", "visibility": "public"}, "String#gsub": {"description": "downcases the contents of<i>str.<i>，returning <code>nil</code> if no changes were made.\\n \\n有关+options+的含义，请参阅字符串小写，并与不同的编码一起使用。", "name": "gsub", "namespace": "String", "path": "String#gsub", "type": "instance_method", "visibility": "public"}, "String#gsub!": {"description": "生成一个+str+版本，所有非打印字符替换为<code>\\nnn</code>符号，所有特殊字符转义。\\n n   \"hello \\n ''\".dump  #=> \"\\\"hello \\\\n ''\\\"\"", "name": "gsub!", "namespace": "String", "path": "String#gsub!", "type": "instance_method", "visibility": "public"}, "String#hash": {"description": "将<i>str中的每个字节传递给给定的块，或者如果没有给定块，则返回\\n枚举器。\\n \n   \"hello\".each_byte {|c| print c, ' ' }\n \\n<em>products:->em>\\n \\n 104 101 108 108 111", "name": "hash", "namespace": "String", "path": "String#hash", "type": "instance_method", "visibility": "public"}, "String#hex": {"description": "将<i>str<i>中的每个字符传递给给定的块，或者如果没有给定块，则返回枚举器。\\n \n   \"hello\".each_char {|c| print c, ' ' }\n \\n<em>产生：.<em>\\n \\n h e l l o", "name": "hex", "namespace": "String", "path": "String#hex", "type": "instance_method", "visibility": "public"}, "String#include?": {"description": "当应用到给定块的unicode字符串时，传递<i>str、\\n中每个字符的<code>Integer</code>序数。对于除utf-8/utf-16（be le）/utf-32（be le）以外的编码，值直接从每个字符的二进制表示形式派生。\\n \\n如果没有给定块，则返回枚举器。\\n \n   \"hello\\u0639\".each_codepoint {|c| print c, ' ' }\n \\n<em>products:->em>\\n \\n 104 101 108 111 1593", "name": "include?", "namespace": "String", "path": "String#include?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "String#index": {"description": "将<i>str<i>中的每个图形簇传递给给定的块，或者如果没有给定块，则返回枚举器。\\n与字符串每个字符不同，它通过Unicode标准附件29 http://unicode.org/reports/tr29/\\n \n   \"a\\u0300\".each_char.to_a.size #=> 2\n   \"a\\u0300\".each_grapheme_cluster.to_a.size #=> 1定义的图形簇进行枚举。", "name": "index", "namespace": "String", "path": "String#index", "type": "instance_method", "visibility": "public"}, "String#initialize": {"description": "使用提供的参数作为记录分隔符（默认为<code>$/</code>），依次将每个子字符串传递到提供的块。如果提供了零长度的记录分隔符，则将字符串拆分为由多个连续换行符分隔的段落。\\n \\n有关getline_args的详细信息，请参阅IO.readlines。\\n \\n如果没有给定块，则返回枚举器。\\n \n   print \"Example one\\n\"\n   \"hello\\nworld\".each_line {|s| p s}\n   print \"Example two\\n\"\n   \"hello\\nworld\".each_line('l') {|s| p s}\n   print \"Example three\\n\"\n   \"hello\\n\\n\\nworld\".each_line('') {|s| p s}\n \\n<em>产生：.<em>\\n \n   Example one\n   \"hello\\n\"\n   \"world\"\n   Example two\n   \"hel\"\n   \"l\"\n   \"o\\nworl\"\n   \"d\"\n   Example three\n   \"hello\\n\\n\"\n“world”", "name": "initialize", "namespace": "String", "path": "String#initialize", "type": "instance_method", "visibility": "public"}, "String#initialize_copy": {"description": "在给定的索引处的字符之前插入“Other”（其他）str，modifying（修改）str。负索引从字符串末尾开始计数，然后在给定字符之后插入<em>\\n其目的是插入<i>astring，以便它从给定的索引开始。n \n   \"abcd\".insert(0, 'X')    #=> \"Xabcd\"\n   \"abcd\".insert(3, 'X')    #=> \"abcXd\"\n   \"abcd\".insert(4, 'X')    #=> \"abcdX\"\n   \"abcd\".insert(-3, 'X')   #=> \"abXcd\"\n   \"abcd\".insert(-1, 'X')   #=> \"abcdX\"", "name": "initialize_copy", "namespace": "String", "path": "String#initialize_copy", "type": "instance_method", "visibility": "public"}, "String#insert": {"description": "第一个表单返回+str+的副本，该副本被转码为编码+encoding+。\\n第二个表单返回从src_encoding到dst_encoding转码的+str+的副本。\\n最后一个表单返回+str+的副本，该副本被转码到\\n<tt>encoding.default_internal->\\n \\n默认情况下，第一个和第二个表单对目标编码中未定义的字符引发encoding:：UndefinedConversionError，对源编码中的无效字节序列引发encoding:：InvalidByteSequenceError。默认情况下，最后一个窗体不引发异常，而是使用替换字符串。\\n \\n +options+哈希提供转换的详细信息，如果值为true，则可以具有以下键：\\n \\n :invalid:：\n   \"hello\".gsub(/[aeiou]/, '*')                  #=> \"h*ll*\"\n   \"hello\".gsub(/([aeiou])/, '<\\1>')             #=> \"h<e>ll<o>\"\n   \"hello\".gsub(/./) {|s| s.ord.to_s + ' '}      #=> \"104 101 108 108 111 \"\n   \"hello\".gsub(/(?<foo>[aeiou])/, '{\\k<foo>}')  #=> \"h{e}ll{o}\"\n8:undef:：\n  If the value is +:replace+, #encode replaces characters which are\n  undefined in the destination encoding with the replacement character.\n  The default is to raise the Encoding::UndefinedConversionError.\n:replace:：\n  Sets the replacement string to the given value. The default replacement\n  string is \"\\uFFFD\" for Unicode encoding forms, and \"?\" otherwise.\n:fallback:：\n   \"hello\".gsub(/[aeiou]/, '*')                  #=> \"h*ll*\"\n   \"hello\".gsub(/([aeiou])/, '<\\1>')             #=> \"h<e>ll<o>\"\n   \"hello\".gsub(/./) {|s| s.ord.to_s + ' '}      #=> \"104 101 108 108 111 \"\n   \"hello\".gsub(/(?<foo>[aeiou])/, '{\\k<foo>}')  #=> \"h{e}ll{o}\"\n   'hello'.gsub(/[eo]/, 'e' => 3, 'o' => '*')    #=> \"h3ll*\"1:xml:：\n   \"hello\".gsub(/[aeiou]/, '*')                  #=> \"h*ll*\"\n   \"hello\".gsub(/([aeiou])/, '<\\1>')             #=> \"h<e>ll<o>\"\n   \"hello\".gsub(/./) {|s| s.ord.to_s + ' '}      #=> \"104 101 108 108 111 \"\n   \"hello\".gsub(/(?<foo>[aeiou])/, '{\\k<foo>}')  #=> \"h{e}ll{o}\"\n   'hello'.gsub(/[eo]/, 'e' => 3, 'o' => '*')    #=> \"h3ll*\"2:cr_newline:：\n  Replaces LF (\"\\n\") with CR (\"\\r\") if value is true.\n:cr lf_newline:：\n  Replaces LF (\"\\n\") with CRLF (\"\\r\\n\") if value is true.\n:universal_newline:：\\n将CRLF（“\\r\\n”）和cr（“\\r”）替换为lf（“\\n”）。", "name": "insert", "namespace": "String", "path": "String#insert", "type": "instance_method", "visibility": "public"}, "String#inspect": {"description": "第一个表单将<i>str的内容从str.encoding转换为+encoding+。\\n第二个表单将<i>str.<i>的内容从src_encoding转换为dst_encoding。\\n选项哈希提供转换的详细信息。有关详细信息，请参见字符串编码。\\n即使未做任何更改，也返回字符串。", "name": "inspect", "namespace": "String", "path": "String#inspect", "type": "instance_method", "visibility": "public"}, "String#intern": {"description": "如果+str+以给定的+prefixes+之一开头，则返回true。n \n  \"hello\".start_with?(\"hell\")               #=> true\n\n  # returns true if one of the prefixes matches.\n  \"hello\".start_with?(\"heaven\", \"hell\")     #=> true\n  \"hello\".start_with?(\"heaven\", \"paradise\") #=> false", "name": "intern", "namespace": "String", "path": "String#intern", "type": "instance_method", "visibility": "public"}, "String#length": {"description": "将<i>str<i>的前导字符视为一个八进制数字串（带有\\n可选符号），并返回相应的数字。如果转换失败，则返回0。\\n \n   \"123\".oct       #=> 83\n   \"-377\".oct      #=> -255\n   \"bad\".oct       #=> 0\n   \"0377bad\".oct   #=> 255\n \\n如果+str+以<code>0</code>开头，则基数指示符将被接受。\\n请参阅内核整数。", "name": "length", "namespace": "String", "path": "String#length", "type": "instance_method", "visibility": "public"}, "String#lines": {"description": "如果两个字符串的长度和内容相同，则它们是相等的。", "name": "lines", "namespace": "String", "path": "String#lines", "type": "instance_method", "visibility": "public"}, "String#ljust": {"description": "将编码更改为+encoding+并返回self。", "name": "ljust", "namespace": "String", "path": "String#ljust", "type": "instance_method", "visibility": "public"}, "String#lstrip": {"description": "以整数形式返回<i>index=>th byte。", "name": "lstrip", "namespace": "String", "path": "String#lstrip", "type": "instance_method", "visibility": "public"}, "String#lstrip!": {"description": "返回<i>str>中的图形簇数组。这是<code>str.each_grapheme_cluster.to_a</code>的简写。\\n \\n如果给定的块（已弃用的形式）的工作方式与<code>each_grapheme_cluster</code>相同。", "name": "lstrip!", "namespace": "String", "path": "String#lstrip!", "type": "instance_method", "visibility": "public"}, "String#match": {"description": "返回<i>str<i>with<em>all<em>occurrences of\\n<i>pattern<i>substituted for the second argument的副本。<i>模式通常为<code>Regexp</code>；如果给定为<code>String</code>，则它包含的任何正则表达式元字符都将逐字解释，例如，<code>'\\\\\\d'</code>将匹配反斜杠，后跟“d”，\\n而不是数字。\\n \\n如果<i>replacement<i>is a <code>String</code> it will be substituted for the matched text.它可能包含对模式的捕获组的后面引用，格式为<code>\\\\\\d</code>，其中<i>d<i>i s a group number，or <code>\\\\\\k<n></code>，其中<i>n<i>i s a group name.如果是双引号字符串，则两个后引用前面都必须有一个\\n附加反斜杠。但是，在<i>replacement<i>the special match variables，例如<code>$&</code>，will not refer to the current match.\\n \\n如果第二个参数是<code>Hash</code>，并且匹配的文本是其键之一，则对应的值是替换字符串。\\n \\n在区块形式中，目前的比对字串会作为参数传入，并会适当设定<code>$1</code>、<code>$2</code>、<code>$`</code>、<code>$&</code>和<code>$'</code>等变数。块返回的值将在每次调用时替换匹配项。\\n \\n结果继承原始字符串或提供的任何替换字符串中的任何污点。\\n \\n如果既不提供块也不提供第二个参数，则返回\\n <code>Enumerator</code>。n \n   \"hello\".gsub(/[aeiou]/, '*')                  #=> \"h*ll*\"\n   \"hello\".gsub(/([aeiou])/, '<\\1>')             #=> \"h<e>ll<o>\"\n   \"hello\".gsub(/./) {|s| s.ord.to_s + ' '}      #=> \"104 101 108 108 111 \"\n   \"hello\".gsub(/(?<foo>[aeiou])/, '{\\k<foo>}')  #=> \"h{e}ll{o}\"\n   'hello'.gsub(/[eo]/, 'e' => 3, 'o' => '*')    #=> \"h3ll*\"", "name": "match", "namespace": "String", "path": "String#match", "type": "instance_method", "visibility": "public"}, "String#match?": {"description": "就地执行<code>String#gsub</code>的替换，如果没有执行任何替换，则返回\\n<i>str<i>或<code>nil</code>。\\n如果没有给出块和no<i>replacement，则返回枚举器。", "name": "match?", "namespace": "String", "path": "String#match?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "String#next": {"description": "从<i>str<i>中删除尾随空格，如果未做任何更改，则返回<code>nil</code>。另见<code>String#lstrip!</code>和<code>String#strip!</code>。\\n \\n有关空白的定义，请参阅<code>strip</code>。n \n   \"  hello  \".rstrip!  #=> \"  hello\"\n   \"  hello\".rstrip!    #=> nil\n   \"hello\".rstrip!      #=> nil", "name": "next", "namespace": "String", "path": "String#next", "type": "instance_method", "visibility": "public"}, "String#next!": {"description": "两个表单都迭代通过<i>str<i>，匹配模式（可能是<code>Regexp</code>或<code>String</code>）。对于每个匹配，将生成一个结果，并将其添加到结果数组或传递到块。如果模式不包含组，则每个单独的结果都由匹配的字符串<code>$&</code>组成。如果模式包含组，则每个单独的结果本身就是一个数组，每个组包含一个条目。\\n \n   a = \"cruel world\"\n   a.scan(/\\w+/)        #=> [\"cruel\", \"world\"]\n   a.scan(/.../)        #=> [\"cru\", \"el \", \"wor\"]\n   a.scan(/(...)/)      #=> [[\"cru\"], [\"el \"], [\"wor\"]]\n   a.scan(/(..)(..)/)   #=> [[\"cr\", \"ue\"], [\"l \", \"wo\"]]\n \\n和块形式：\\n \n   a.scan(/\\w+/) {|w| print \"<<#{w}>> \" }\n   print \"\\n\"\n   a.scan(/(.)(.)/) {|x,y| print y, x }\n   print \"\\n\"\n \\n<em>products:-\\n \n   <<cruel>> <<world>>\n rceu lowlr", "name": "next!", "namespace": "String", "path": "String#next!", "type": "instance_method", "visibility": "public"}, "String#oct": {"description": "如果包含给定的字符串或字符，则返回<code>true</code>。n \n   \"hello\".include? \"lo\"   #=> true\n   \"hello\".include? \"ol\"   #=> false\n   \"hello\".include? ?h     #=> true", "name": "oct", "namespace": "String", "path": "String#oct", "type": "instance_method", "visibility": "public"}, "String#ord": {"description": "返回给定<i>子字符串的第一个匹配项的索引，或返回<i>str中的模式（<i>regexp<i>）。如果找不到，则返回<code>nil</code>。如果存在第二个参数，则指定字符串中开始搜索的位置。n \n   \"hello\".index('e')             #=> 1\n   \"hello\".index('lo')            #=> 3\n   \"hello\".index('a')             #=> nil\n   \"hello\".index(?e)              #=> 1\n   \"hello\".index(/[aeiou]/, -3)   #=> 4", "name": "ord", "namespace": "String", "path": "String#ord", "type": "instance_method", "visibility": "public"}, "String#partition": {"description": "返回一个新的字符串对象，该对象包含<i>str的副本。\\n \\n可选的<i>encoding</i>keyword参数指定新字符串的编码。\\n如果未指定，则使用<i>str.>i>的编码\\n（或ASCII-8bit，if<i>str.>i>is not specified）。\\n \\n可选的<i>capacity->i>keyword参数指定内部缓冲区的大小。\\n当字符串将被连接多次（导致多次realloc调用）时，这可能会提高性能。", "name": "partition", "namespace": "String", "path": "String#partition", "type": "instance_method", "visibility": "public"}, "String#prepend": {"description": "将<i>str的内容和污点替换为<i>other_str中的相应值。n \n   s = \"hello\"         #=> \"hello\"\n   s.replace \"world\"   #=> \"world\"", "name": "prepend", "namespace": "String", "path": "String#prepend", "type": "instance_method", "visibility": "public"}, "String#replace": {"description": "在给定的索引处的字符之前插入“Other”（其他）str，modifying（修改）str。负索引从字符串末尾开始计数，然后在给定字符之后插入<em>\\n其目的是插入<i>astring，以便它从给定的索引开始。n \n   \"abcd\".insert(0, 'X')    #=> \"Xabcd\"\n   \"abcd\".insert(3, 'X')    #=> \"abcXd\"\n   \"abcd\".insert(4, 'X')    #=> \"abcdX\"\n   \"abcd\".insert(-3, 'X')   #=> \"abXcd\"\n   \"abcd\".insert(-1, 'X')   #=> \"abcdX\"", "name": "replace", "namespace": "String", "path": "String#replace", "type": "instance_method", "visibility": "public"}, "String#reverse": {"description": "返回_str_u的可打印版本，由引号包围，并转义特殊字符。n \n   str = \"hello\"\n   str[3] = \"\\b\"\n   str.inspect       #=> \"\\\"hel\\\\bo\\\"\"", "name": "reverse", "namespace": "String", "path": "String#reverse", "type": "instance_method", "visibility": "public"}, "String#reverse!": {"description": "返回对应于<i>str<i>的<code>Symbol</code>，如果该符号以前不存在，则创建该符号。见<code>Symbol#id2name</code>。\\n \n   \"Koala\".intern         #=> :Koala\n   s = 'cat'.to_sym       #=> :cat\n   s == :cat              #=> true\n   s = '@cat'.to_sym      #=> :@cat\n   s == :@cat             #=> true\n \\n这也可用于创建无法使用<code>:xxx</code>表示法表示的符号。\\n n    'cat and dog'.to_sym   #=> :\"cat and dog\"", "name": "reverse!", "namespace": "String", "path": "String#reverse!", "type": "instance_method", "visibility": "public"}, "String#rindex": {"description": "返回<i>str>的字符长度。", "name": "rindex", "namespace": "String", "path": "String#rindex", "type": "instance_method", "visibility": "public"}, "String#rjust": {"description": "使用提供的记录分隔符（默认值为<code>$/</code>）返回<i>str中的行数组。这是<code>str.each_line(separator).to_a</code>的简写。\\n \\n如果给定的块（已弃用）的工作方式与<code>each_line</code>相同。", "name": "rjust", "namespace": "String", "path": "String#rjust", "type": "instance_method", "visibility": "public"}, "String#rpartition": {"description": "如果<i>integer<i>大于<i>str的长度，则返回长度为<i>integer的新的<code>$&</code>2；<i>with<i>str</i>left-justified and padded with<i>padstr<i>；否则，返回<i>str<i>。n \n   \"hello\".ljust(4)            #=> \"hello\"\n   \"hello\".ljust(20)           #=> \"hello               \"\n   \"hello\".ljust(20, '1234')   #=> \"hello123412341234123\"", "name": "rpartition", "namespace": "String", "path": "String#rpartition", "type": "instance_method", "visibility": "public"}, "String#rstrip": {"description": "返回删除前导空格后的<i>str.<i>另见<code>String#rstrip</code>和<code>String#strip</code>。\\n \\n有关空白的定义，请参阅<code>strip</code>。n \n   \"  hello  \".lstrip   #=> \"hello  \"\n   \"hello\".lstrip       #=> \"hello\"", "name": "rstrip", "namespace": "String", "path": "String#rstrip", "type": "instance_method", "visibility": "public"}, "String#rstrip!": {"description": "从<i>str<i>中删除前导空格，如果未做任何更改，则返回<code>nil</code>。另见<code>String#rstrip!</code>和<code>Hash</code>2。\\n \\n有关空白的定义，请参阅<code>strip</code>。n \n   \"  hello  \".lstrip!  #=> \"hello  \"\n   \"hello  \".lstrip!    #=> nil\n   \"hello\".lstrip!      #=> nil", "name": "rstrip!", "namespace": "String", "path": "String#rstrip!", "type": "instance_method", "visibility": "public"}, "String#scan": {"description": "将<i>模式转换为<code>Regexp</code>（如果它还不是一个），\\n然后在<i>str上调用其<code>match</code>方法。如果存在第二个参数，则指定字符串中开始搜索的位置。\\n \n   'hello'.match('(.)\\1')      #=> #<MatchData \"ll\" 1:\"l\">\n   'hello'.match('(.)\\1')[0]   #=> \"ll\"\n   'hello'.match(/(.)\\1/)[0]   #=> \"ll\"\n   'hello'.match(/(.)\\1/, 3)   #=> nil\n   'hello'.match('xx')         #=> nil\n \\n如果给定了块，则如果匹配成功，则使用MatchData调用该块，以便您可以写入\n   str.match(pat) {|m| ...}\n \\n而不是\n   if m = str.match(pat)\n     ...\n   end\n \\n在这种情况下，返回值是块执行的值。", "name": "scan", "namespace": "String", "path": "String#scan", "type": "instance_method", "visibility": "public"}, "String#scrub": {"description": "将模式转换为+Regexp+（如果它还不是一个），然后返回+true+或+false+，指示regexp是否匹配str，而不更新<code>$~</code>和其他相关变量。如果存在第二个参数，则指定字符串中开始搜索的位置。n \n   \"Ruby\".match?(/R.../)    #=> true\n   \"Ruby\".match?(/R.../, 1) #=> false\n   \"Ruby\".match?(/P.../)    #=> false\n   $&                       #=> nil", "name": "scrub", "namespace": "String", "path": "String#scrub", "type": "instance_method", "visibility": "public"}, "String#scrub!": {"description": "返回<i>str>的后续项。后继字符是通过从字符串中最右边的字母数字（如果没有字母数字，则是最右边的字符）开始递增字符来计算的。增加一个数字总是会产生另一个数字，而增加一个字母则会产生相同大小写的另一个字母。\\n递增非字母数字使用基础字符集的排序序列。\\n \\n如果增量生成“进位”，则左边的字符将递增。此过程将重复，直到没有进位，如有必要，请添加一个附加字符。n \n   \"abcd\".succ        #=> \"abce\"\n   \"THX1138\".succ     #=> \"THX1139\"\n   \"<<koala>>\".succ   #=> \"<<koalb>>\"\n   \"1999zzz\".succ     #=> \"2000aaa\"\n   \"ZZZ9999\".succ     #=> \"AAAA0000\"\n   \"***\".succ         #=> \"**+\"", "name": "scrub!", "namespace": "String", "path": "String#scrub!", "type": "instance_method", "visibility": "public"}, "String#setbyte": {"description": "相当于<code>String#succ</code>，但在适当位置修改接收器。", "name": "setbyte", "namespace": "String", "path": "String#setbyte", "type": "instance_method", "visibility": "public"}, "String#size": {"description": "将<i>str<i>的前导字符视为一个八进制数字串（带有\\n可选符号），并返回相应的数字。如果转换失败，则返回0。\\n \n   \"123\".oct       #=> 83\n   \"-377\".oct      #=> -255\n   \"bad\".oct       #=> 0\n   \"0377bad\".oct   #=> 255\n \\n如果+str+以<code>0</code>开头，则基数指示符将被接受。\\n请参阅内核整数。", "name": "size", "namespace": "String", "path": "String#size", "type": "instance_method", "visibility": "public"}, "String#slice": {"description": "返回一个字符串的<code>Integer</code>序数。\\n n    \"a\".ord         #=> 97", "name": "slice", "namespace": "String", "path": "String#slice", "type": "instance_method", "visibility": "public"}, "String#slice!": {"description": "在字符串中搜索<i>sep->i>或pattern（<i>regexp->i>）并返回之前的部分、匹配的部分和之后的部分。\\n如果未找到，则返回两个空字符串和<i>str。n \n   \"hello\".partition(\"l\")         #=> [\"he\", \"l\", \"lo\"]\n   \"hello\".partition(\"x\")         #=> [\"hello\", \"\", \"\"]\n   \"hello\".partition(/.l/)        #=> [\"h\", \"el\", \"lo\"]", "name": "slice!", "namespace": "String", "path": "String#slice!", "type": "instance_method", "visibility": "public"}, "String#split": {"description": "prepend-将给定的字符串预先发送到<i>str。\\n \n   a = \"!\"\n   a.prepend(\"hello \", \"world\") #=> \"hello world!\"\n   a                            #=> \"hello world!\"\n \\n另见字符串concat。", "name": "split", "namespace": "String", "path": "String#split", "type": "instance_method", "visibility": "public"}, "String#squeeze": {"description": "将<i>str的内容和污点替换为<i>other_str中的相应值。n \n   s = \"hello\"         #=> \"hello\"\n   s.replace \"world\"   #=> \"world\"", "name": "squeeze", "namespace": "String", "path": "String#squeeze", "type": "instance_method", "visibility": "public"}, "String#squeeze!": {"description": "以相反的顺序返回一个新字符串，其中包含<i>str<i>中的字符。\\n n    \"stressed\".reverse   #=> \"desserts\"", "name": "squeeze!", "namespace": "String", "path": "String#squeeze!", "type": "instance_method", "visibility": "public"}, "String#start_with?": {"description": "反转<i>str<i>in place。", "name": "start_with?", "namespace": "String", "path": "String#start_with?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "String#strip": {"description": "返回给定<i>子字符串的最后一次出现的索引或<i>str中的模式（<i>regexp<i>）。如果找不到，则返回<code>nil</code>。如果存在第二个参数，它将指定字符串中结束搜索的位置-将不考虑超过此点的字符。n \n   \"hello\".rindex('e')             #=> 1\n   \"hello\".rindex('l')             #=> 3\n   \"hello\".rindex('a')             #=> nil\n   \"hello\".rindex(?e)              #=> 1\n   \"hello\".rindex(/[aeiou]/, -2)   #=> 1", "name": "strip", "namespace": "String", "path": "String#strip", "type": "instance_method", "visibility": "public"}, "String#strip!": {"description": "如果<i>integer<i>大于<i>str的长度，则返回长度为<i>integer的新的<code>String</code>，其中<i>str<i>right justified and padded with<i>padstr<i>；否则，返回<i>str<i>。n \n   \"hello\".rjust(4)            #=> \"hello\"\n   \"hello\".rjust(20)           #=> \"               hello\"\n   \"hello\".rjust(20, '1234')   #=> \"123412341234123hello\"", "name": "strip!", "namespace": "String", "path": "String#strip!", "type": "instance_method", "visibility": "public"}, "String#sub": {"description": "从字符串的末尾搜索字符串中的<i>sep<i>或pattern（<i>regexp<i>），并返回该字符串前面的部分、匹配部分和后面的部分。\\n如果未找到，则返回两个空字符串和<i>str。n \n   \"hello\".rpartition(\"l\")         #=> [\"hel\", \"l\", \"o\"]\n   \"hello\".rpartition(\"x\")         #=> [\"\", \"\", \"hello\"]\n   \"hello\".rpartition(/.l/)        #=> [\"he\", \"ll\", \"o\"]", "name": "sub", "namespace": "String", "path": "String#sub", "type": "instance_method", "visibility": "public"}, "String#sub!": {"description": "返回删除了尾随空格的<i>str.>i>的副本。另见<code>String#lstrip</code>和<code>String#strip</code>。\\n \\n有关空白的定义，请参阅<code>strip</code>。n \n   \"  hello  \".rstrip   #=> \"  hello\"\n   \"hello\".rstrip       #=> \"hello\"", "name": "sub!", "namespace": "String", "path": "String#sub!", "type": "instance_method", "visibility": "public"}, "String#succ": {"description": "从<i>str<i>中删除尾随空格，如果未做任何更改，则返回<code>nil</code>。另见<code>String#lstrip!</code>和<code>String#strip!</code>。\\n \\n有关空白的定义，请参阅<code>strip</code>。n \n   \"  hello  \".rstrip!  #=> \"  hello\"\n   \"  hello\".rstrip!    #=> nil\n   \"hello\".rstrip!      #=> nil", "name": "succ", "namespace": "String", "path": "String#succ", "type": "instance_method", "visibility": "public"}, "String#succ!": {"description": "两个表单都迭代通过<i>str<i>，匹配模式（可能是<code>Regexp</code>或<code>String</code>）。对于每个匹配，将生成一个结果，并将其添加到结果数组或传递到块。如果模式不包含组，则每个单独的结果都由匹配的字符串<code>$&</code>组成。如果模式包含组，则每个单独的结果本身就是一个数组，每个组包含一个条目。\\n \n   a = \"cruel world\"\n   a.scan(/\\w+/)        #=> [\"cruel\", \"world\"]\n   a.scan(/.../)        #=> [\"cru\", \"el \", \"wor\"]\n   a.scan(/(...)/)      #=> [[\"cru\"], [\"el \"], [\"wor\"]]\n   a.scan(/(..)(..)/)   #=> [[\"cr\", \"ue\"], [\"l \", \"wo\"]]\n \\n和块形式：\\n \n   a.scan(/\\w+/) {|w| print \"<<#{w}>> \" }\n   print \"\\n\"\n   a.scan(/(.)(.)/) {|x,y| print y, x }\n   print \"\\n\"\n \\n<em>products:-\\n \n   <<cruel>> <<world>>\n rceu lowlr", "name": "succ!", "namespace": "String", "path": "String#succ!", "type": "instance_method", "visibility": "public"}, "String#sum": {"description": "如果字符串是无效的字节序列，则用给定的替换字符替换无效的字节，否则返回self。\\n如果给定了块，请用块的返回值替换无效的字节。n \n   \"abc\\u3042\\x81\".scrub #=> \"abc\\u3042\\uFFFD\"\n   \"abc\\u3042\\x81\".scrub(\"*\") #=> \"abc\\u3042*\"\n   \"abc\\u3042\\xE3\\x80\".scrub{|bytes| '<'+bytes.unpack('H*')[0]+'>' } #=> \"abc\\u3042<e380>\"", "name": "sum", "namespace": "String", "path": "String#sum", "type": "instance_method", "visibility": "public"}, "String#swapcase": {"description": "如果字符串是无效的字节序列，则用给定的替换字符替换无效的字节，否则返回self。\\n如果给定了块，请用块的返回值替换无效的字节。n \n   \"abc\\u3042\\x81\".scrub! #=> \"abc\\u3042\\uFFFD\"\n   \"abc\\u3042\\x81\".scrub!(\"*\") #=> \"abc\\u3042*\"\n   \"abc\\u3042\\xE3\\x80\".scrub!{|bytes| '<'+bytes.unpack('H*')[0]+'>' } #=> \"abc\\u3042<e380>\"", "name": "swapcase", "namespace": "String", "path": "String#swapcase", "type": "instance_method", "visibility": "public"}, "String#swapcase!": {"description": "将索引修改为整数。", "name": "swapcase!", "namespace": "String", "path": "String#swapcase!", "type": "instance_method", "visibility": "public"}, "String#to_c": {"description": "返回<i>str>的字符长度。", "name": "to_c", "namespace": "String", "path": "String#to_c", "type": "instance_method", "visibility": "public"}, "String#to_f": {"description": "元素引用-如果传递单个+index+，则返回该索引处一个字符的子字符串。如果传递了一个+start+索引和一个+length+，则返回一个子字符串，其中包含从+start+索引开始的+length+个字符。如果传递的是+range+，则其开始和结束将被解释为限定要返回的子字符串的偏移量。\\n \\n在这三种情况下，如果索引为负，则从字符串结尾开始计数。对于+start+和+range+情况，起始索引刚好在匹配字符串大小的字符和索引之前。\\n此外，当字符范围的起始索引位于字符串末尾时，将返回空字符串。\\n \\n如果初始索引超出字符串或长度为负，则返回+nil+。\\n \\n如果提供了+Regexp+，则返回字符串的匹配部分。如果+capture+跟随正则表达式（可能是捕获组索引或名称）跟随正则表达式，则返回MatchData的组件。\\n \\n如果给定了+match_str+，则如果该字符串出现在字符串中，则返回该字符串。\\n \\n如果正则表达式不匹配或找不到匹配字符串，则返回+nil+。n \n   a = \"hello there\"\n\n   a[1]                   #=> \"e\"\n   a[2, 3]                #=> \"llo\"\n   a[2..3]                #=> \"ll\"\n\n   a[-3, 2]               #=> \"er\"\n   a[7..-2]               #=> \"her\"\n   a[-4..-2]              #=> \"her\"\n   a[-2..-4]              #=> \"\"\n\n   a[11, 0]               #=> \"\"\n   a[11]                  #=> nil\n   a[12, 0]               #=> nil\n   a[12..-1]              #=> nil\n\n   a[/[aeiou](.)\\1/]      #=> \"ell\"\n   a[/[aeiou](.)\\1/, 0]   #=> \"ell\"\n   a[/[aeiou](.)\\1/, 1]   #=> \"l\"\n   a[/[aeiou](.)\\1/, 2]   #=> nil\n\n   a[/(?<vowel>[aeiou])(?<non_vowel>[^aeiou])/, \"non_vowel\"] #=> \"l\"\n   a[/(?<vowel>[aeiou])(?<non_vowel>[^aeiou])/, \"vowel\"]     #=> \"e\"\n\n   a[\"lo\"]                #=> \"lo\"\n   a[\"bye\"]               #=> nil", "name": "to_f", "namespace": "String", "path": "String#to_f", "type": "instance_method", "visibility": "public"}, "String#to_i": {"description": "从<i>str>中删除指定的部分，并返回\\n已删除的部分。n \n   string = \"this is a string\"\n   string.slice!(2)        #=> \"i\"\n   string.slice!(3..6)     #=> \" is \"\n   string.slice!(/s.*t/)   #=> \"sa st\"\n   string.slice!(\"r\")      #=> \"r\"\n   string                  #=> \"thing\"", "name": "to_i", "namespace": "String", "path": "String#to_i", "type": "instance_method", "visibility": "public"}, "String#to_r": {"description": "根据分隔符将<i>str<i>划分为子字符串，返回这些子字符串的数组。\\n \\n如果<i>pattern<i>是<code>String</code>，则在拆分<i>str时，其内容用作分隔符。如果<i>pattern<i>is a single space，<i>str<i>is split on whitespace，with leading whitespace and runs of continuous whitespace characters ignored.\\n \\n如果<i>pattern</i>是一个<code>Regexp</code>，<i>str</i>is divided where the pattern matches.每当模式与零长度字符串匹配时，就会将\\n<i>str<i>拆分为单个字符。如果<i>pattern<i>contains groups，则相应的匹配项也将返回到数组中。\\n \\n如果<i>pattern<i>is <code>nil</code>，则使用值<code>$;</code>。\\n如果<code>$;</code>是<code>nil</code>（这是默认值），<i>str<i>is split on whitespace as if“”were specified.\\n \\n如果省略了<i>limit='i>参数，将抑制后面的空字段。如果<i>limit<i>是一个正数，则最多将返回拆分子字符串的数目（捕获的组也将返回，但不计入限制）。\\n如果<i>limit<i>is <code>1</code>，则整个字符串作为数组中的唯一条目返回。如果为负，则返回的字段数没有限制，后面的空字段不会被抑制。\\n \\n当输入+str+为空时，将返回空数组，因为该字符串被认为没有要拆分的字段。\\n \n   \" now's  the time\".split        #=> [\"now's\", \"the\", \"time\"]\n   \" now's  the time\".split(' ')   #=> [\"now's\", \"the\", \"time\"]\n   \" now's  the time\".split(/ /)   #=> [\"\", \"now's\", \"\", \"the\", \"time\"]\n   \"1, 2.34,56, 7\".split(%r{,\\s*}) #=> [\"1\", \"2.34\", \"56\", \"7\"]\n   \"hello\".split(//)               #=> [\"h\", \"e\", \"l\", \"l\", \"o\"]\n   \"hello\".split(//, 3)            #=> [\"h\", \"e\", \"llo\"]\n   \"hi mom\".split(%r{\\s*})         #=> [\"h\", \"i\", \"m\", \"o\", \"m\"]\n\n   \"mellow yellow\".split(\"ello\")   #=> [\"m\", \"w y\", \"w\"]\n   \"1,2,,3,4,,\".split(',')         #=> [\"1\", \"2\", \"\", \"3\", \"4\"]\n   \"1,2,,3,4,,\".split(',', 4)      #=> [\"1\", \"2\", \"\", \"3,4,,\"]\n   \"1,2,,3,4,,\".split(',', -4)     #=> [\"1\", \"2\", \"\", \"3\", \"4\", \"\", \"\"]\n\n   \"1:2:3\".split(/(:)()()/, 2)     #=> [\"1\", \":\", \"\", \"\", \"2:3\"]\n \\n    \"\".split(',', -1)               #=> []", "name": "to_r", "namespace": "String", "path": "String#to_r", "type": "instance_method", "visibility": "public"}, "String#to_s": {"description": "挤压<i>str<i>in place，如果没有进行任何更改，则返回<i>str<i>或<code>nil</code>。", "name": "to_s", "namespace": "String", "path": "String#to_s", "type": "instance_method", "visibility": "public"}, "String#to_str": {"description": "挤压<i>str<i>in place，如果没有进行任何更改，则返回<i>str<i>或<code>nil</code>。", "name": "to_str", "namespace": "String", "path": "String#to_str", "type": "instance_method", "visibility": "public"}, "String#to_sym": {"description": "如果+str+以给定的+prefixes+之一开头，则返回true。n \n  \"hello\".start_with?(\"hell\")               #=> true\n\n  # returns true if one of the prefixes matches.\n  \"hello\".start_with?(\"heaven\", \"hell\")     #=> true\n  \"hello\".start_with?(\"heaven\", \"paradise\") #=> false", "name": "to_sym", "namespace": "String", "path": "String#to_sym", "type": "instance_method", "visibility": "public"}, "String#tr": {"description": "返回删除前导空格和尾随空格的<i>str<i>\\n \\n空白被定义为下列任何字符：\\n NULL、水平制表符、换行符、垂直制表符、换行符、回车符、空格。n \n   \"    hello    \".strip   #=> \"hello\"\n   \"\\tgoodbye\\r\\n\".strip   #=> \"goodbye\"\n   \"\\x00\\t\\n\\v\\f\\r \".strip #=> \"\"", "name": "tr", "namespace": "String", "path": "String#tr", "type": "instance_method", "visibility": "public"}, "String#tr!": {"description": "从<i>str>中删除前导空格和尾随空格。如果未更改，则返回<code>nil</code>。\\n \\n有关空白的定义，请参阅<code>strip</code>。", "name": "tr!", "namespace": "String", "path": "String#tr!", "type": "instance_method", "visibility": "public"}, "String#tr_s": {"description": "返回一个+str+的副本，第一次出现的+pattern+ \\n被第二个参数替换。+pattern+通常是一个Regexp;如果作为一个字符串给出，它包含的任何正则表达式元字符都将被逐字解释，例如，<code>'\\\\\\d'</code>将匹配反斜杠，后跟“d”，而不是数字。\\n \\n如果+replacement+是字符串，则将替换匹配的文本。\\n它可能包含对模式的捕获组的后面引用，格式为<code>\"\\\\d\"</code>，其中<i>d<i>i s a group number，or <code>\"\\\\k<n>\"</code>，where<i>n<i>i s a group name.如果是双引号字符串，则两个后引用前面都必须有一个\\n附加反斜杠。但是，在+replacement+中，特殊匹配变量（如<code>$&</code>）将不引用当前匹配。\\n如果+replacement+是一个看起来像模式的捕获组但实际上不是模式捕获组的字符串，例如<code>\"\\\\'\"</code>，则它前面必须有两个反斜杠，如<code>\"\\\\\\\\'\"</code>。\\n \\n如果第二个参数是哈希，并且匹配的文本是其键之一，则对应的值是替换字符串。\\n \\n在区块形式中，目前的比对字串会作为参数传入，并会适当设定<code>$1</code>、<code>$2</code>、<code>$`</code>、<code>$&</code>和<code>$'</code>等变数。块返回的值将在每次调用时替换匹配项。\\n \\n结果继承原始字符串或提供的任何替换字符串中的任何污点。n \n   \"hello\".sub(/[aeiou]/, '*')                  #=> \"h*llo\"\n   \"hello\".sub(/([aeiou])/, '<\\1>')             #=> \"h<e>llo\"\n   \"hello\".sub(/./) {|s| s.ord.to_s + ' ' }     #=> \"104 ello\"\n   \"hello\".sub(/(?<foo>[aeiou])/, '*\\k<foo>*')  #=> \"h*e*llo\"\n   'Is SHELL your preferred shell?'.sub(/[[:upper:]]{2,}/, ENV)\n    #=> \"Is /bin/bash your preferred shell?\"", "name": "tr_s", "namespace": "String", "path": "String#tr_s", "type": "instance_method", "visibility": "public"}, "String#tr_s!": {"description": "执行与字符串sub相同的替换。\\n \\n如果执行了替换，则返回+str+；如果未执行替换，则返回+nil+。", "name": "tr_s!", "namespace": "String", "path": "String#tr_s!", "type": "instance_method", "visibility": "public"}, "String#undump": {"description": "返回<i>str>的后续项。后继字符是通过从字符串中最右边的字母数字（如果没有字母数字，则是最右边的字符）开始递增字符来计算的。增加一个数字总是会产生另一个数字，而增加一个字母则会产生相同大小写的另一个字母。\\n递增非字母数字使用基础字符集的排序序列。\\n \\n如果增量生成“进位”，则左边的字符将递增。此过程将重复，直到没有进位，如有必要，请添加一个附加字符。n \n   \"abcd\".succ        #=> \"abce\"\n   \"THX1138\".succ     #=> \"THX1139\"\n   \"<<koala>>\".succ   #=> \"<<koalb>>\"\n   \"1999zzz\".succ     #=> \"2000aaa\"\n   \"ZZZ9999\".succ     #=> \"AAAA0000\"\n   \"***\".succ         #=> \"**+\"", "name": "undump", "namespace": "String", "path": "String#undump", "type": "instance_method", "visibility": "public"}, "String#unicode_normalize": {"description": "相当于<code>String#succ</code>，但在适当位置修改接收器。", "name": "unicode_normalize", "namespace": "String", "path": "String#unicode_normalize", "type": "instance_method", "visibility": "public"}, "String#unicode_normalize!": {"description": "返回<i>str中字符的基本校验和，默认值为16。结果只是在模块<code>2**n - 1</code>中每个字节的二进制值之和。这不是一个特别好的校验和。", "name": "unicode_normalize!", "namespace": "String", "path": "String#unicode_normalize!", "type": "instance_method", "visibility": "public"}, "String#unicode_normalized?": {"description": "返回将大写字母字符转换为小写字符和将小写字符转换为大写字符的<i>str.<i>\\n \\n有关+options+的含义，请参阅字符串小写，并与不同的编码一起使用。n \n   \"Hello\".swapcase          #=> \"hELLO\"\n   \"cYbEr_PuNk11\".swapcase   #=> \"CyBeR_pUnK11\"", "name": "unicode_normalized?", "namespace": "String", "path": "String#unicode_normalized?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "String#unpack": {"description": "相当于<code>String#swapcase</code>，但在适当的位置修改接收器，如果没有进行任何更改，则返回<i>str.>i>或<code>nil</code>。\\n \\n有关+options+的含义，请参阅字符串小写，并与不同的编码一起使用。", "name": "unpack", "namespace": "String", "path": "String#unpack", "type": "instance_method", "visibility": "public"}, "String#unpack1": {"description": "返回表示字符串形式的复数。分析器忽略前导空格和尾随垃圾。任何数字序列都可以用下划线分隔。为空字符串或垃圾字符串返回零。\\n \n   '9'.to_c           #=> (9+0i)\n   '2.5'.to_c         #=> (2.5+0i)\n   '2.5/1'.to_c       #=> ((5/2)+0i)\n   '-3/2'.to_c        #=> ((-3/2)+0i)\n   '-i'.to_c          #=> (0-1i)\n   '45i'.to_c         #=> (0+45i)\n   '3-4i'.to_c        #=> (3-4i)\n   '-4e2-4e-2i'.to_c  #=> (-400.0-0.04i)\n   '-0.0-0.0i'.to_c   #=> (-0.0-0.0i)\n   '1/2+3/4i'.to_c    #=> ((1/2)+(3/4)*i)\n   'ruby'.to_c        #=> (0+0i)\n \\n请参阅kernel.complex。", "name": "unpack1", "namespace": "String", "path": "String#unpack1", "type": "instance_method", "visibility": "public"}, "String#upcase": {"description": "返回将<i>str<i>中的前导字符解释为浮点数的结果。超过有效数字结尾的外来字符将被忽略。如果<i>str开头没有有效数字，则返回\\n <code>0.0</code>。此方法从不引发异常。n \n   \"123.45e1\".to_f        #=> 1234.5\n   \"45.67 degrees\".to_f   #=> 45.67\n   \"thx1138\".to_f         #=> 0.0", "name": "upcase", "namespace": "String", "path": "String#upcase", "type": "instance_method", "visibility": "public"}, "String#upcase!": {"description": "返回将<i>str中的前导字符解释为整数base的结果（介于2和36之间）。超过有效数字结尾的外来字符将被忽略。如果在<i>str<i>开头没有有效数字，则返回<code>0</code>。当<i>base<i>有效时，此方法不会引发\\n异常。n \n   \"12345\".to_i             #=> 12345\n   \"99 red balloons\".to_i   #=> 99\n   \"0a\".to_i                #=> 0\n   \"0a\".to_i(16)            #=> 10\n   \"hello\".to_i             #=> 0\n   \"1100101\".to_i(2)        #=> 101\n   \"1100101\".to_i(8)        #=> 294977\n   \"1100101\".to_i(10)       #=> 1100101\n   \"1100101\".to_i(16)       #=> 17826049", "name": "upcase!", "namespace": "String", "path": "String#upcase!", "type": "instance_method", "visibility": "public"}, "String#upto": {"description": "返回将+str+中的前导字符解释为有理数的结果。超过有效数字结尾的前导空格和外来字符将被忽略。\\n数字序列可以用下划线分隔。\\n如果在+str+开头没有有效的数字，则返回零。此方法从不引发异常。\\n \n   '  2  '.to_r       #=> (2/1)\n   '300/2'.to_r       #=> (150/1)\n   '-9.2'.to_r        #=> (-46/5)\n   '-9.2e2'.to_r      #=> (-920/1)\n   '1_234_567'.to_r   #=> (1234567/1)\n   '21 June 09'.to_r  #=> (21/1)\n   '21/06/09'.to_r    #=> (7/2)\n   'BWV 1079'.to_r    #=> (0/1)\n \\n NOTE:“0.3”。to_r与0.3.to_r不同。前者相当于“3/10”。to_r，但后者不同。\\n \n   \"0.3\".to_r == 3/10r  #=> true\n   0.3.to_r   == 3/10r  #=> false\n \\n另请参阅kernel rational。", "name": "upto", "namespace": "String", "path": "String#upto", "type": "instance_method", "visibility": "public"}, "String#valid_encoding?": {"description": "返回+self+。\\n \\n如果在string的子类上调用，则将接收器转换为string对象。", "name": "valid_encoding?", "namespace": "String", "path": "String#valid_encoding?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "String.try_convert": {"description": "返回+self+。\\n \\n如果在string的子类上调用，则将接收器转换为string对象。", "name": "try_convert", "namespace": "String", "path": "String.try_convert", "type": "class_method", "visibility": "public"}, "Float": {"description": "返回对应于<i>str<i>的<code>Symbol</code>，如果该符号以前不存在，则创建该符号。见<code>Symbol#id2name</code>。\\n \n   \"Koala\".intern         #=> :Koala\n   s = 'cat'.to_sym       #=> :cat\n   s == :cat              #=> true\n   s = '@cat'.to_sym      #=> :@cat\n   s == :@cat             #=> true\n \\n这也可用于创建无法使用<code>:xxx</code>表示法表示的符号。\\n n    'cat and dog'.to_sym   #=> :\"cat and dog\"", "name": "Float", "namespace": "", "path": "Float", "type": "class", "visibility": "public"}, "Float#%": {"description": "如果+float+大于+real+，则返回+true+。\\n \\n <code>NaN > NaN</code>的结果未定义，因此返回一个依赖于实现的值。", "name": "%", "namespace": "Float", "path": "Float#%", "type": "instance_method", "visibility": "public"}, "Float#*": {"description": "使用与<code>String#tr</code>相同的规则，将<i>str<i>in place转换。如果没有进行任何更改，则返回<i>str.>i>或<code>nil</code>。", "name": "*", "namespace": "Float", "path": "Float#*", "type": "instance_method", "visibility": "public"}, "Float#**": {"description": "按照<code>String#tr</code>中的描述处理<i>str的副本，然后删除受翻译影响的区域中的重复字符。n \n   \"hello\".tr_s('l', 'r')     #=> \"hero\"\n   \"hello\".tr_s('el', '*')    #=> \"h*o\"\n   \"hello\".tr_s('el', 'hx')   #=> \"hhxo\"", "name": "**", "namespace": "Float", "path": "Float#**", "type": "instance_method", "visibility": "public"}, "Float#+": {"description": "如果没有进行任何更改，则对<i>str<i>i n place、\\n returning<i>str<i>或<code>nil</code>执行<code>String#tr_s</code>处理。", "name": "+", "namespace": "Float", "path": "Float#+", "type": "instance_method", "visibility": "public"}, "Float#-": {"description": "生成无范围版本+str+。\\n另请参阅字符串转储，因为字符串转储与字符串转储相反。\\n n   \"\\\"hello \\\\n ''\\\"\".undump #=> \"hello \\n ''\"", "name": "-", "namespace": "Float", "path": "Float#-", "type": "instance_method", "visibility": "public"}, "Float#-@": {"description": "unicode normalizations-使用unicode normalizations nfc、nfd、NFKC或NFKD返回标准化形式+str+。\\n所用的规范化形式由+form+确定，它可以是\\n四个值中的任何一个：+：nfc+、+：nfd+、+：nfkc+或+：nfkd+。\\n默认值为+：nfc+。\\n \\n如果字符串不是Unicode编码，则会引发异常。\\n在此上下文中，“unicode编码”是指utf-8、utf-16be/le、\\n和utf-32be/le中的任何一种，以及GB18030、ucs2be和UCS_4BE。\\n除了utf-8以外的任何东西都是通过转换为utf-8来实现的，这使得它比utf-8慢。n \n  \"a\\u0300\".unicode_normalize        #=> \"\\u00E0\"\n  \"a\\u0300\".unicode_normalize(:nfc)  #=> \"\\u00E0\"\n  \"\\u00E0\".unicode_normalize(:nfd)   #=> \"a\\u0300\"\n  \"\\xE0\".force_encoding('ISO-8859-1').unicode_normalize(:nfd)\n                                     #=> Encoding::CompatibilityError raised", "name": "-@", "namespace": "Float", "path": "Float#-@", "type": "instance_method", "visibility": "public"}, "Float#/": {"description": "破坏性版本的字符串unicode 进行规范化，就地执行unicode规范化。", "name": "/", "namespace": "Float", "path": "Float#/", "type": "instance_method", "visibility": "public"}, "Float#<": {"description": "检查+str+是否为Unicode规范化表单+form+，它可以是四个值中的任意一个：+：nfc+、+：nfd+、+：nfkc+或+：nfkd+。\\n默认值为+：nfc+。\\n \\n如果字符串不是Unicode编码，则会引发异常。\\n有关详细信息，请参阅字符串\\ unicode \\u normalize。n \n  \"a\\u0300\".unicode_normalized?        #=> false\n  \"a\\u0300\".unicode_normalized?(:nfd)  #=> true\n  \"\\u00E0\".unicode_normalized?         #=> true\n  \"\\u00E0\".unicode_normalized?(:nfd)   #=> false\n  \"\\xE0\".force_encoding('ISO-8859-1').unicode_normalized?\n                                       #=> Encoding::CompatibilityError raised", "name": "<", "namespace": "Float", "path": "Float#<", "type": "instance_method", "visibility": "public"}, "Float#<=": {"description": "根据格式字符串解码（可能包含二进制数据），返回提取的每个值的数组。格式字符串由一系列单字符指令组成，这些指令\\n在此项末尾的表中汇总。\\n每个指令后面都可以跟一个数字，指示用该指令重复的次数。星号（``<code>*</code>''）将耗尽所有剩余元素。指令<code>sSiIlL</code>后面可以跟下划线（``<code>_</code>''）或感叹号（``<code>!</code>''），以使用基础平台的本机大小来指定type;，否则，它使用独立于平台的一致大小。格式字符串中的空格将被忽略。另见<code>String#unpack1</code>、<code>Array#pack</code>。\\n \n   \"abc \\0\\0abc \\0\\0\".unpack('A6Z6')   #=> [\"abc\", \"abc \"]\n   \"abc \\0\\0\".unpack('a3a3')           #=> [\"abc\", \" \\000\\000\"]\n   \"abc \\0abc \\0\".unpack('Z*Z*')       #=> [\"abc \", \"abc \"]\n   \"aa\".unpack('b8B8')                 #=> [\"\n  browsers.empty? #=> false\n0\", \"01100001\"]\n   \"aaa\".unpack('h2H2c')               #=> [\"16\", \"61\", 97]\n   \"\\xfe\\xff\\xfe\\xff\".unpack('sS')     #=> [-2, 65534]\n   \"now=20is\".unpack('M*')             #=> [\"now is\"]\n   \"whole\".unpack('xax2aX2aX1aX2a')    #=> [\"h\", \"e\", \"l\", \"l\", \"o\"]\n \\n此表汇总了各种格式和每个返回的Ruby类。\\n \\n integer \\n directive返回含义\\n- ----------------------------------------------------------------\\n c integer 8位无符号（无符号字符\\n s integer 16位无符号，本机端接（uint16_t）\\n l integer 32位无符号，本机端接（uint32_t）n q integer 64位无符号，本机endian（uint64_t）\\n j integer指针宽度无符号，本机endian（uintptr_t）\n               |         |\n c integer 8位有符号（signed char），n s integer 16位有符号，本机endian（int16_t），n l integer 32位有符号，本机endian（int32_t）\\n q integer 64位有符号，本机endian（int64_t）\\n j integer指针宽度有符号，本机endian（intptr_t）\n               |         |\n S_ s！integer_unsigned short，native endian \\n i I_ i！integer_unsigned int，本机endian \\n L_ L！integer_unsigned long，native endian \\n Q_ Q！integer_unsigned long long，native endian（参数错误\n               |         | if the platform has no long long type.)\n J！integer_uintptr_t，本机endian（与j相同）\n               |         |\n s_ s！integer_signed short，native endian \\n i i_ i！integer_signed int，native endian \\n l_ L！integer_signed long，native endian \\n q_ Q！integer_signed long long，native endian（参数错误\n               |         | if the platform has no long long type.)\n J！integer_intptr_t，本机endian（与j相同）\n               |         |\n s>s>s！>S！>integer与不带“>”的指令相同，但\\n l>l>l！>我！>big endian \\n i！>我！>\\n q>q>q！>问！>“s>”与“n”相同\\n j>j>j！>J！>“l>”与“n”\n               |         |\n s<s<s！相同<s！<integer与不带“<”的指令相同，但\\n l<l<l！<l！<小endian \\n i！<我！<\\n q<q<q！<Q！<“s<”与“v”相同\\n j<j<j！<j！<“L<”与“V”\n               |         |\n N整数16位无符号，网络（big endian）字节顺序\\n整数32位无符号，网络（big endian）字节顺序\\n V整数16位无符号，VAX（little endian）字节顺序\\n V整数32位无符号，VAX（little endian）字节1002相同494 u integer utf-8 character \\n w integer ber compressed integer（请参阅array.pack）\\n \\n float \\n指令返回含义\\n- ------------------------------------------------------\\n d float双精度，本机格式\\n f f float single精度，本机格式\\n e float double precision，little endian byte order \\n e float single precision，little endian byte order \\n g float double precision，network（big endian）byte order \\n \\n string\\n指令返回含义\\n- -----------------------------------------------------------\\n a字符串任意二进制字符串（删除尾随的空值和ASCII空格）\\n a字符串任意二进制字符串\\n z字符串以空值结尾的字符串\\n b字符串位串（msb-first）位串\\n b字符串位串（lsb-first）位串\\n h字符串十六进制串（high nibble-first）位串\\n h字符串十六进制串（low nibble-first）位串\\n u字符串u u编码串\\n m字符串带引号的可打印、MIME编码（请参阅rfc245 \\n m字符串base64编码字符串（RFC 2045）（默认值）\n              |         | base64 encoded string (RFC 4648) if followed by 0\n P字符串指向结构的指针（固定长度字符串）\\n P字符串指向以空结尾的字符串的指针\\n \\n其他。\\n指令返回含义\\n- -------------------------------------------------------------------\\n", "name": "<=", "namespace": "Float", "path": "Float#<=", "type": "instance_method", "visibility": "public"}, "Float#<=>": {"description": "根据格式字符串解码（可能包含二进制数据），返回提取的第一个值。\\n另请参阅<code>String#unpack</code>、<code>Array#pack</code>。", "name": "<=>", "namespace": "Float", "path": "Float#<=>", "type": "instance_method", "visibility": "public"}, "Float#==": {"description": "", "name": "==", "namespace": "Float", "path": "Float#==", "type": "instance_method", "visibility": "public"}, "Float#===": {"description": "", "name": "===", "namespace": "Float", "path": "Float#===", "type": "instance_method", "visibility": "public"}, "Float#>": {"description": "返回一个<i>str<i>的副本，将所有小写字母替换为它们的大写对应字母。\\n \\n有关+options+的含义，请参阅字符串小写，并与不同的编码一起使用。\\n n    \"hEllO\".upcase   #=> \"HELLO\"", "name": ">", "namespace": "Float", "path": "Float#>", "type": "instance_method", "visibility": "public"}, "Float#>=": {"description": "upcases the contents of<i>str<i>，returning <code>nil</code> if no changes were made.\\n \\n有关+options+的含义，请参阅字符串小写，并与不同的编码一起使用。", "name": ">=", "namespace": "Float", "path": "Float#>=", "type": "instance_method", "visibility": "public"}, "Float#abs": {"description": "返回-1、0或+1，具体取决于+float+是小于、等于还是大于+real+。\\n这是可比较模块中测试的基础。\\n \\n <code>NaN <=> NaN</code>的结果未定义，因此返回一个依赖于实现的值。\\n \\n如果这两个值不可比较，则返回+nil+。", "name": "abs", "namespace": "Float", "path": "Float#abs", "type": "instance_method", "visibility": "public"}, "Float#angle": {"description": "返回大于或等于+float+的最小数字，精度为+ndigits+位十进制数字（默认值：0）。\\n \\n如果精度为负，则返回的值是一个整数，后面至少有<code>ndigits.abs</code>个零。\\n \\n当+ndigits+为正数时返回浮点数，否则返回整数。\\n \n   1.2.ceil      #=> 2\n   2.0.ceil      #=> 2\n   (-1.2).ceil   #=> -1\n   (-2.0).ceil   #=> -2\n\n   1.234567.ceil(2)   #=> 1.24\n   1.234567.ceil(3)   #=> 1.235\n   1.234567.ceil(4)   #=> 1.2346\n   1.234567.ceil(5)   #=> 1.23457\n\n   34567.89.ceil(-5)  #=> 100000\n   34567.89.ceil(-4)  #=> 40000\n   34567.89.ceil(-3)  #=> 35000\n   34567.89.ceil(-2)  #=> 34600\n   34567.89.ceil(-1)  #=> 34570\n   34567.89.ceil(0)   #=> 34568\n   34567.89.ceil(1)   #=> 34567.9\n   34567.89.ceil(2)   #=> 34567.89\n   34567.89.ceil(3)   #=> 34567.89\n \\n请注意，浮点运算的有限精度可能会导致令人惊讶的结果：\\n \\n    (2.1 / 0.7).ceil  #=> 4 (!)", "name": "angle", "namespace": "Float", "path": "Float#angle", "type": "instance_method", "visibility": "public"}, "Float#arg": {"description": "返回大于或等于+float+的最小数字，精度为+ndigits+位十进制数字（默认值：0）。\\n \\n如果精度为负，则返回的值是一个整数，后面至少有<code>ndigits.abs</code>个零。\\n \\n当+ndigits+为正数时返回浮点数，否则返回整数。\\n \n   1.2.ceil      #=> 2\n   2.0.ceil      #=> 2\n   (-1.2).ceil   #=> -1\n   (-2.0).ceil   #=> -2\n\n   1.234567.ceil(2)   #=> 1.24\n   1.234567.ceil(3)   #=> 1.235\n   1.234567.ceil(4)   #=> 1.2346\n   1.234567.ceil(5)   #=> 1.23457\n\n   34567.89.ceil(-5)  #=> 100000\n   34567.89.ceil(-4)  #=> 40000\n   34567.89.ceil(-3)  #=> 35000\n   34567.89.ceil(-2)  #=> 34600\n   34567.89.ceil(-1)  #=> 34570\n   34567.89.ceil(0)   #=> 34568\n   34567.89.ceil(1)   #=> 34567.9\n   34567.89.ceil(2)   #=> 34567.89\n   34567.89.ceil(3)   #=> 34567.89\n \\n请注意，浮点运算的有限精度可能会导致令人惊讶的结果：\\n \\n    (2.1 / 0.7).ceil  #=> 4 (!)", "name": "arg", "namespace": "Float", "path": "Float#arg", "type": "instance_method", "visibility": "public"}, "Float#ceil": {"description": "************************************************************\\n\\n \n  Float objects represent inexact real numbers using the native\n  architecture's double-precision floating point representation.\n102519\n  - http://docs.sun.com/source/806-3568/ncg_goldberg.html\n  - http://wiki.github.com/rdp/ruby_tutorials_core/ruby-talk-faq#wiki-floats_imprecise\n-http://en.wikipedia.org/wiki/floating诳point诳accuracy诳problems", "name": "ceil", "namespace": "Float", "path": "Float#ceil", "type": "instance_method", "visibility": "public"}, "Float#coerce": {"description": "返回+float+除以+other+后的模。n \n   6543.21.modulo(137)      #=> 104.21000000000004\n   6543.21.modulo(137.24)   #=> 92.92999999999961", "name": "coerce", "namespace": "Float", "path": "Float#coerce", "type": "instance_method", "visibility": "public"}, "Float#denominator": {"description": "返回一个新的float，它是+float+和+other+的乘积。", "name": "denominator", "namespace": "Float", "path": "Float#denominator", "type": "instance_method", "visibility": "public"}, "Float#divmod": {"description": "将+float+提升到+other+的幂。\\n n    2.0**3   #=> 8.0", "name": "divmod", "namespace": "Float", "path": "Float#divmod", "type": "instance_method", "visibility": "public"}, "Float#eql?": {"description": "", "name": "eql?", "namespace": "Float", "path": "Float#eql?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Float#fdiv": {"description": "参见数字divmod。n \n   42.0.divmod(6)   #=> [7, 0.0]\n   42.0.divmod(5)   #=> [8, 2.0]", "name": "fdiv", "namespace": "Float", "path": "Float#fdiv", "type": "instance_method", "visibility": "public"}, "Float#finite?": {"description": "返回一个新的浮点值，其差值为+float+和+other+。", "name": "finite?", "namespace": "Float", "path": "Float#finite?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Float#floor": {"description": "返回+float+，求反。", "name": "floor", "namespace": "Float", "path": "Float#floor", "type": "instance_method", "visibility": "public"}, "Float#hash": {"description": "返回一个新的浮点值，该值是将+float+除以+other+的结果。", "name": "hash", "namespace": "Float", "path": "Float#hash", "type": "instance_method", "visibility": "public"}, "Float#infinite?": {"description": "如果+float+小于+real+，则返回+true+。\\n \\n <code>NaN < NaN</code>的结果未定义，因此返回一个依赖于实现的值。", "name": "infinite?", "namespace": "Float", "path": "Float#infinite?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Float#inspect": {"description": "返回绝对值+float+。\\n \n   (-34.56).abs   #=> 34.56\n   -34.56.abs     #=> 34.56\n   34.56.abs      #=> 34.56\n \\n float marize是float abs的别名。", "name": "inspect", "namespace": "Float", "path": "Float#inspect", "type": "instance_method", "visibility": "public"}, "Float#magnitude": {"description": "返回-1、0或+1，具体取决于+float+是小于、等于还是大于+real+。\\n这是可比较模块中测试的基础。\\n \\n <code>NaN <=> NaN</code>的结果未定义，因此返回一个依赖于实现的值。\\n \\n如果这两个值不可比较，则返回+nil+。", "name": "magnitude", "namespace": "Float", "path": "Float#magnitude", "type": "instance_method", "visibility": "public"}, "Float#modulo": {"description": "如果+float+大于+real+，则返回+true+。\\n \\n <code>NaN > NaN</code>的结果未定义，因此返回一个依赖于实现的值。", "name": "modulo", "namespace": "Float", "path": "Float#modulo", "type": "instance_method", "visibility": "public"}, "Float#nan?": {"description": "如果+float+大于或等于+real+，则返回+true+。\\n \\n <code>NaN >= NaN</code>的结果未定义，因此返回一个依赖于实现的值。", "name": "nan?", "namespace": "Float", "path": "Float#nan?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Float#negative?": {"description": "返回绝对值+float+。\\n \n   (-34.56).abs   #=> 34.56\n   -34.56.abs     #=> 34.56\n   34.56.abs      #=> 34.56\n \\n float marize是float abs的别名。", "name": "negative?", "namespace": "Float", "path": "Float#negative?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Float#next_float": {"description": "如果值为正数，则返回0，否则返回pi。", "name": "next_float", "namespace": "Float", "path": "Float#next_float", "type": "instance_method", "visibility": "public"}, "Float#numerator": {"description": "如果值为正数，则返回0，否则返回pi。", "name": "numerator", "namespace": "Float", "path": "Float#numerator", "type": "instance_method", "visibility": "public"}, "Float#phase": {"description": "返回大于或等于+float+的最小数字，精度为+ndigits+位十进制数字（默认值：0）。\\n \\n如果精度为负，则返回的值是一个整数，后面至少有<code>ndigits.abs</code>个零。\\n \\n当+ndigits+为正数时返回浮点数，否则返回整数。\\n \n   1.2.ceil      #=> 2\n   2.0.ceil      #=> 2\n   (-1.2).ceil   #=> -1\n   (-2.0).ceil   #=> -2\n\n   1.234567.ceil(2)   #=> 1.24\n   1.234567.ceil(3)   #=> 1.235\n   1.234567.ceil(4)   #=> 1.2346\n   1.234567.ceil(5)   #=> 1.23457\n\n   34567.89.ceil(-5)  #=> 100000\n   34567.89.ceil(-4)  #=> 40000\n   34567.89.ceil(-3)  #=> 35000\n   34567.89.ceil(-2)  #=> 34600\n   34567.89.ceil(-1)  #=> 34570\n   34567.89.ceil(0)   #=> 34568\n   34567.89.ceil(1)   #=> 34567.9\n   34567.89.ceil(2)   #=> 34567.89\n   34567.89.ceil(3)   #=> 34567.89\n \\n请注意，浮点运算的有限精度可能会导致令人惊讶的结果：\\n \\n    (2.1 / 0.7).ceil  #=> 4 (!)", "name": "phase", "namespace": "Float", "path": "Float#phase", "type": "instance_method", "visibility": "public"}, "Float#positive?": {"description": "返回一个数组，其中+numeric+和+float+都表示为浮点对象。\\n \\n这是通过将+numeric+转换为浮点来实现的。n \n   1.2.coerce(3)       #=> [3.0, 1.2]\n   2.5.coerce(1.1)     #=> [1.1, 2.5]", "name": "positive?", "namespace": "Float", "path": "Float#positive?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Float#prev_float": {"description": "返回分母（始终为正）。结果取决于机器。\\n \\n另请参见浮动分子。", "name": "prev_float", "namespace": "Float", "path": "Float#prev_float", "type": "instance_method", "visibility": "public"}, "Float#quo": {"description": "参见数字divmod。n \n   42.0.divmod(6)   #=> [7, 0.0]\n   42.0.divmod(5)   #=> [8, 2.0]", "name": "quo", "namespace": "Float", "path": "Float#quo", "type": "instance_method", "visibility": "public"}, "Float#rationalize": {"description": "返回<code>float / numeric</code>，与float/相同。", "name": "rationalize", "namespace": "Float", "path": "Float#rationalize", "type": "instance_method", "visibility": "public"}, "Float#round": {"description": "如果+float+是有效的IEEE浮点数，则返回+true+，即它不是无限的和浮动的n a n？是+false+。", "name": "round", "namespace": "Float", "path": "Float#round", "type": "instance_method", "visibility": "public"}, "Float#to_f": {"description": "返回小于或等于+float+的最大数字，精度为+ndigits+位小数（默认值：0）。\\n \\n当精度为负时，返回的值是一个整数，后面至少有<code>ndigits.abs</code>个零。\\n \\n当+ndigits+为正数时返回浮点数，否则返回整数。\\n \n   1.2.floor      #=> 1\n   2.0.floor      #=> 2\n   (-1.2).floor   #=> -2\n   (-2.0).floor   #=> -2\n\n   1.234567.floor(2)   #=> 1.23\n   1.234567.floor(3)   #=> 1.234\n   1.234567.floor(4)   #=> 1.2345\n   1.234567.floor(5)   #=> 1.23456\n102581 \\n请注意，浮点运算的有限精度可能会导致令人惊讶的结果：\\n \\n    (0.3 / 0.1).floor  #=> 2 (!)", "name": "to_f", "namespace": "Float", "path": "Float#to_f", "type": "instance_method", "visibility": "public"}, "Float#to_i": {"description": "根据值是有限的、<code>-Infinity</code>还是<code>+Infinity</code>，返回+nil+、-1或1。n \n   (0.0).infinite?        #=> nil\n   (-1.0/0.0).infinite?   #=> -1\n   (+1.0/0.0).infinite?   #=> 1", "name": "to_i", "namespace": "Float", "path": "Float#to_i", "type": "instance_method", "visibility": "public"}, "Float#to_int": {"description": "根据值是有限的、<code>-Infinity</code>还是<code>+Infinity</code>，返回+nil+、-1或1。n \n   (0.0).infinite?        #=> nil\n   (-1.0/0.0).infinite?   #=> -1\n   (+1.0/0.0).infinite?   #=> 1", "name": "to_int", "namespace": "Float", "path": "Float#to_int", "type": "instance_method", "visibility": "public"}, "Float#to_r": {"description": "返回一个包含+self+表示形式的字符串。\\n除了+float+的固定或指数形式之外，调用还可以返回+NaN+、+Infinity+和+-Infinity+。", "name": "to_r", "namespace": "Float", "path": "Float#to_r", "type": "instance_method", "visibility": "public"}, "Float#to_s": {"description": "返回绝对值+float+。\\n \n   (-34.56).abs   #=> 34.56\n   -34.56.abs     #=> 34.56\n   34.56.abs      #=> 34.56\n \\n float marize是float abs的别名。", "name": "inspect", "namespace": "Float", "path": "Float#inspect", "type": "instance_method", "visibility": "public"}, "Float#truncate": {"description": "时返回的模后用+other+ +float+分野。\n   6543.21.modulo(137)      #=> 104.21000000000004\n   6543.21.modulo(137.24)   #=> 92.92999999999961 \\n", "name": "truncate", "namespace": "Float", "path": "Float#truncate", "type": "instance_method", "visibility": "public"}, "Float#zero?": {"description": "+true+ +float+时返回，如果是一个无效的IEEE浮点数。\n   a = -1.0      #=> -1.0\n   a.nan?        #=> false\n   a = 0.0/0.0   #=> NaN\n   a.nan?        #=> true \\n", "name": "zero?", "namespace": "Float", "path": "Float#zero?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Float::DIG": {"description": "+true+ +float+时返回，如果是小于0。", "name": "DIG", "namespace": "Float", "path": "Float::DIG", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "Float::EPSILON": {"description": "时返回下一点表示的浮点数。\\n：浮：浮max.next _和浮：浮INFINITY.next _是浮INFINITY：：。。。。。。。\\n：浮：浮nan.next _是浮：南。\\n \\n for example：\n  0.01.next_float    #=> 0.010000000000000002\n  1.0.next_float     #=> 1.0000000000000002\n  100.0.next_float   #=> 100.00000000000001\n\n  0.01.next_float - 0.01     #=> 1.734723475976807e-18\n  1.0.next_float - 1.0       #=> 2.220446049250313e-16\n  100.0.next_float - 100.0   #=> 1.4210854715202004e-14\n\n  f = 0.01; 20.times { printf \"%-20a %s\\n\", f, f.to_s; f = f.next_float }\n  #=> 0x1.47ae147ae147bp-7 0.01\n  #   0x1.47ae147ae147cp-7 0.010000000000000002\n  #   0x1.47ae147ae147dp-7 0.010000000000000004\n  #   0x1.47ae147ae147ep-7 0.010000000000000005\n  #   0x1.47ae147ae147fp-7 0.010000000000000007\n  #   0x1.47ae147ae148p-7  0.010000000000000009\n  #   0x1.47ae147ae1481p-7 0.01000000000000001\n  #   0x1.47ae147ae1482p-7 0.010000000000000012\n  #   0x1.47ae147ae1483p-7 0.010000000000000014\n  #   0x1.47ae147ae1484p-7 0.010000000000000016\n  #   0x1.47ae147ae1485p-7 0.010000000000000018\n  #   0x1.47ae147ae1486p-7 0.01000000000000002\n  #   0x1.47ae147ae1487p-7 0.010000000000000021\n  #   0x1.47ae147ae1488p-7 0.010000000000000023\n  #   0x1.47ae147ae1489p-7 0.010000000000000024\n  #   0x1.47ae147ae148ap-7 0.010000000000000026\n  #   0x1.47ae147ae148bp-7 0.010000000000000028\n  #   0x1.47ae147ae148cp-7 0.01000000000000003\n  #   0x1.47ae147ae148dp-7 0.010000000000000031\n  #   0x1.47ae147ae148ep-7 0.010000000000000033\n\n  f = 0.0\n  100.times { f += 0.1 }\n  f                           #=> 9.99999999999998       # should be 10.0 in the ideal world.\n  10-f                        #=> 1.9539925233402755e-14 # the floating point error.\n  10.0.next_float-10          #=> 1.7763568394002505e-15 # 1 ulp (unit in the last place).\n  (10-f)/(10.0.next_float-10) #=> 11.0                   # the error is 11 ulp.\n  (10-f)/(10*Float::EPSILON)  #=> 8.8                    # approximation of the above.\n  \"%a\" % 10                   #=> \"0x1.4p+3\"\n  \"%a\" % f                    #=> \"0x1.3fffffffffff5p+3\" # the last hex digit is 5.  16 - 5 = 11 ulp.", "name": "EPSILON", "namespace": "Float", "path": "Float::EPSILON", "type": "constant", "return": ["Float", ""], "visibility": "public"}, "Float::INFINITY": {"description": "在numerator时返回。的结果是机械性的。\n   n = 0.3.numerator    #=> 5404319552844595\n   d = 0.3.denominator  #=> 18014398509481984\n   n.fdiv(d)            #=> 0.3\n \\n \\n看也# denominator浮。", "name": "INFINITY", "namespace": "Float", "path": "Float::INFINITY", "type": "constant", "return": ["Float", ""], "visibility": "public"}, "Float::MANT_DIG": {"description": "时返回0，如果是阳性的PI值，否则。。。。。。。", "name": "MANT_DIG", "namespace": "Float", "path": "Float::MANT_DIG", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "Float::MAX": {"description": "如果是+float+ +true+时返回大于0。", "name": "MAX", "namespace": "Float", "path": "Float::MAX", "type": "constant", "return": ["Float", ""], "visibility": "public"}, "Float::MAX_10_EXP": {"description": "时返回的以前的点表示的浮点数。\\n（浮：max）和.prev _浮子（浮：：INFINITY）是.prev _浮子浮INFINITY：：。。。。。。。\\n：浮：浮nan.prev _是浮：南。\\n \\n for example：\n  0.01.prev_float    #=> 0.009999999999999998\n  1.0.prev_float     #=> 0.9999999999999999\n  100.0.prev_float   #=> 99.99999999999999\n\n  0.01 - 0.01.prev_float     #=> 1.734723475976807e-18\n  1.0 - 1.0.prev_float       #=> 1.1102230246251565e-16\n  100.0 - 100.0.prev_float   #=> 1.4210854715202004e-14\n\n  f = 0.01; 20.times { printf \"%-20a %s\\n\", f, f.to_s; f = f.prev_float }\n  #=> 0x1.47ae147ae147bp-7 0.01\n  #   0x1.47ae147ae147ap-7 0.009999999999999998\n  #   0x1.47ae147ae1479p-7 0.009999999999999997\n  #   0x1.47ae147ae1478p-7 0.009999999999999995\n  #   0x1.47ae147ae1477p-7 0.009999999999999993\n  #   0x1.47ae147ae1476p-7 0.009999999999999992\n  #   0x1.47ae147ae1475p-7 0.00999999999999999\n  #   0x1.47ae147ae1474p-7 0.009999999999999988\n  #   0x1.47ae147ae1473p-7 0.009999999999999986\n  #   0x1.47ae147ae1472p-7 0.009999999999999985\n  #   0x1.47ae147ae1471p-7 0.009999999999999983\n  #   0x1.47ae147ae147p-7  0.009999999999999981\n  #   0x1.47ae147ae146fp-7 0.00999999999999998\n  #   0x1.47ae147ae146ep-7 0.009999999999999978\n  #   0x1.47ae147ae146dp-7 0.009999999999999976\n  #   0x1.47ae147ae146cp-7 0.009999999999999974\n  #   0x1.47ae147ae146bp-7 0.009999999999999972\n  #   0x1.47ae147ae146ap-7 0.00999999999999997\n  #   0x1.47ae147ae1469p-7 0.009999999999999969\n # 0x1.47ae147ae1468p-7 0.009999999999999967", "name": "MAX_10_EXP", "namespace": "Float", "path": "Float::MAX_10_EXP", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "Float::MAX_EXP": {"description": "<code>float / numeric</code>时返回，同为浮# /。。。。。。。", "name": "MAX_EXP", "namespace": "Float", "path": "Float::MAX_EXP", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "Float::MIN": {"description": "一种近似的simpler时返回的值（外语教学| EPS |＜n＜result = \\ = +在外语教学中的| EPS |）。如果可选argument +eps+诺特是给定的，则它将被自动选中。\n   0.3.rationalize          #=> (3/10)\n   1.333.rationalize        #=> (1333/1000)\n   1.333.rationalize(0.01)  #=> (4/3)\n \\n \\n看也#浮到_ R。。。。。。。", "name": "MIN", "namespace": "Float", "path": "Float::MIN", "type": "constant", "return": ["Float", ""], "visibility": "public"}, "Float::MIN_10_EXP": {"description": "+float+ ROUNDED时返回的值与最近一个精密+ndigits+小数位数（默认为0）。\\n\\n当精密是负的，在returned值是一个整数，与至少<code>ndigits.abs</code> trailing zeros。。。。。。。\\n\\n浮点数时返回一个点，当+ndigits+是阳性，则另有时返回的整数。\n   1.4.round      #=> 1\n   1.5.round      #=> 2\n   1.6.round      #=> 2\n   (-1.5).round   #=> -2\n\n   1.234567.round(2)   #=> 1.23\n   1.234567.round(3)   #=> 1.235\n   1.234567.round(4)   #=> 1.2346\n   1.234567.round(5)   #=> 1.23457\n\n   34567.89.round(-5)  #=> 0\n   34567.89.round(-4)  #=> 30000\n   34567.89.round(-3)  #=> 35000\n   34567.89.round(-2)  #=> 34600\n   34567.89.round(-1)  #=> 34570\n   34567.89.round(0)   #=> 34568\n   34567.89.round(1)   #=> 34567.9\n   34567.89.round(2)   #=> 34567.89\n   34567.89.round(3)   #=> 34567.89\n \\n \\n如果可选+half+关键字的argument是给定的数，这是半通之间的两个可能的值将被ROUNDED ROUNDED根据《道路specified破+方式+：\\n <code>:up</code> *或+ + nil：圆半消失从零（默认）\\n×<code>:down</code>：圆的半toward零\\n×<code>:even</code>：圆的半toward n最近数\n   2.5.round(half: :up)      #=> 3\n   2.5.round(half: :down)    #=> 2\n   2.5.round(half: :even)    #=> 2\n   3.5.round(half: :up)      #=> 4\n   3.5.round(half: :down)    #=> 3\n   3.5.round(half: :even)    #=> 4\n   (-2.5).round(half: :up)   #=> -3\n   (-2.5).round(half: :down) #=> -2\n   (-2.5).round(half: :even) #=> -2夏娃", "name": "MIN_10_EXP", "namespace": "Float", "path": "Float::MIN_10_EXP", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "Float::MIN_EXP": {"description": "由于+float+已经是一浮，+self+时返回。", "name": "MIN_EXP", "namespace": "Float", "path": "Float::MIN_EXP", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "Float::NAN": {"description": "在+float+截断时返回的整数。\n   1.2.to_i      #=> 1\n   (-1.2).to_i   #=> -1\n \\n \\n值得注意的是在有限的精密导线点浮到空中的可能结果的surprising：\\n \\n \n  (0.3 / 0.1).to_i  #=> 2 (!)\n #到_国际是一个别名的方法#到_ I。", "name": "NAN", "namespace": "Float", "path": "Float::NAN", "type": "constant", "return": ["Float", ""], "visibility": "public"}, "Float::RADIX": {"description": "在+float+截断时返回的整数。\n   1.2.to_i      #=> 1\n   (-1.2).to_i   #=> -1\n \\n \\n值得注意的是在有限的精密导线点浮到空中的可能结果的surprising：\\n \\n \n  (0.3 / 0.1).to_i  #=> 2 (!)\n #到_国际是一个别名的方法#到_ I。", "name": "RADIX", "namespace": "Float", "path": "Float::RADIX", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "Float::ROUNDS": {"description": "时返回的值作为一个理性的。\n   2.0.to_r    #=> (2/1)\n   2.5.to_r    #=> (5/2)\n   -0.75.to_r  #=> (-3/4)\n   0.0.to_r    #=> (0/1)\n   0.3.to_r    #=> (5404319552844595/18014398509481984)\n \\n \\n NOTE：0.3.to _ R T是同样为“0.3”.to _ R。在latter是等价的，“3月10日的“.to _ R，但原是T的SO。。。。。。。\n   0.3.to_r   == 3/10r  #=> false\n   \"0.3\".to_r == 3/10r  #=> true\n \\n \\n看也# rationalize浮。", "name": "ROUNDS", "namespace": "Float", "path": "Float::ROUNDS", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "Continuation": {"description": "时返回一个字符串的氟系+self+ A表示。\\n作为好作为一个不动点指数或形态的+float+，\\n呼叫可能回报+NaN+，+Infinity+，和+ + + + +∞。", "name": "Continuation", "namespace": "", "path": "Continuation", "type": "class", "visibility": "public"}, "Continuation#[]": {"description": "如果是+float+ +true+时返回0。", "name": "[]", "namespace": "Continuation", "path": "Continuation#[]", "type": "instance_method", "visibility": "public"}, "Continuation#call": {"description": "如果是+float+ +true+时返回0。", "name": "call", "namespace": "Continuation", "path": "Continuation#call", "type": "instance_method", "visibility": "public"}, "Fiber": {"description": "的最低人数重大的小数点位数在一个双精度浮点数的点。\\n\\n通常defaults到15。", "name": "Fiber", "namespace": "", "path": "Fiber", "type": "class", "visibility": "public"}, "Fiber#alive?": {"description": "1之间的差别和smallest双层精密浮点数大于1。\\n\\n通常defaults到2.2204460492503131e-16。。。。。。。", "name": "alive?", "namespace": "Fiber", "path": "Fiber#alive?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Fiber#initialize": {"description": ":nodoc:", "name": "initialize", "namespace": "Fiber", "path": "Fiber#initialize", "type": "instance_method", "visibility": "public"}, "Fiber#inspect": {"description": "整数的最大可能的在一个双精度浮点数的数量。\\n\\n通常defaults到1.7976931348623157e + 308。", "name": "inspect", "namespace": "Fiber", "path": "Fiber#inspect", "type": "instance_method", "visibility": "public"}, "Fiber#resume": {"description": "在数座位数的+double+数据类型。\\n\\n通常defaults至53。", "name": "resume", "namespace": "Fiber", "path": "Fiber#resume", "type": "instance_method", "visibility": "public"}, "Fiber#to_s": {"description": "整数的最大可能的在一个双精度浮点数的数量。\\n\\n通常defaults到1.7976931348623157e + 308。", "name": "inspect", "namespace": "Fiber", "path": "Fiber#inspect", "type": "instance_method", "visibility": "public"}, "Fiber#transfer": {"description": "“最大的阳性并且幂指数在一个双精度浮点数在10点提高到这个功率减1。\\n\\n通常defaults到308。", "name": "transfer", "namespace": "Fiber", "path": "Fiber#transfer", "type": "instance_method", "visibility": "public"}, "Fiber.current": {"description": "在最大的可能的值，并且幂指数在一个双精度浮点数。\\n\\n通常defaults到1024。", "name": "current", "namespace": "Fiber", "path": "Fiber.current", "type": "class_method", "visibility": "public"}, "Fiber.yield": {"description": "：分钟。\\n 0.0.next _浮时返回的smallest阳性浮点数包括化数。", "name": "yield", "namespace": "Fiber", "path": "Fiber.yield", "type": "class_method", "visibility": "public"}, "FiberError": {"description": "在smallest阴性并且幂指数在一个双精度浮点数在10点提高到这个功率减1。\\n\\n通常defaults到307。", "name": "FiberError", "namespace": "", "path": "FiberError", "type": "class", "visibility": "public"}, "Dir": {"description": "smallest可能并且幂指数的值在一个双精度浮点数。\\n\\n通常defaults至1021年。", "name": "Dir", "namespace": "", "path": "Dir", "type": "class", "visibility": "public"}, "Dir#close": {"description": "安的表达representing A值，这是“不一号”。", "name": "close", "namespace": "Dir", "path": "Dir#close", "type": "instance_method", "visibility": "public"}, "Dir#each": {"description": "在基地的浮点数的点，或独特的位数用来代表号。\\n\\n通常defaults二是最系统，这可能代表一个十进制小数点。", "name": "each", "namespace": "Dir", "path": "Dir#each", "type": "instance_method", "visibility": "public"}, "Dir#fileno": {"description": "1：：：：确定0 rounding对零：1：rounding的近邻数：2：对革兰氏阳性菌rounding∞3：rounding向负无穷大", "name": "fileno", "namespace": "Dir", "path": "Dir#fileno", "type": "instance_method", "visibility": "public"}, "Dir#initialize": {"description": "Continuation对象是由kernel callcc生成的，在having+require+d<i>Continuation之后。它们保存一个返回地址和执行上下文，允许从程序中的任何位置\\n非本地返回到<code>callcc</code>块的末尾。延续有点类似于C的<code>setjmp/longjmp</code>的结构化版本（尽管它们包含更多的状态，所以您可能认为它们更接近线程）。\\n \\n例如：\\n \n   require \"continuation\"\n   arr = [ \"Freddie\", \"Herbie\", \"Ron\", \"Max\", \"Ringo\" ]\n   callcc{|cc| $cc = cc}\n   puts(message = arr.shift)\n   $cc.call unless message =~ /Max/\n \\n<em>products:-\\n \n   Freddie\n   Herbie\n   Ron\n   Max\n \\n also you can callcc in other methods:\\n \n   require \"continuation\"\n+timeout+2669\n   f\n \\n this（some destruved）example allows the inner loop to abort \\n processing early:\\n \n   require \"continuation\"\n   callcc {|cont|\n     for i in 0..4\n       print \"\\n#{i}: \"\n       for j in i*5...(i+1)*5\n         cont.call() if j == 17\n         printf \"%3d\", j\n       end\n     end\n   }\n   puts\n \\n<em>products:-\\n \n   0:   0  1  2  3  4\n   1:   5  6  7  8  9\n   2:  10 11 12 13 14\n 3:15 16", "name": "initialize", "namespace": "Dir", "path": "Dir#initialize", "type": "instance_method", "visibility": "public"}, "Dir#inspect": {"description": "调用继续。程序从<code>callcc</code>块结束时继续。如果没有给出参数，则原始的<code>callcc</code>返回<code>nil</code>。如果给定一个参数，则<code>callcc</code>返回该参数。否则，将返回包含<i>args的数组。n \n   callcc {|cont|  cont.call }           #=> nil\n   callcc {|cont|  cont.call 1 }         #=> 1\n   callcc {|cont|  cont.call 1, 2, 3 }   #=> [1, 2, 3]", "name": "inspect", "namespace": "Dir", "path": "Dir#inspect", "type": "instance_method", "visibility": "public"}, "Dir#path": {"description": "返回当前光纤。在使用此方法之前，您需要<code>require 'fiber'</code> \\n。如果您没有在光纤的上下文中运行，此方法将返回根光纤。", "name": "path", "namespace": "Dir", "path": "Dir#path", "type": "instance_method", "visibility": "public"}, "Dir#pos": {"description": "将控制权转移到另一个光纤，从上次停止的位置恢复控制权，或者如果之前没有恢复控制权，则启动控制权。呼叫光纤将被挂起，就像在呼叫<code>Fiber.yield</code>时一样。在使用此方法之前，您需要<code>require 'fiber'</code> \\n。\\n \\n接收传输呼叫的光纤将其视为恢复呼叫。传递给传输的参数被视为传递给恢复的参数。\\n \\n无法恢复将控制权转移到另一个控制权的光纤。\\n这将导致双重恢复错误。你需要把控制权转移回这种纤维，然后它才能屈服和恢复。\\n \\n示例：\\n \n  fiber1 = Fiber.new do\n    puts \"In Fiber 1\"\n    Fiber.yield\n  end\n\n  fiber2 = Fiber.new do\n    puts \"In Fiber 2\"\n    fiber1.transfer\n    puts \"Never see this message\"\n  end\n\n  fiber3 = Fiber.new do\n    puts \"In Fiber 3\"\n  end\n\n  fiber2.resume\n  fiber3.resume\n \\n<em>products</em>\\n \n  In fiber 2\n  In fiber 1\n in fiber 3", "name": "pos", "namespace": "Dir", "path": "Dir#pos", "type": "instance_method", "visibility": "public"}, "Dir#pos=": {"description": "如果光纤仍然可以恢复（或传输到），则返回true。完成光纤块的执行后，此方法将始终返回false。在使用此方法之前，您需要<code>require 'fiber'</code> \\n。", "name": "pos=", "namespace": "Dir", "path": "Dir#pos=", "type": "instance_method", "visibility": "public"}, "Dir#read": {"description": "返回光纤信息字符串。", "name": "read", "namespace": "Dir", "path": "Dir#read", "type": "instance_method", "visibility": "public"}, "Dir#rewind": {"description": "从调用最后一个<code>Fiber.yield</code>的点恢复光纤，或者在第一次调用<code>resume</code>时开始运行光纤。传递给resume的参数将是<code>Fiber.yield</code>表达式的值，或者将作为块参数传递给fiber的块（如果这是第一个<code>resume</code>）。\\n \\n或者，当调用resume时，它计算传递给fiber块内的下一个<code>Fiber.yield</code>语句的参数，或者计算传递给块值的参数（如果在没有任何<code>Fiber.yield</code>的情况下运行到完成时）。", "name": "rewind", "namespace": "Dir", "path": "Dir#rewind", "type": "instance_method", "visibility": "public"}, "Dir#seek": {"description": "返回光纤信息字符串。", "name": "seek", "namespace": "Dir", "path": "Dir#seek", "type": "instance_method", "visibility": "public"}, "Dir#tell": {"description": "将控制权转移到另一个光纤，从上次停止的位置恢复控制权，或者如果之前没有恢复控制权，则启动控制权。呼叫光纤将被挂起，就像在呼叫<code>Fiber.yield</code>时一样。在使用此方法之前，您需要<code>require 'fiber'</code> \\n。\\n \\n接收传输呼叫的光纤将其视为恢复呼叫。传递给传输的参数被视为传递给恢复的参数。\\n \\n无法恢复将控制权转移到另一个控制权的光纤。\\n这将导致双重恢复错误。你需要把控制权转移回这种纤维，然后它才能屈服和恢复。\\n \\n示例：\\n \n  fiber1 = Fiber.new do\n    puts \"In Fiber 1\"\n    Fiber.yield\n  end\n\n  fiber2 = Fiber.new do\n    puts \"In Fiber 2\"\n    fiber1.transfer\n    puts \"Never see this message\"\n  end\n\n  fiber3 = Fiber.new do\n    puts \"In Fiber 3\"\n  end\n\n  fiber2.resume\n  fiber3.resume\n \\n<em>products</em>\\n \n  In fiber 2\n  In fiber 1\n in fiber 3", "name": "tell", "namespace": "Dir", "path": "Dir#tell", "type": "instance_method", "visibility": "public"}, "Dir#to_path": {"description": "返回当前光纤。在使用此方法之前，您需要<code>require 'fiber'</code> \\n。如果您没有在光纤的上下文中运行，此方法将返回根光纤。", "name": "to_path", "namespace": "Dir", "path": "Dir#to_path", "type": "instance_method", "visibility": "public"}, "Dir.[]": {"description": "将控制权返回到恢复光纤的上下文，并传递传递传递给光纤的所有参数。当下一个调用<code>resume</code>时，光纤将在此点恢复处理。\\n传递给下一个<code>resume</code>的任何参数都将是此<code>Fiber.yield</code>表达式计算得出的值。", "name": "[]", "namespace": "Dir", "path": "Dir.[]", "type": "class_method", "visibility": "public"}, "Dir.chdir": {"description": "在尝试对光纤执行无效操作时引发，特别是在尝试调用/恢复死掉的光纤、尝试从根光纤生成或跨线程调用光纤时。n \n   fiber = Fiber.new{}\n   fiber.resume #=> nil\n   fiber.resume #=> FiberError: dead fiber called", "name": "chdir", "namespace": "Dir", "path": "Dir.chdir", "type": "class_method", "visibility": "public"}, "Dir.children": {"description": "<code>Dir</code>类的对象是表示底层文件系统中目录的目录流。它们提供了多种方法来列出目录及其内容。另见<code>File</code>。\\n \\n这些示例中使用的目录包含两个常规文件（<code>config.h</code>和<code>main.rb</code>）、父目录（<code>..</code>）和目录本身\\n（<code>.</code>）。", "name": "children", "namespace": "Dir", "path": "Dir.children", "type": "class_method", "visibility": "public"}, "Dir.chroot": {"description": "关闭目录流。\\n自Ruby 2.3以来，在closed dir对象上调用此方法被忽略。n \n   d = Dir.new(\"testdir\")\n   d.close   #=> nil", "name": "chroot", "namespace": "Dir", "path": "Dir.chroot", "type": "class_method", "visibility": "public"}, "Dir.delete": {"description": "返回一个数组，该数组包含给定目录中除“.”、“n”和“..”之外的所有文件名。如果命名目录不存在，将引发一个<code>SystemCallError</code>。\\n \\n可选的<i>encoding</i>关键字参数指定目录的编码。如果未指定，则使用文件系统编码。\\n n    Dir.children(\"testdir\")   #=> [\"config.h\", \"main.rb\"]", "name": "delete", "namespace": "Dir", "path": "Dir.delete", "type": "class_method", "visibility": "public"}, "Dir.each_child": {"description": "返回<em>目录中使用的文件描述符。\\n \n   d = Dir.new(\"..\")\n   d.fileno   #=> 8\n \\n此方法使用POSIX 2008定义的dirfd（）函数。\\n NotImplementedError在其他平台（如Windows）上提升，但Windows不提供此功能。", "name": "each_child", "namespace": "Dir", "path": "Dir.each_child", "type": "class_method", "visibility": "public"}, "Dir.empty?": {"description": "返回命名目录的新目录对象。\\n \\n可选的<i>encoding</i>关键字参数指定目录的编码。\\n如果未指定，则使用文件系统编码。", "name": "empty?", "namespace": "Dir", "path": "Dir.empty?", "type": "class_method", "visibility": "public", "return": [["Boolean"], ""]}, "Dir.entries": {"description": "返回描述此dir对象的字符串。", "name": "entries", "namespace": "Dir", "path": "Dir.entries", "type": "class_method", "visibility": "public"}, "Dir.exist?": {"description": "返回传递给<em>dir的构造函数的path参数。n \n   d = Dir.new(\"..\")\n   d.path   #=> \"..\"", "name": "exist?", "namespace": "Dir", "path": "Dir.exist?", "type": "class_method", "visibility": "public", "return": [["Boolean"], ""]}, "Dir.exists?": {"description": "返回<em>dir中的当前位置。另见<code>Dir#seek</code>。n \n   d = Dir.new(\"testdir\")\n   d.tell   #=> 0\n   d.read   #=> \".\"\n   d.tell   #=> 12", "name": "exists?", "namespace": "Dir", "path": "Dir.exists?", "type": "class_method", "visibility": "public", "return": [["Boolean"], ""]}, "Dir.foreach": {"description": "与<code>Dir#seek</code>同义，但返回position参数。n \n   d = Dir.new(\"testdir\")   #=> #<Dir:0x401b3c40>\n   d.read                   #=> \".\"\n   i = d.pos                #=> 12\n   d.read                   #=> \"..\"\n   d.pos = i                #=> 12\n   d.read                   #=> \"..\"", "name": "foreach", "namespace": "Dir", "path": "Dir.foreach", "type": "class_method", "visibility": "public"}, "Dir.getwd": {"description": "相当于调用<code>Dir.glob([</code><i>string，…<i><code>], 0)</code>。", "name": "getwd", "namespace": "Dir", "path": "Dir.getwd", "type": "class_method", "visibility": "public"}, "Dir.glob": {"description": "重新定位到第一个条目。n \n   d = Dir.new(\"testdir\")\n   d.read     #=> \".\"\n   d.rewind   #=> #<Dir:0x401b3fb0>\n   d.read     #=> \".\"", "name": "glob", "namespace": "Dir", "path": "Dir.glob", "type": "class_method", "visibility": "public"}, "Dir.home": {"description": "在<em>目录中查找特定位置。<i>integer</i>\\n必须是<code>Dir#tell</code>返回的值。n \n   d = Dir.new(\"testdir\")   #=> #<Dir:0x401b3c40>\n   d.read                   #=> \".\"\n   i = d.tell               #=> 12\n   d.read                   #=> \"..\"\n   d.seek(i)                #=> #<Dir:0x401b3c40>\n   d.read                   #=> \"..\"", "name": "home", "namespace": "Dir", "path": "Dir.home", "type": "class_method", "visibility": "public"}, "Dir.mkdir": {"description": "返回<em>dir中的当前位置。另见<code>Dir#seek</code>。n \n   d = Dir.new(\"testdir\")\n   d.tell   #=> 0\n   d.read   #=> \".\"\n   d.tell   #=> 12", "name": "mkdir", "namespace": "Dir", "path": "Dir.mkdir", "type": "class_method", "visibility": "public"}, "Dir.open": {"description": "返回传递给<em>dir的构造函数的path参数。n \n   d = Dir.new(\"..\")\n   d.path   #=> \"..\"", "name": "open", "namespace": "Dir", "path": "Dir.open", "type": "class_method", "visibility": "public"}, "Dir.pwd": {"description": "相当于调用<code>Dir.glob([</code><i>string，…<i><code>], 0)</code>。", "name": "pwd", "namespace": "Dir", "path": "Dir.pwd", "type": "class_method", "visibility": "public"}, "Dir.rmdir": {"description": "返回一个数组，该数组包含给定目录中除“.”、“n”和“..”之外的所有文件名。如果命名目录不存在，将引发一个<code>SystemCallError</code>。\\n \\n可选的<i>encoding</i>关键字参数指定目录的编码。如果未指定，则使用文件系统编码。\\n n    Dir.children(\"testdir\")   #=> [\"config.h\", \"main.rb\"]", "name": "rmdir", "namespace": "Dir", "path": "Dir.rmdir", "type": "class_method", "visibility": "public"}, "Dir.unlink": {"description": "返回一个数组，该数组包含给定目录中除“.”、“n”和“..”之外的所有文件名。如果命名目录不存在，将引发一个<code>SystemCallError</code>。\\n \\n可选的<i>encoding</i>关键字参数指定目录的编码。如果未指定，则使用文件系统编码。\\n n    Dir.children(\"testdir\")   #=> [\"config.h\", \"main.rb\"]", "name": "unlink", "namespace": "Dir", "path": "Dir.unlink", "type": "class_method", "visibility": "public"}, "File": {"description": "更改此进程的文件系统根目录的概念。只有特权进程才能进行此调用。并非所有平台都可用。在UNIX系统上，有关详细信息，请参阅<code>chroot(2)</code>。", "name": "File", "namespace": "", "path": "File", "type": "class", "visibility": "public"}, "File#atime": {"description": "删除命名目录。如果目录不为空，则引发一个子类<code>SystemCallError</code>。", "name": "atime", "namespace": "File", "path": "File#atime", "type": "instance_method", "visibility": "public"}, "File#birthtime": {"description": "对命名目录中除“.”和“..”之外的每个条目调用一次块，并将每个条目的文件名作为参数传递给块。\\n \\n如果没有给定块，则返回枚举器。\\n \n   Dir.each_child(\"testdir\") {|x| puts \"Got #{x}\" }\n \\n<em>产生：.<em>\\n \n   Got config.h\n got main.rb", "name": "birthtime", "namespace": "File", "path": "File#birthtime", "type": "instance_method", "visibility": "public"}, "File#chmod": {"description": "如果命名文件是空目录，则返回<code>true</code>；如果命名文件不是目录或非空目录，则返回<code>false</code>。", "name": "chmod", "namespace": "File", "path": "File#chmod", "type": "instance_method", "visibility": "public"}, "File#chown": {"description": "返回包含给定目录中所有文件名的数组。如果命名目录不存在，将引发<code>SystemCallError</code>。\\n \\n可选的<i>encoding</i>关键字参数指定目录的编码。如果未指定，则使用文件系统编码。\\n n    Dir.entries(\"testdir\")   #=> [\".\", \"..\", \"config.h\", \"main.rb\"]", "name": "chown", "namespace": "File", "path": "File#chown", "type": "instance_method", "visibility": "public"}, "File#ctime": {"description": "如果命名文件是目录，则返回<code>true</code>，否则返回<code>false</code>。", "name": "ctime", "namespace": "File", "path": "File#ctime", "type": "instance_method", "visibility": "public"}, "File#flock": {"description": "已弃用的方法。不要使用。", "name": "flock", "namespace": "File", "path": "File#flock", "type": "instance_method", "visibility": "public"}, "File#initialize": {"description": "为命名目录中的每个条目调用一次块，将每个条目的文件名作为参数传递给块。\\n \\n如果没有给定块，则返回枚举器。\\n \n   Dir.foreach(\"testdir\") {|x| puts \"Got #{x}\" }\n \\n<em>products:->em>\\n \n   Got .\n   Got ..\n   Got config.h\n get main.rb", "name": "initialize", "namespace": "File", "path": "File#initialize", "type": "instance_method", "visibility": "public"}, "File#lstat": {"description": "以字符串形式返回此进程当前工作目录的路径。n \n   Dir.chdir(\"/tmp\")   #=> 0\n   Dir.getwd           #=> \"/tmp\"\n   Dir.pwd             #=> \"/tmp\"", "name": "lstat", "namespace": "File", "path": "File#lstat", "type": "instance_method", "visibility": "public"}, "File#mtime": {"description": "展开+pattern+，它是模式字符串或模式字符串数组，并返回包含匹配文件名的数组。\\n如果给定了块，则为每个匹配的文件名调用该块一次，并将文件名作为参数传递给该块。\\n \\n可选的+base+关键字参数指定用于解释相对路径名而不是当前工作目录的基目录。\\n由于在这种情况下，结果没有以基目录名作为前缀，因此如果需要真正的路径，则需要预先附加基目录名。\\n \\n请注意，模式不是regexp，它更接近shell glob。\\n有关+flags+参数的含义，请参阅文件：：fnmatch。\\n区分大小写取决于您的系统（忽略文件：：FNM_CASEFOLD），\\n返回结果的顺序也是如此。\\n \\n <code>*</code>:：\n  Matches any file. Can be restricted by other values in the glob.\n  Equivalent to <code>/ .* /x</code> in regexp.\n\n  <code>*</code>::     Matches all files\n  <code>c*</code>::    Matches all files beginning with <code>c</code>\n  <code>*c</code>::    Matches all files ending with <code>c</code>\n  <code>\\*c\\*</code>:: Match all files that have <code>c</code> in them\n                       (including at the beginning or end).\n\n  Note, this will not match Unix-like hidden files (dotfiles).  In order\n  to include those in the match results, you must use the\n  File::FNM_DOTMATCH flag or something like <code>\"{*,.*}\"</code>.\n \\n <code>**</code>:：\n  Matches directories recursively.\n \\n <code>?</code>:：\n  Matches any one character. Equivalent to <code>/.{1}/</code> in regexp.\n \\n <code>[set]</code>:：\n  Matches any one character in +set+.  Behaves exactly like character sets\n  in Regexp, including set negation (<code>[^a-z]</code>).\n \\n <code>{p,q}</code>:：\n  Matches either literal <code>p</code> or literal <code>q</code>.\n  Equivalent to pattern alternation in regexp.\n\n  Matching literals may be more than one character in length.  More than\n  two literals may be specified.\n \\n <code> \\\\ </code>:：\n  Escapes the next metacharacter.\n\n  Note that this means you cannot use backslash on windows as part of a\n  glob, i.e.  <code>Dir[\"c:\\\\foo*\"]</code> will not work, use\n  <code>Dir[\"c:/foo*\"]</code> instead.\n \\n示例：\\n \n   Dir[\"config.?\"]                     #=> [\"config.h\"]\n   Dir.glob(\"config.?\")                #=> [\"config.h\"]\n   Dir.glob(\"*.[a-z][a-z]\")            #=> [\"main.rb\"]\n   Dir.glob(\"*.[^r]*\")                 #=> [\"config.h\"]\n   Dir.glob(\"*.{rb,h}\")                #=> [\"main.rb\", \"config.h\"]\n   Dir.glob(\"*\")                       #=> [\"config.h\", \"main.rb\"]\n   Dir.glob(\"*\", File::FNM_DOTMATCH)   #=> [\".\", \"..\", \"config.h\", \"main.rb\"]\n\n   rbfiles = File.join(\"**\", \"*.rb\")\n   Dir.glob(rbfiles)                   #=> [\"main.rb\",\n                                       #    \"lib/song.rb\",\n                                       #    \"lib/song/karaoke.rb\"]\n\n   Dir.glob(rbfiles, base: \"lib\")      #=> [\"song.rb\",\n                                       #    \"song/karaoke.rb\"]\n\n   libdirs = File.join(\"**\", \"lib\")\n   Dir.glob(libdirs)                   #=> [\"lib\"]\n\n   librbfiles = File.join(\"**\", \"lib\", \"**\", \"*.rb\")\n   Dir.glob(librbfiles)                #=> [\"lib/song.rb\",\n                                       #    \"lib/song/karaoke.rb\"]\n\n   librbfiles = File.join(\"**\", \"lib\", \"*.rb\")\n   Dir.glob(librbfiles)                #=> [\"lib/song.rb\"]", "name": "mtime", "namespace": "File", "path": "File#mtime", "type": "instance_method", "visibility": "public"}, "File#path": {"description": "可选的关键字参数指定目录的编码。\\n如果未指定，则使用文件系统编码。\\n \\n如果没有块，<code>open</code>是<code>Dir::new</code>的同义词。如果存在块，则将其作为参数传递。目录在块的末尾关闭，<code>Dir::open</code>返回块的值。", "name": "path", "namespace": "File", "path": "File#path", "type": "instance_method", "visibility": "public"}, "File#size": {"description": "生成一个名为<i>string的新目录，其权限由可选参数<i>aninteger指定。权限可能被<code>File::umask</code>值修改，在NT上被忽略。如果无法创建目录，则引发<code>SystemCallError</code>。另请参见<code>File</code>类文档中的权限讨论。\\n n   Dir.mkdir(File.join(Dir.home, \".foo\"), 0700) #=> 0", "name": "size", "namespace": "File", "path": "File#size", "type": "instance_method", "visibility": "public"}, "File#to_path": {"description": "可选的关键字参数指定目录的编码。\\n如果未指定，则使用文件系统编码。\\n \\n如果没有块，<code>open</code>是<code>Dir::new</code>的同义词。如果存在块，则将其作为参数传递。目录在块的末尾关闭，<code>Dir::open</code>返回块的值。", "name": "to_path", "namespace": "File", "path": "File#to_path", "type": "instance_method", "visibility": "public"}, "File#truncate": {"description": "以字符串形式返回此进程当前工作目录的路径。n \n   Dir.chdir(\"/tmp\")   #=> 0\n   Dir.getwd           #=> \"/tmp\"\n   Dir.pwd             #=> \"/tmp\"", "name": "truncate", "namespace": "File", "path": "File#truncate", "type": "instance_method", "visibility": "public"}, "File.absolute_path": {"description": "删除命名目录。如果目录不为空，则引发一个子类<code>SystemCallError</code>。", "name": "absolute_path", "namespace": "File", "path": "File.absolute_path", "type": "class_method", "visibility": "public"}, "File.atime": {"description": "删除命名目录。如果目录不为空，则引发一个子类<code>SystemCallError</code>。", "name": "atime", "namespace": "File", "path": "File.atime", "type": "class_method", "visibility": "public"}, "File.basename": {"description": "<code>File</code>是程序可访问的任何文件对象的抽象，它与类<code>IO</code>密切相关。\\n <code>File</code>将模块<code>FileTest</code>的方法作为类方法包括在内，允许您编写（例如）<code>File.exist?(\"foo\")</code>。\\n \\n在文件方法的描述中，权限位是一组特定于平台的位，用于指示文件的权限。在基于Unix的系统上，权限被视为一组三个八位字节，供所有者、组和世界其他地方使用。对于这些实体中的每一个，权限都可以设置为读取、写入或执行文件：\\n\\n因此，权限位<code>0644</code>（八进制）将解释为所有者的读/写，以及组和其他的只读。高阶位还可用于指示文件类型（普通、目录、管道、套接字等）和其他各种特殊功能。如果权限用于目录，则可以搜索设置目录时执行位changes;的含义。\\n \\n在非POSIX操作系统上，可能只有使文件只读或读写的能力。在这种情况下，剩余的权限位将被合成为类似于典型值。例如，在WindowsNT上，默认的权限位是<code>0644</code>，这意味着对所有者的读/写，对所有其他人的读/写。唯一可以做的更改是使文件只读，报告为<code>0444</code>。\\n \\n在file:：constants中可以找到文件中方法的各种常量。", "name": "basename", "namespace": "File", "path": "File.basename", "type": "class_method", "visibility": "public"}, "File.birthtime": {"description": "返回上一次访问时间（一个<code>Time</code>对象），对于<i>file，如果<i>file，则返回epoch，如果<i>file，则返回epoch。\\n n    File.new(\"testfile\").atime   #=> Wed Dec 31 18:00:00 CST 1969", "name": "birthtime", "namespace": "File", "path": "File.birthtime", "type": "class_method", "visibility": "public"}, "File.chmod": {"description": "返回<i>文件的出生时间。\\n \n   File.new(\"testfile\").birthtime   #=> Wed Apr 09 08:53:14 CDT 2003\n \\n如果平台没有出生时间，则提升NotImplementedError。", "name": "chmod", "namespace": "File", "path": "File.chmod", "type": "class_method", "visibility": "public"}, "File.chown": {"description": "将<i>文件上的权限位更改为由<i>模式\\n int表示的位模式。实际效果是Unix系统上的平台dependent;，有关详细信息，请参阅<code>chmod(2)</code>。\\n遵循符号链接。另见<code>File#lchmod</code>。n \n   f = File.new(\"out\", \"w\");\n   f.chmod(0644)   #=> 0", "name": "chown", "namespace": "File", "path": "File.chown", "type": "class_method", "visibility": "public"}, "File.ctime": {"description": "将文件的所有者和组更改为给定的数字所有者和组ID。只有具有超级用户权限的进程才能更改文件的所有者。文件的当前所有者可以将文件的组更改为所有者所属的任何组。忽略\\n <code>nil</code>或-1所有者或组ID。遵循符号链接。另见<code>File#lchown</code>。\\n \\n file.new（“testfile”）.chown（502，1000）", "name": "ctime", "namespace": "File", "path": "File.ctime", "type": "class_method", "visibility": "public"}, "File.delete": {"description": "使用硬链接为现有文件创建新名称。如果已经存在，将不会覆盖<i>new_name</i>（引发一个子类<code>SystemCallError</code>）。并非所有平台都可用。n \n   File.link(\"testfile\", \".testfile\")   #=> 0\n   IO.readlines(\".testfile\")[0]         #=> \"This is line one\\n\"", "name": "delete", "namespace": "File", "path": "File.delete", "type": "class_method", "visibility": "public"}, "File.dirname": {"description": "根据下表中的值的逻辑值，锁定或解锁文件。\\n如果指定了<code>File::LOCK_NB</code>，则返回<code>false</code>，否则操作将被阻止。并非所有平台都可用。\\n \\n锁定常量（在类文件中）：\\n \n   LOCK_EX   | Exclusive lock. Only one process may hold an\n             | exclusive lock for a given file at a time.\n   ----------+------------------------------------------------\n   LOCK_NB   | Don't block when locking. May be combined\n             | with other lock options using logical or.\n   ----------+------------------------------------------------\n   LOCK_SH   | Shared lock. Multiple processes may each hold a\n             | shared lock for a given file at the same time.\n   ----------+------------------------------------------------\n   LOCK_UN   | Unlock.\n \\n示例：\\n \n   # update a counter using write lock\n   # don't use \"w\" because it truncates the file before lock.\n   File.open(\"counter\", File::RDWR|File::CREAT, 0644) {|f|\n     f.flock(File::LOCK_EX)\n     value = f.read.to_i + 1\n     f.rewind\n     f.write(\"#{value}\\n\")\n     f.flush\n     f.truncate(f.pos)\n   }\n\n   # read the counter using read lock\n   File.open(\"counter\", \"r\") {|f|\n     f.flock(File::LOCK_SH)\n     p f.read\n", "name": "dirname", "namespace": "File", "path": "File.dirname", "type": "class_method", "visibility": "public"}, "File.expand_path": {"description": "根据给定的+mode+打开名为+filename+的文件，并返回一个新的文件对象。\\n \\n有关+mode+和+opt+的描述，请参阅IO.new。\\n \\n如果正在创建文件，则可以在+perm+中提供权限位。这些模式和权限位是Unix系统上的平台dependent;，有关详细信息，请参阅open（2）和chmod（2）手册页。\\n \\n除非+filename+是TTY，否则新的文件对象是缓冲模式（或非同步模式）。\\n有关同步模式，请参阅IO flush、IO fsync、IO fdatasync和<code>IO#sync=</code>。\\n \\n==示例\n  f = File.new(\"testfile\", \"r\")\n  f = File.new(\"newfile\",  \"w+\")\n f=file.new（“NEW_FILE”，文件：：CREAT文件：：TRUNC文件：：RDWR，0644）", "name": "expand_path", "namespace": "File", "path": "File.expand_path", "type": "class_method", "visibility": "public"}, "File.extname": {"description": "与<code>IO#stat</code>相同，但不遵循最后一个符号链接。相反，报告链接本身。n \n   File.symlink(\"testfile\", \"link2test\")   #=> 0\n   File.stat(\"testfile\").size              #=> 66\n   f = File.new(\"link2test\")\n   f.lstat.size                            #=> 8\n   f.stat.size                             #=> 66", "name": "extname", "namespace": "File", "path": "File.extname", "type": "class_method", "visibility": "public"}, "File.fnmatch": {"description": "以字符串形式返回用于创建<i>文件的路径名。不规范化名称。\\n \\n路径名可能不指向与<i>文件对应的文件。例如，当文件被移动或删除时，路径名变为无效。\\n \\n此方法为使用<code>File::Constants::TMPFILE</code>创建的<i>文件引发<code>IOError</code>，因为它们没有路径名。n \n   File.new(\"testfile\").path               #=> \"testfile\"\n   File.new(\"/tmp/../tmp/xxx\", \"w\").path   #=> \"/tmp/../tmp/xxx\"", "name": "fnmatch", "namespace": "File", "path": "File.fnmatch", "type": "class_method", "visibility": "public"}, "File.fnmatch?": {"description": "以字符串形式返回用于创建<i>文件的路径名。不规范化名称。\\n \\n路径名可能不指向与<i>文件对应的文件。例如，当文件被移动或删除时，路径名变为无效。\\n \\n此方法为使用<code>File::Constants::TMPFILE</code>创建的<i>文件引发<code>IOError</code>，因为它们没有路径名。n \n   File.new(\"testfile\").path               #=> \"testfile\"\n   File.new(\"/tmp/../tmp/xxx\", \"w\").path   #=> \"/tmp/../tmp/xxx\"", "name": "fnmatch?", "namespace": "File", "path": "File.fnmatch?", "type": "class_method", "visibility": "public", "return": [["Boolean"], ""]}, "File.ftype": {"description": "返回<i>文件的大小（以字节为单位）。\\n n    File.new(\"testfile\").size   #=> 66", "name": "ftype", "namespace": "File", "path": "File.ftype", "type": "class_method", "visibility": "public"}, "File.join": {"description": "以字符串形式返回用于创建<i>文件的路径名。不规范化名称。\\n \\n路径名可能不指向与<i>文件对应的文件。例如，当文件被移动或删除时，路径名变为无效。\\n \\n此方法为使用<code>File::Constants::TMPFILE</code>创建的<i>文件引发<code>IOError</code>，因为它们没有路径名。n \n   File.new(\"testfile\").path               #=> \"testfile\"\n   File.new(\"/tmp/../tmp/xxx\", \"w\").path   #=> \"/tmp/../tmp/xxx\"", "name": "join", "namespace": "File", "path": "File.join", "type": "class_method", "visibility": "public"}, "File.lchmod": {"description": "截断<i>文件</i>至多为<i>整数</i>字节。必须打开该文件进行写入。并非所有平台都可用。n \n   f = File.new(\"out\", \"w\")\n   f.syswrite(\"1234567890\")   #=> 10\n   f.truncate(5)              #=> 0\n   f.close()                  #=> nil\n   File.size(\"out\")           #=> 5", "name": "lchmod", "namespace": "File", "path": "File.lchmod", "type": "class_method", "visibility": "public"}, "File.lchown": {"description": "将路径名转换为绝对路径名。相对路径是从进程的当前工作目录引用的，除非给出了\\n<i>dir_string<i>，在这种情况下，它将用作起点。如果给定的路径名以“<code>~</code>”开头，则不展开，它将被视为普通目录名。\\n n    File.absolute_path(\"~oracle/bin\")       #=> \"<relative_path>/~oracle/bin\"", "name": "lchown", "namespace": "File", "path": "File.lchown", "type": "class_method", "visibility": "public"}, "File.link": {"description": "以时间对象的形式返回命名文件的上次访问时间。\\n \\n文件名可以是IO对象。\\n n    File.atime(\"testfile\")   #=> Wed Apr 09 08:51:48 CDT 2003", "name": "link", "namespace": "File", "path": "File.link", "type": "class_method", "visibility": "public"}, "File.lstat": {"description": "返回文件名的最后一个组件（在第一个剥离尾随分隔符之后），当<code>File::ALT_SEPARATOR</code>不是<code>nil</code>时，可以使用<code>File::SEPARATOR</code>和<code>File::ALT_SEPARATOR</code>作为分隔符来形成。如果在<i>文件名的末尾给出并出现后缀</i>，\\n则删除该后缀。如果后缀<i>是“.*”，则将删除任何扩展名。n \n   File.basename(\"/home/gumby/work/ruby.rb\")          #=> \"ruby.rb\"\n   File.basename(\"/home/gumby/work/ruby.rb\", \".rb\")   #=> \"ruby\"\n   File.basename(\"/home/gumby/work/ruby.rb\", \".*\")    #=> \"ruby\"", "name": "lstat", "namespace": "File", "path": "File.lstat", "type": "class_method", "visibility": "public"}, "File.lutime": {"description": "返回命名文件的出生时间。\\n \\n文件名可以是IO对象。\\n \n   File.birthtime(\"testfile\")   #=> Wed Apr 09 08:53:13 CDT 2003\n \\n如果平台没有出生时间，则提升NotImplementedError。", "name": "lutime", "namespace": "File", "path": "File.lutime", "type": "class_method", "visibility": "public"}, "File.mkfifo": {"description": "将命名文件上的权限位更改为\\n由<i>模式\\u int表示的位模式。实际效果取决于操作系统（请参见本节开头部分）。在UNIX系统上，有关详细信息，请参阅<code>chmod(2)</code>。返回处理的文件数。\\n n    File.chmod(0644, \"testfile\", \"out\")   #=> 2", "name": "mkfifo", "namespace": "File", "path": "File.mkfifo", "type": "class_method", "visibility": "public"}, "File.mtime": {"description": "将命名文件的所有者和组更改为给定的数字所有者和组ID。只有具有超级用户权限的进程才能更改文件的所有者。文件的当前所有者可以将文件的组更改为所有者所属的任何组。将忽略<code>nil</code>或-1所有者或组ID。\\n返回处理的文件数。\\n \\n file.chown（nil，100，“测试文件”）", "name": "mtime", "namespace": "File", "path": "File.mtime", "type": "class_method", "visibility": "public"}, "File.open": {"description": "将<em>ios的状态信息作为<code>File::Stat</code>类型的对象返回。n \n   f = File.new(\"testfile\")\n   s = f.stat\n   \"%o\" % s.mode   #=> \"100644\"\n   s.blksize       #=> 4096\n   s.atime         #=> Wed Apr 09 08:53:54 CDT 2003", "name": "open", "namespace": "File", "path": "File.open", "type": "class_method", "visibility": "public"}, "File.path": {"description": "删除命名文件，返回作为参数传递的名称数。对任何错误引发异常。\\n由于基础实现依赖于<code>unlink(2)</code>系统调用，因此引发的异常类型取决于其错误类型（请参阅https://linux.die.net/man/2/unlink），其形式为<code>Errno::ENOENT</code>。\\n \\n另请参阅<code>Dir::rmdir</code>。", "name": "path", "namespace": "File", "path": "File.path", "type": "class_method", "visibility": "public"}, "File.readlink": {"description": "返回<i>file_name中给定的文件名的所有组件，除了最后一个组件（在第一个剥离尾随分隔符之后）。\\n当<code>File::ALT_SEPARATOR</code>不是<code>nil</code>时，可以使用<code>File::SEPARATOR</code>和<code>File::ALT_SEPARATOR</code>作为分隔符来形成文件名。\\n n    File.dirname(\"/home/gumby/work/ruby.rb\")   #=> \"/home/gumby/work\"", "name": "readlink", "namespace": "File", "path": "File.readlink", "type": "class_method", "visibility": "public"}, "File.realdirpath": {"description": "将路径名转换为绝对路径名。除非给出+dir_string+，否则从进程的当前工作目录引用相对路径，在这种情况下，它将用作起点。给定的路径名可以以“<code>~</code>”开头，它扩展到进程所有者的主目录（必须正确设置环境变量+HOME+）。``<code>~</code><i>user='i>''扩展到命名用户的主目录。\\n \n   File.expand_path(\"~oracle/bin\")           #=> \"/home/oracle/bin\"\n \\n使用+dir_string+的简单示例为follows.\n   File.expand_path(\"ruby\", \"/usr/bin\")      #=> \"/usr/bin/ruby\"\n \\n更复杂的示例也解析父目录，如下所示。\\n假设我们在bin/mygem中，需要lib/mygem.rb的绝对路径。\\n \n   File.expand_path(\"../../lib/mygem.rb\", __FILE__)\n   #=> \".../path/to/project/lib/mygem.rb\"\n \\n因此，首先解析__FILE__的父级，即bin/，然后转到父级，即项目的根，并附加+lib/mygem.rb+。", "name": "realdirpath", "namespace": "File", "path": "File.realdirpath", "type": "class_method", "visibility": "public"}, "File.realpath": {"description": "返回扩展名（+path+中文件名的一部分，从最后一个句点开始）。\\n \\n如果+path+是点文件，或以句点开头，则起始点不处理扩展名的起始点。\\n \\n当句点是+path+中的最后一个字符时，也将返回空字符串。n \n   File.extname(\"test.rb\")         #=> \".rb\"\n   File.extname(\"a/b/d/test.rb\")   #=> \".rb\"\n   File.extname(\".a/b/d/test.rb\")  #=> \".rb\"\n   File.extname(\"foo.\")            #=> \"\"\n   File.extname(\"test\")            #=> \"\"\n   File.extname(\".profile\")        #=> \"\"\n   File.extname(\".profile.sh\")     #=> \".sh\"", "name": "realpath", "namespace": "File", "path": "File.realpath", "type": "class_method", "visibility": "public"}, "File.rename": {"description": "如果+path+与+pattern+匹配，则返回true。该模式不是常规的expression;，而是遵循类似于shell文件名填充的规则。它可以包含以下元字符：\\n \\n <code>*</code>:：+path+4\n  <code>*</code>::    Matches all files regular files\n  <code>c*</code>::   Matches all files beginning with <code>c</code>\n  <code>*c</code>::   Matches all files ending with <code>c</code>\n  <code>\\*c*</code>:: Matches all files that have <code>c</code> in them\n                      (including at the beginning or end).\n\n  To match hidden files (that start with a <code>.</code> set the\n  File::FNM_DOTMATCH flag.\n \\n <code>**</code>:：\n  Matches directories recursively or files expansively.\n \\n <code>?</code>:：\n  Matches any one character. Equivalent to <code>/.{1}/</code> in regexp.\n \\n <code>[set]</code>:：\n  Matches any one character in +set+.  Behaves exactly like character sets\n  in Regexp, including set negation (<code>[^a-z]</code>).\n \\n <code> \\ </code>:：\n  Escapes the next metacharacter.\n \\n <code>{a,b}</code>:：\n  Matches pattern a and pattern b if File::FNM_EXTGLOB flag is enabled.\n  Behaves like a Regexp union (<code>(?:a|b)</code>).\n \\n +flags+是<code>FNM_XXX</code>常量的按位或。dir：：glob使用相同的glob模式和标志。\\n \\n范例：\\n \n   File.fnmatch('cat',       'cat')        #=> true  # match entire string\n   File.fnmatch('cat',       'category')   #=> false # only match partial string\n\n   File.fnmatch('c{at,ub}s', 'cats')                    #=> false # { } isn't supported by default\n   File.fnmatch('c{at,ub}s', 'cats', File::FNM_EXTGLOB) #=> true  # { } is supported on FNM_EXTGLOB\n\n   File.fnmatch('c?t',     'cat')          #=> true  # '?' match only 1 character\n   File.fnmatch('c??t',    'cat')          #=> false # ditto\n   File.fnmatch('c*',      'cats')         #=> true  # '*' match 0 or more characters\n   File.fnmatch('c*t',     'c/a/b/t')      #=> true  # ditto\n   File.fnmatch('ca[a-z]', 'cat')          #=> true  # inclusive bracket expression\n   File.fnmatch('ca[^t]',  'cat')          #=> false # exclusive bracket expression ('^' or '!')\n\n   File.fnmatch('cat', 'CAT')                     #=> false # case sensitive\n   File.fnmatch('cat', 'CAT', File::FNM_CASEFOLD) #=> true  # case insensitive\n\n   File.fnmatch('?',   '/', File::FNM_PATHNAME)  #=> false # wildcard doesn't match '/' on FNM_PATHNAME\n   File.fnmatch('*',   '/', File::FNM_PATHNAME)  #=> false # ditto\n   File.fnmatch('[/]', '/', File::FNM_PATHNAME)  #=> false # ditto\n\n   File.fnmatch('\\?',   '?')                       #=> true  # escaped wildcard becomes ordinary\n   File.fnmatch('\\a',   'a')                       #=> true  # escaped ordinary remains ordinary\n   File.fnmatch('\\a',   '\\a', File::FNM_NOESCAPE)  #=> true  # FNM_NOESCAPE makes '\\' ordinary\n   File.fnmatch('[\\?]', '?')                       #=> true  # can escape inside bracket expression\n\n   File.fnmatch('*',   '.profile')                      #=> false # wildcard doesn't match leading\n   File.fnmatch('*',   '.profile', File::FNM_DOTMATCH)  #=> true  # period by default.\n   File.fnmatch('.*',  '.profile')                      #=> true\n\n   rbfiles = '**' '/' '*.rb' # you don't have to do like this. just write in single string.\n   File.fnmatch(rbfiles, 'main.rb')                    #=> false\n   File.fnmatch(rbfiles, './main.rb')                  #=> false\n   File.fnmatch(rbfiles, 'lib/song.rb')                #=> true\n   File.fnmatch('**.rb', 'main.rb')                    #=> true\n   File.fnmatch('**.rb', './main.rb')                  #=> false\n   File.fnmatch('**.rb', 'lib/song.rb')                #=> true\n   File.fnmatch('*',           'dave/.profile')                      #=> true\n\n   pattern = '*' '/' '*'\n   File.fnmatch(pattern, 'dave/.profile', File::FNM_PATHNAME)  #=> false\n   File.fnmatch(pattern, 'dave/.profile', File::FNM_PATHNAME | File::FNM_DOTMATCH) #=> true\n\n   pattern = '**' '/' 'foo'\n   File.fnmatch(pattern, 'a/b/c/foo', File::FNM_PATHNAME)     #=> true\n   File.fnmatch(pattern, '/a/b/c/foo', File::FNM_PATHNAME)    #=> true\n   File.fnmatch(pattern, 'c:/a/b/c/foo', File::FNM_PATHNAME)  #=> true\n   File.fnmatch(pattern, 'a/.b/c/foo', File::FNM_PATHNAME)    #=> false\n   File.fnmatch(pattern, 'a/.b/c/foo', File::FNM_PATHNAME | File::FNM_DOTMATCH) #=> true", "name": "rename", "namespace": "File", "path": "File.rename", "type": "class_method", "visibility": "public"}, "File.split": {"description": "如果+path+与+pattern+匹配，则返回true。该模式不是常规的expression;，而是遵循类似于shell文件名填充的规则。它可以包含以下元字符：\\n \\n <code>*</code>:：\n  Matches any file. Can be restricted by other values in the glob.\n  Equivalent to <code>/ .* /x</code> in regexp.\n\n  <code>*</code>::    Matches all files regular files\n  <code>c*</code>::   Matches all files beginning with <code>c</code>\n  <code>*c</code>::   Matches all files ending with <code>c</code>\n  <code>\\*c*</code>:: Matches all files that have <code>c</code> in them\n                      (including at the beginning or end).\n\n  To match hidden files (that start with a <code>.</code> set the\n  File::FNM_DOTMATCH flag.\n \\n <code>**</code>:：\n  Matches directories recursively or files expansively.\n \\n <code>?</code>:：\n  Matches any one character. Equivalent to <code>/.{1}/</code> in regexp.\n \\n <code>[set]</code>:：\n  Matches any one character in +set+.  Behaves exactly like character sets\n  in Regexp, including set negation (<code>[^a-z]</code>).\n \\n <code> \\ </code>:：\n  Escapes the next metacharacter.\n \\n <code>{a,b}</code>:：\n  Matches pattern a and pattern b if File::FNM_EXTGLOB flag is enabled.\n  Behaves like a Regexp union (<code>(?:a|b)</code>).\n \\n +flags+是<code>FNM_XXX</code>常量的按位或。dir：：glob使用相同的glob模式和标志。\\n \\n范例：\\n \n   File.fnmatch('cat',       'cat')        #=> true  # match entire string\n   File.fnmatch('cat',       'category')   #=> false # only match partial string\n\n   File.fnmatch('c{at,ub}s', 'cats')                    #=> false # { } isn't supported by default\n   File.fnmatch('c{at,ub}s', 'cats', File::FNM_EXTGLOB) #=> true  # { } is supported on FNM_EXTGLOB\n\n   File.fnmatch('c?t',     'cat')          #=> true  # '?' match only 1 character\n   File.fnmatch('c??t',    'cat')          #=> false # ditto\n   File.fnmatch('c*',      'cats')         #=> true  # '*' match 0 or more characters\n   File.fnmatch('c*t',     'c/a/b/t')      #=> true  # ditto\n   File.fnmatch('ca[a-z]', 'cat')          #=> true  # inclusive bracket expression\n   File.fnmatch('ca[^t]',  'cat')          #=> false # exclusive bracket expression ('^' or '!')\n\n   File.fnmatch('cat', 'CAT')                     #=> false # case sensitive\n   File.fnmatch('cat', 'CAT', File::FNM_CASEFOLD) #=> true  # case insensitive\n\n   File.fnmatch('?',   '/', File::FNM_PATHNAME)  #=> false # wildcard doesn't match '/' on FNM_PATHNAME\n   File.fnmatch('*',   '/', File::FNM_PATHNAME)  #=> false # ditto\n   File.fnmatch('[/]', '/', File::FNM_PATHNAME)  #=> false # ditto\n\n   File.fnmatch('\\?',   '?')                       #=> true  # escaped wildcard becomes ordinary\n   File.fnmatch('\\a',   'a')                       #=> true  # escaped ordinary remains ordinary\n   File.fnmatch('\\a',   '\\a', File::FNM_NOESCAPE)  #=> true  # FNM_NOESCAPE makes '\\' ordinary\n   File.fnmatch('[\\?]', '?')                       #=> true  # can escape inside bracket expression\n\n   File.fnmatch('*',   '.profile')                      #=> false # wildcard doesn't match leading\n   File.fnmatch('*',   '.profile', File::FNM_DOTMATCH)  #=> true  # period by default.\n   File.fnmatch('.*',  '.profile')                      #=> true\n\n   rbfiles = '**' '/' '*.rb' # you don't have to do like this. just write in single string.\n   File.fnmatch(rbfiles, 'main.rb')                    #=> false\n   File.fnmatch(rbfiles, './main.rb')                  #=> false\n   File.fnmatch(rbfiles, 'lib/song.rb')                #=> true\n   File.fnmatch('**.rb', 'main.rb')                    #=> true\n   File.fnmatch('**.rb', './main.rb')                  #=> false\n   File.fnmatch('**.rb', 'lib/song.rb')                #=> true\n   File.fnmatch('*',           'dave/.profile')                      #=> true\n\n   pattern = '*' '/' '*'\n   File.fnmatch(pattern, 'dave/.profile', File::FNM_PATHNAME)  #=> false\n   File.fnmatch(pattern, 'dave/.profile', File::FNM_PATHNAME | File::FNM_DOTMATCH) #=> true\n\n   pattern = '**' '/' 'foo'\n   File.fnmatch(pattern, 'a/b/c/foo', File::FNM_PATHNAME)     #=> true\n   File.fnmatch(pattern, '/a/b/c/foo', File::FNM_PATHNAME)    #=> true\n   File.fnmatch(pattern, 'c:/a/b/c/foo', File::FNM_PATHNAME)  #=> true\n   File.fnmatch(pattern, 'a/.b/c/foo', File::FNM_PATHNAME)    #=> false\n   File.fnmatch(pattern, 'a/.b/c/foo', File::FNM_PATHNAME | File::FNM_DOTMATCH) #=> true", "name": "split", "namespace": "File", "path": "File.split", "type": "class_method", "visibility": "public"}, "File.stat": {"description": "标识命名的file;的类型。返回字符串是\\n``<code>file</code>'、``<code>directory</code>'、\\n``<code>characterSpecial</code>'、``<code>blockSpecial</code>'、\\n``<code>fifo</code>'、``<code>link</code>'、\\n``<code>socket</code>'或``<code>unknown</code>'之一。n \n   File.ftype(\"testfile\")            #=> \"file\"\n   File.ftype(\"/dev/tty\")            #=> \"characterSpecial\"\n   File.ftype(\"/tmp/.X11-unix/X0\")   #=> \"socket\"", "name": "stat", "namespace": "File", "path": "File.stat", "type": "class_method", "visibility": "public"}, "File.symlink": {"description": "返回通过使用<code>\"/\"</code>联接字符串而形成的新字符串。\\n n    File.join(\"usr\", \"mail\", \"gumby\")   #=> \"usr/mail/gumby\"", "name": "symlink", "namespace": "File", "path": "File.symlink", "type": "class_method", "visibility": "public"}, "File.truncate": {"description": "相当于<code>File::chmod</code>，但不遵循符号链接（因此它将更改与链接关联的权限，而不是链接引用的文件）。通常不可用。", "name": "truncate", "namespace": "File", "path": "File.truncate", "type": "class_method", "visibility": "public"}, "File.umask": {"description": "相当于<code>File::chown</code>，但不遵循符号链接（因此它将更改与链接关联的所有者，而不是链接引用的文件）。通常不可用。返回参数列表中的文件数。", "name": "umask", "namespace": "File", "path": "File.umask", "type": "class_method", "visibility": "public"}, "File.unlink": {"description": "使用硬链接为现有文件创建新名称。如果已经存在，将不会覆盖<i>new_name</i>（引发一个子类<code>SystemCallError</code>）。并非所有平台都可用。n \n   File.link(\"testfile\", \".testfile\")   #=> 0\n   IO.readlines(\".testfile\")[0]         #=> \"This is line one\\n\"", "name": "unlink", "namespace": "File", "path": "File.unlink", "type": "class_method", "visibility": "public"}, "File.utime": {"description": "与<code>File::stat</code>相同，但不遵循最后一个符号链接。相反，报告链接本身。n \n   File.symlink(\"testfile\", \"link2test\")   #=> 0\n   File.stat(\"testfile\").size              #=> 66\n   File.lstat(\"link2test\").size            #=> 8\n   File.stat(\"link2test\").size             #=> 66", "name": "utime", "namespace": "File", "path": "File.utime", "type": "class_method", "visibility": "public"}, "File::ALT_SEPARATOR": {"description": "将每个命名文件的访问和修改时间设置为前两个参数。如果文件是符号链接，则此方法将作用于链接本身，而不是其referent;，以实现反向行为，请参见file.utime。返回参数列表中的文件名数。", "name": "ALT_SEPARATOR", "namespace": "File", "path": "File::ALT_SEPARATOR", "type": "constant", "return": null, "visibility": "public"}, "File::Constants": {"description": "创建一个名为file_name的FIFO特殊文件。模式指定FIFO的权限。它是由进程的umask以通常的方式修改的：创建的文件的权限是\\n（模式&~umask）。", "name": "Constants", "namespace": "File", "path": "File::Constants", "type": "module", "visibility": "public"}, "File::Constants::APPEND": {"description": "将命名文件的修改时间作为时间对象返回。\\n \\n文件名可以是IO对象。\\n n    File.mtime(\"testfile\")   #=> Tue Apr 08 12:58:04 CDT 2003", "name": "APPEND", "namespace": "File::Constants", "path": "File::Constants::APPEND", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "File::Constants::BINARY": {"description": "call seq:\n   IO.open(fd, mode=\"r\" [, opt])                -> io\n   IO.open(fd, mode=\"r\" [, opt]) {|io| block }  -> obj\n \\n如果没有关联的块，<code>IO.open</code>是io.new的同义词。如果给定了可选代码块，它将作为参数传递+io+，并且在块终止时IO对象将自动关闭。\\n在此实例中，IO.open返回块的值。\\n \\n有关+fd+、+mode+和+opt+参数的说明，请参阅IO.new。", "name": "BINARY", "namespace": "File::Constants", "path": "File::Constants::BINARY", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "File::Constants::CREAT": {"description": "返回路径\n   File.path(\"/dev/null\")          #=> \"/dev/null\"\n   File.path(Pathname.new(\"/tmp\")) #=> \"/tmp\"的字符串表示形式", "name": "CREAT", "namespace": "File::Constants", "path": "File::Constants::CREAT", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "File::Constants::DIRECT": {"description": "返回给定链接引用的文件名。\\n并非所有平台都可用。n \n   File.symlink(\"testfile\", \"link2test\")   #=> 0\n   File.readlink(\"link2test\")              #=> \"testfile\"", "name": "DIRECT", "namespace": "File::Constants", "path": "File::Constants::DIRECT", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "File::Constants::DSYNC": {"description": "返回实际文件系统中路径名的实际（绝对）路径名。\\n真正的路径名不包含符号链接或无用的点。\\n \\n如果给定dir_string，它将用作解释相对路径名而不是当前目录的基本目录。\\n \\n实际路径名的最后一个组件可能不存在。", "name": "DSYNC", "namespace": "File::Constants", "path": "File::Constants::DSYNC", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "File::Constants::EXCL": {"description": "返回实际文件系统中不包含符号链接或无用点的路径名的实际（绝对）路径名。\\n \\n如果给定dir_string，它将用作解释相对路径名而不是当前目录的基本目录。\\n \\n调用此方法时，路径名的所有组件都必须存在。", "name": "EXCL", "namespace": "File::Constants", "path": "File::Constants::EXCL", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "File::Constants::LOCK_EX": {"description": "将给定文件重命名为新名称。如果无法重命名文件，则引发<code>SystemCallError</code>。\\n n    File.rename(\"afile\", \"afile.bak\")   #=> 0", "name": "LOCK_EX", "namespace": "File::Constants", "path": "File::Constants::LOCK_EX", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "File::Constants::LOCK_NB": {"description": "将给定的字符串拆分为目录和文件组件，并在两元素数组中返回它们。另见<code>File::dirname</code>和<code>File::basename</code>。\\n n    File.split(\"/home/gumby/.profile\")   #=> [\"/home/gumby\", \".profile\"]", "name": "LOCK_NB", "namespace": "File::Constants", "path": "File::Constants::LOCK_NB", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "File::Constants::LOCK_SH": {"description": "返回命名文件的<code>File::Stat</code>对象（请参见<code>File::Stat</code>）。\\n n    File.stat(\"testfile\").mtime   #=> Tue Apr 08 12:58:04 CDT 2003", "name": "LOCK_SH", "namespace": "File::Constants", "path": "File::Constants::LOCK_SH", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "File::Constants::LOCK_UN": {"description": "为现有文件创建名为“新名称”的符号链接\\n“旧名称”。在不支持符号链接的平台上引发\\n <code>NotImplemented</code>异常。\\n n    File.symlink(\"testfile\", \"link2test\")   #=> 0", "name": "LOCK_UN", "namespace": "File::Constants", "path": "File::Constants::LOCK_UN", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "File::Constants::NOATIME": {"description": "截断文件<i>file_name</i>至多为<i>integer</i>\\n bytes long。并非所有平台都可用。n \n   f = File.new(\"out\", \"w\")\n   f.write(\"1234567890\")     #=> 10\n   f.close                   #=> nil\n   File.truncate(\"out\", 5)   #=> 0\n   File.size(\"out\")          #=> 5", "name": "NOATIME", "namespace": "File::Constants", "path": "File::Constants::NOATIME", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "File::Constants::NOCTTY": {"description": "返回此进程的当前umask值。如果给定了可选参数，请将umask设置为该值并返回上一个值。umask值是从默认权限中减去的，因此<code>0222</code>的umask将使每个人都成为只读文件。n \n   File.umask(0006)   #=> 18\n   File.umask         #=> 6", "name": "NOCTTY", "namespace": "File::Constants", "path": "File::Constants::NOCTTY", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "File::Constants::NOFOLLOW": {"description": "删除命名文件，返回作为参数传递的名称数。对任何错误引发异常。\\n由于基础实现依赖于<code>unlink(2)</code>系统调用，因此引发的异常类型取决于其错误类型（请参阅https://linux.die.net/man/2/unlink），其形式为<code>Errno::ENOENT</code>。\\n \\n另请参阅<code>Dir::rmdir</code>。", "name": "NOFOLLOW", "namespace": "File::Constants", "path": "File::Constants::NOFOLLOW", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "File::Constants::NONBLOCK": {"description": "将每个命名文件的访问和修改时间设置为前两个参数。如果文件是symlink，则此方法作用于其引用，而不是链接itself;，以获取反向行为。请参见file.lutime。返回参数列表中的文件名数。", "name": "NONBLOCK", "namespace": "File::Constants", "path": "File::Constants::NONBLOCK", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "File::Constants::NULL": {"description": "平台专用替代分离器", "name": "NULL", "namespace": "File::Constants", "path": "File::Constants::NULL", "type": "constant", "return": ["String", ""], "visibility": "public"}, "File::Constants::RDONLY": {"description": "文件：：常量提供与文件相关的常量。文档中列出了所有可能的文件常量，但它们可能并不都存在于您的平台上。\\n \\n如果基础平台未定义常量，则未定义相应的Ruby常量。\\n \\n您的平台文档（例如man open（2））可能会描述更详细的信息。", "name": "RDONLY", "namespace": "File::Constants", "path": "File::Constants::RDONLY", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "File::Constants::RDWR": {"description": "每次写入时追加", "name": "RDWR", "namespace": "File::Constants", "path": "File::Constants::RDWR", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "File::Constants::RSYNC": {"description": "禁用行代码转换", "name": "RSYNC", "namespace": "File::Constants", "path": "File::Constants::RSYNC", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "File::Constants::SHARE_DELETE": {"description": "如果不存在，则创建文件", "name": "SHARE_DELETE", "namespace": "File::Constants", "path": "File::Constants::SHARE_DELETE", "type": "constant", "return": null, "visibility": "public"}, "File::Constants::SYNC": {"description": "尝试最小化与此文件之间的I/O缓存效果。", "name": "SYNC", "namespace": "File::Constants", "path": "File::Constants::SYNC", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "File::Constants::TMPFILE": {"description": "除某些元数据外，任何写入操作都会同步执行。", "name": "TMPFILE", "namespace": "File::Constants", "path": "File::Constants::TMPFILE", "type": "constant", "return": null, "visibility": "public"}, "File::Constants::TRUNC": {"description": "如果CREAT和文件存在，则出错", "name": "TRUNC", "namespace": "File::Constants", "path": "File::Constants::TRUNC", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "File::Constants::WRONLY": {"description": "专用锁。参见文件", "name": "WRONLY", "namespace": "File::Constants", "path": "File::Constants::WRONLY", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "File::PATH_SEPARATOR": {"description": "无阻塞锁。用于LOCK_SH或LOCK_EX。参见文件", "name": "PATH_SEPARATOR", "namespace": "File", "path": "File::PATH_SEPARATOR", "type": "constant", "return": ["String", ""], "visibility": "public"}, "File::SEPARATOR": {"description": "", "name": "SEPARATOR", "namespace": "File", "path": "File::SEPARATOR", "type": "constant", "return": ["String", ""], "visibility": "public"}, "File::Separator": {"description": "共享锁。参见文件", "name": "Separator", "namespace": "File", "path": "File::Separator", "type": "constant", "return": ["String", ""], "visibility": "public"}, "File::Stat": {"description": "解锁。参见文件", "name": "Stat", "namespace": "File", "path": "File::Stat", "type": "class", "visibility": "public"}, "File::Stat#<=>": {"description": "Linux", "name": "<=>", "namespace": "File::Stat", "path": "File::Stat#<=>", "type": "instance_method", "visibility": "public"}, "File::Stat#atime": {"description": "不使打开的IO成为控制终端设备", "name": "atime", "namespace": "File::Stat", "path": "File::Stat#atime", "type": "instance_method", "visibility": "public"}, "File::Stat#birthtime": {"description": "FreeBSD，Linux", "name": "birthtime", "namespace": "File::Stat", "path": "File::Stat#birthtime", "type": "instance_method", "visibility": "public"}, "File::Stat#blksize": {"description": "不阻止打开或使数据可用", "name": "blksize", "namespace": "File::Stat", "path": "File::Stat#blksize", "type": "instance_method", "visibility": "public"}, "File::Stat#blockdev?": {"description": "空设备的名称", "name": "blockdev?", "namespace": "File::Stat", "path": "File::Stat#blockdev?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "File::Stat#blocks": {"description": "仅供阅读", "name": "blocks", "namespace": "File::Stat", "path": "File::Stat#blocks", "type": "instance_method", "visibility": "public"}, "File::Stat#chardev?": {"description": "开放阅读和写作", "name": "chardev?", "namespace": "File::Stat", "path": "File::Stat#chardev?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "File::Stat#ctime": {"description": "任何读取操作都会同步执行。用于SYNC或DSYNC。", "name": "ctime", "namespace": "File::Stat", "path": "File::Stat#ctime", "type": "instance_method", "visibility": "public"}, "File::Stat#dev": {"description": "可以删除打开的文件", "name": "dev", "namespace": "File::Stat", "path": "File::Stat#dev", "type": "instance_method", "visibility": "public"}, "File::Stat#dev_major": {"description": "任何写入操作都同步执行", "name": "dev_major", "namespace": "File::Stat", "path": "File::Stat#dev_major", "type": "instance_method", "visibility": "public"}, "File::Stat#dev_minor": {"description": "创建未命名的临时文件", "name": "dev_minor", "namespace": "File::Stat", "path": "File::Stat#dev_minor", "type": "instance_method", "visibility": "public"}, "File::Stat#directory?": {"description": "将大小截断为0", "name": "directory?", "namespace": "File::Stat", "path": "File::Stat#directory?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "File::Stat#executable?": {"description": "只供书写用", "name": "executable?", "namespace": "File::Stat", "path": "File::Stat#executable?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "File::Stat#executable_real?": {"description": "路径列表分隔符", "name": "executable_real?", "namespace": "File::Stat", "path": "File::Stat#executable_real?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "File::Stat#file?": {"description": "在路径中分隔目录部分", "name": "file?", "namespace": "File::Stat", "path": "File::Stat#file?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "File::Stat#ftype": {"description": "类<code>File::Stat</code>的对象封装了<code>File</code>对象的公共状态信息。当<code>File::Stat</code>对象为created;时，在该点之后对文件所做的更改将不会反映出来，此时将记录该信息。<code>File::Stat</code>对象由<code>IO#stat</code>、<code>File::stat</code>、<code>File#lstat</code>和<code>File::lstat</code>返回。其中许多方法返回平台特定的值，并不是所有值都对所有系统有意义。另见<code>Kernel#test</code>。", "name": "ftype", "namespace": "File::Stat", "path": "File::Stat#ftype", "type": "instance_method", "visibility": "public"}, "File::Stat#gid": {"description": "通过比较文件：：stat对象各自的修改次数来比较它们。\\n \\n如果+other_stat+不是文件，则返回+nil+：：stat对象\n   f1 = File.new(\"f1\", \"w\")\n   sleep 1\n   f2 = File.new(\"f2\", \"w\")\n   f1.stat <=> f2.stat   #=> -1", "name": "gid", "namespace": "File::Stat", "path": "File::Stat#gid", "type": "instance_method", "visibility": "public"}, "File::Stat#grpowned?": {"description": "以<code>Time</code>类对象的形式返回此文件的上次访问时间。\\n n    File.stat(\"testfile\").atime   #=> Wed Dec 31 18:00:00 CST 1969", "name": "grpowned?", "namespace": "File::Stat", "path": "File::Stat#grpowned?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "File::Stat#initialize": {"description": "返回<i>stat<i>的出生时间。\\n \\n如果平台没有出生时间，则提升NotImplementedError。n \n   File.write(\"testfile\", \"foo\")\n   sleep 10\n   File.write(\"testfile\", \"bar\")\n   sleep 10\n   File.chmod(0644, \"testfile\")\n   sleep 10\n   File.read(\"testfile\")\n   File.stat(\"testfile\").birthtime   #=> 2014-02-24 11:19:17 +0900\n   File.stat(\"testfile\").mtime       #=> 2014-02-24 11:19:27 +0900\n   File.stat(\"testfile\").ctime       #=> 2014-02-24 11:19:37 +0900\n   File.stat(\"testfile\").atime       #=> 2014-02-24 11:19:47 +0900", "name": "initialize", "namespace": "File::Stat", "path": "File::Stat#initialize", "type": "instance_method", "visibility": "public"}, "File::Stat#initialize_copy": {"description": ":nodoc:", "name": "initialize_copy", "namespace": "File::Stat", "path": "File::Stat#initialize_copy", "type": "instance_method", "visibility": "public"}, "File::Stat#ino": {"description": "返回本机文件系统的块大小。将在不支持此信息的平台上返回<code>nil</code>。\\n n    File.stat(\"testfile\").blksize   #=> 4096", "name": "ino", "namespace": "File::Stat", "path": "File::Stat#ino", "type": "instance_method", "visibility": "public"}, "File::Stat#inspect": {"description": "如果文件是块设备，则返回<code>true</code>；如果文件不是块设备，则返回<code>false</code>；如果操作系统不支持此功能，则返回<code>false</code>。n \n   File.stat(\"testfile\").blockdev?    #=> false\n   File.stat(\"/dev/hda1\").blockdev?   #=> true", "name": "inspect", "namespace": "File::Stat", "path": "File::Stat#inspect", "type": "instance_method", "visibility": "public"}, "File::Stat#mode": {"description": "返回为此文件分配的本机文件系统块的数目，如果操作系统不支持此功能，则返回<code>nil</code>。\\n n    File.stat(\"testfile\").blocks   #=> 2", "name": "mode", "namespace": "File::Stat", "path": "File::Stat#mode", "type": "instance_method", "visibility": "public"}, "File::Stat#mtime": {"description": "如果文件是字符设备，则返回<code>true</code>；如果文件不是字符设备，则返回<code>false</code>；如果操作系统不支持此功能，则返回<code>false</code>。\\n n    File.stat(\"/dev/tty\").chardev?   #=> true", "name": "mtime", "namespace": "File::Stat", "path": "File::Stat#mtime", "type": "instance_method", "visibility": "public"}, "File::Stat#nlink": {"description": "返回<i>stat的更改时间（即，有关文件的时间目录信息已更改，而不是文件本身）。\\n \\n请注意，在Windows（NTFS）上，返回创建时间（出生时间）。\\n n    File.stat(\"testfile\").ctime   #=> Wed Apr 09 08:53:14 CDT 2003", "name": "nlink", "namespace": "File::Stat", "path": "File::Stat#nlink", "type": "instance_method", "visibility": "public"}, "File::Stat#owned?": {"description": "返回一个整数，表示<i>stat存在的设备。\\n n    File.stat(\"testfile\").dev   #=> 774", "name": "owned?", "namespace": "File::Stat", "path": "File::Stat#owned?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "File::Stat#pipe?": {"description": "返回<code>File_Stat#dev</code>或<code>nil</code>的主要部分。n \n   File.stat(\"/dev/fd1\").dev_major   #=> 2\n   File.stat(\"/dev/tty\").dev_major   #=> 5", "name": "pipe?", "namespace": "File::Stat", "path": "File::Stat#pipe?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "File::Stat#rdev": {"description": "返回<code>File_Stat#dev</code>或<code>nil</code>的次要部分。n \n   File.stat(\"/dev/fd1\").dev_minor   #=> 1\n   File.stat(\"/dev/tty\").dev_minor   #=> 0", "name": "rdev", "namespace": "File::Stat", "path": "File::Stat#rdev", "type": "instance_method", "visibility": "public"}, "File::Stat#rdev_major": {"description": "如果是目录，则返回<code>true</code>，否则返回<code>false</code>。n \n   File.stat(\"testfile\").directory?   #=> false\n   File.stat(\".\").directory?          #=> true", "name": "rdev_major", "namespace": "File::Stat", "path": "File::Stat#rdev_major", "type": "instance_method", "visibility": "public"}, "File::Stat#rdev_minor": {"description": "如果可执行或操作系统不区分可执行文件和不可执行文件，则返回<code>true</code>。使用流程的有效所有者进行测试。\\n n    File.stat(\"testfile\").executable?   #=> false", "name": "rdev_minor", "namespace": "File::Stat", "path": "File::Stat#rdev_minor", "type": "instance_method", "visibility": "public"}, "File::Stat#readable?": {"description": "与<code>executable?</code>相同，但使用进程的实际所有者进行测试。", "name": "readable?", "namespace": "File::Stat", "path": "File::Stat#readable?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "File::Stat#readable_real?": {"description": "如果<i>stat<i>is a regular file（not a device file，pipe，socket，etc.），则返回<code>true</code>。\\n\\n    File.stat(\"testfile\").file?   #=> true", "name": "readable_real?", "namespace": "File::Stat", "path": "File::Stat#readable_real?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "File::Stat#setgid?": {"description": "标识<i>stat<i>的类型。返回字符串是以下字符串之一：\\n``<code>file</code>'、``<code>directory</code>'、\\n``<code>characterSpecial</code>'、``<code>blockSpecial</code>'、\\n``<code>fifo</code>'、``<code>link</code>'、\\n``<code>socket</code>'或``<code>unknown</code>'。\\n\\n    File.stat(\"/dev/tty\").ftype   #=> \"characterSpecial\"", "name": "setgid?", "namespace": "File::Stat", "path": "File::Stat#setgid?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "File::Stat#setuid?": {"description": "返回<i>stat>所有者的数字组ID。\\n\\n    File.stat(\"testfile\").gid   #=> 500", "name": "setuid?", "namespace": "File::Stat", "path": "File::Stat#setuid?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "File::Stat#size": {"description": "为给定的文件名创建一个文件：：stat对象（如果该文件不存在，则引发\\n异常）。", "name": "size", "namespace": "File::Stat", "path": "File::Stat#size", "type": "instance_method", "visibility": "public"}, "File::Stat#size?": {"description": "为给定的文件名创建一个文件：：stat对象（如果该文件不存在，则引发\\n异常）。", "name": "size?", "namespace": "File::Stat", "path": "File::Stat#size?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "File::Stat#socket?": {"description": "返回<i>stat的inode编号。\\n\\n    File.stat(\"testfile\").ino   #=> 1083669", "name": "socket?", "namespace": "File::Stat", "path": "File::Stat#socket?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "File::Stat#sticky?": {"description": "生成格式良好的<i>stat<i>描述。\\n \n  File.stat(\"/etc/passwd\").inspect\n     #=> \"#<File::Stat dev=0xe000005, ino=1078078, mode=0100644,\n     #    nlink=1, uid=0, gid=0, rdev=0x0, size=1374, blksize=4096,\n     #    blocks=8, atime=Wed Dec 10 10:16:12 CST 2003,\n     #    mtime=Fri Sep 12 15:41:41 CDT 2003,\n     #    ctime=Mon Oct 27 11:20:27 CST 2003,\n出生时间=周一8月04日08:13:49 CDT 2003>", "name": "sticky?", "namespace": "File::Stat", "path": "File::Stat#sticky?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "File::Stat#symlink?": {"description": "返回表示stat的权限位的整数。位的含义是unix系统上的平台dependent;，请参阅<code>stat(2)</code>。\\n \n   File.chmod(0644, \"testfile\")   #=> 1\n   s = File.stat(\"testfile\")\n   sprintf(\"%o\", s.mode)          #=> \"100644\"", "name": "symlink?", "namespace": "File::Stat", "path": "File::Stat#symlink?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "File::Stat#uid": {"description": "返回<i>stat<i>的修改时间。\\n\\n    File.stat(\"testfile\").mtime   #=> Wed Apr 09 08:53:14 CDT 2003", "name": "uid", "namespace": "File::Stat", "path": "File::Stat#uid", "type": "instance_method", "visibility": "public"}, "File::Stat#world_readable?": {"description": "将硬链接数返回到<i>stat。\\n \n   File.stat(\"testfile\").nlink             #=> 1\n   File.link(\"testfile\", \"testfile.bak\")   #=> 0\n   File.stat(\"testfile\").nlink             #=> 2", "name": "world_readable?", "namespace": "File::Stat", "path": "File::Stat#world_readable?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "File::Stat#world_writable?": {"description": "如果进程的有效用户ID与<i>stat的所有者相同，则返回<code>true</code>。\\n \n   File.stat(\"testfile\").owned?      #=> true\n   File.stat(\"/etc/passwd\").owned?   #=> false", "name": "world_writable?", "namespace": "File::Stat", "path": "File::Stat#world_writable?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "File::Stat#writable?": {"description": "如果操作系统支持管道，则返回<code>true</code>，否则\\n<i>stat<i>is a pipe; <code>false</code>。", "name": "writable?", "namespace": "File::Stat", "path": "File::Stat#writable?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "File::Stat#writable_real?": {"description": "返回表示设备类型的整数，该设备类型\\n<i>stat<i>如果操作系统不支持此功能，则返回<code>nil</code>。\\n \n   File.stat(\"/dev/fd1\").rdev   #=> 513\n   File.stat(\"/dev/tty\").rdev   #=> 1280", "name": "writable_real?", "namespace": "File::Stat", "path": "File::Stat#writable_real?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "File::Stat#zero?": {"description": "返回<code>File_Stat#rdev</code>或<code>nil</code>的主要部分。\\n \n   File.stat(\"/dev/fd1\").rdev_major   #=> 2\n   File.stat(\"/dev/tty\").rdev_major   #=> 5", "name": "zero?", "namespace": "File::Stat", "path": "File::Stat#zero?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Encoding": {"description": "返回<code>File_Stat#rdev</code>或<code>nil</code>的次要部分。\\n \n   File.stat(\"/dev/fd1\").rdev_minor   #=> 1\n   File.stat(\"/dev/tty\").rdev_minor   #=> 0", "name": "Encoding", "namespace": "", "path": "Encoding", "type": "class", "visibility": "public"}, "Encoding#_dump": {"description": ":nodoc:", "name": "_dump", "namespace": "Encoding", "path": "Encoding#_dump", "type": "instance_method", "visibility": "public"}, "Encoding#ascii_compatible?": {"description": "如果此进程的有效用户ID可读，则返回<code>true</code>。\\n\\n    File.stat(\"testfile\").readable?   #=> true", "name": "ascii_compatible?", "namespace": "Encoding", "path": "Encoding#ascii_compatible?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Encoding#dummy?": {"description": "如果此进程的实际用户ID可读，则返回<code>true</code>。\\n\\n    File.stat(\"testfile\").readable_real?   #=> true", "name": "dummy?", "namespace": "Encoding", "path": "Encoding#dummy?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Encoding#inspect": {"description": "如果设置了set group id permission位，则返回<code>true</code>；否则返回<code>false</code>；如果操作系统不支持此功能，则返回<code>false</code>。\\n\\n    File.stat(\"/usr/sbin/lpc\").setgid?   #=> true", "name": "inspect", "namespace": "Encoding", "path": "Encoding#inspect", "type": "instance_method", "visibility": "public"}, "Encoding#name": {"description": "如果<i>stat<i>is a socket，则返回<code>true</code>；如果不是，则返回<code>false</code>；如果操作系统不支持此功能，则返回<code>false</code>。\\n\\n    File.stat(\"testfile\").socket?   #=> false", "name": "name", "namespace": "Encoding", "path": "Encoding#name", "type": "instance_method", "visibility": "public"}, "Encoding#names": {"description": "返回<i>stat<i>的大小（以字节为单位）。\\n\\n    File.stat(\"testfile\").size   #=> 66", "name": "names", "namespace": "Encoding", "path": "Encoding#names", "type": "instance_method", "visibility": "public"}, "Encoding#replicate": {"description": "返回<i>stat<i>的大小（以字节为单位）。\\n\\n    File.stat(\"testfile\").size   #=> 66", "name": "replicate", "namespace": "Encoding", "path": "Encoding#replicate", "type": "instance_method", "visibility": "public"}, "Encoding#to_s": {"description": "如果<i>stat<i>is a socket，则返回<code>true</code>；如果不是，则返回<code>false</code>；如果操作系统不支持此功能，则返回<code>false</code>。\\n\\n    File.stat(\"testfile\").socket?   #=> false", "name": "to_s", "namespace": "Encoding", "path": "Encoding#to_s", "type": "instance_method", "visibility": "public"}, "Encoding._load": {"description": ":nodoc:", "name": "_load", "namespace": "Encoding", "path": "Encoding._load", "type": "class_method", "visibility": "public"}, "Encoding.aliases": {"description": "如果<i>stat<i>has its sticky bit set，则返回<code>true</code>；否则返回<code>false</code>；如果操作系统不支持此功能，则返回<code>false</code>。\\n\\n    File.stat(\"testfile\").sticky?   #=> false", "name": "aliases", "namespace": "Encoding", "path": "Encoding.aliases", "type": "class_method", "visibility": "public"}, "Encoding.compatible?": {"description": "如果<i>stat<i>是符号链接，则返回<code>true</code>；如果不是符号链接，则返回<code>false</code>；如果操作系统不支持此功能，则返回<code>false</code>。由于<code>File::stat</code>自动跟随符号链接，对于<code>File::stat</code>返回的对象，<code>symlink?</code>始终是<code>false</code>。\\n \n   File.symlink(\"testfile\", \"alink\")   #=> 0\n   File.stat(\"alink\").symlink?         #=> false\n   File.lstat(\"alink\").symlink?        #=> true", "name": "compatible?", "namespace": "Encoding", "path": "Encoding.compatible?", "type": "class_method", "visibility": "public", "return": [["Boolean"], ""]}, "Encoding.default_external": {"description": "返回<i>stat>所有者的数字用户ID。\\n\\n    File.stat(\"testfile\").uid   #=> 501", "name": "default_external", "namespace": "Encoding", "path": "Encoding.default_external", "type": "class_method", "visibility": "public"}, "Encoding.default_external=": {"description": "如果其他人可以读取<i>stat，则返回一个整数，表示<i>stat的文件权限位。否则返回<code>nil</code>。位的含义是Unix系统上的dependent;平台，请参见<code>stat(2)</code>。\\n \n   m = File.stat(\"/etc/passwd\").world_readable?  #=> 420\n   sprintf(\"%o\", m)\t\t\t\t    #=> \"644\"", "name": "default_external=", "namespace": "Encoding", "path": "Encoding.default_external=", "type": "class_method", "visibility": "public"}, "Encoding.default_internal": {"description": "如果其他人可写，则返回表示文件权限位的整数。否则返回<code>nil</code>。位的含义是Unix系统上的dependent;平台，请参见<code>stat(2)</code>。\\n \n   m = File.stat(\"/tmp\").world_writable?\t    #=> 511\n   sprintf(\"%o\", m)\t\t\t\t    #=> \"777\"", "name": "default_internal", "namespace": "Encoding", "path": "Encoding.default_internal", "type": "class_method", "visibility": "public"}, "Encoding.default_internal=": {"description": "如果此进程的有效用户ID可写，则返回<code>true</code>。\\n\\n    File.stat(\"testfile\").writable?   #=> true", "name": "default_internal=", "namespace": "Encoding", "path": "Encoding.default_internal=", "type": "class_method", "visibility": "public"}, "Encoding.find": {"description": "如果此进程的实际用户ID可写，则返回<code>true</code>。\\n \\n    File.stat(\"testfile\").writable_real?   #=> true", "name": "find", "namespace": "Encoding", "path": "Encoding.find", "type": "class_method", "visibility": "public"}, "Encoding.list": {"description": "如果<i>stat<i>is a zero length file;\\n <code>false</code> otherwise，则返回<code>true</code>。\\n \\n    File.stat(\"testfile\").zero?   #=> false", "name": "list", "namespace": "Encoding", "path": "Encoding.list", "type": "class_method", "visibility": "public"}, "Encoding.locale_charmap": {"description": "编码实例表示Ruby中可用的字符编码。它被定义为编码命名空间下的常量。它具有名称和别名（可选）：\\n \n  Encoding::ISO_8859_1.name\n  #=> \"ISO-8859-1\"\n\n  Encoding::ISO_8859_1.names\n  #=> [\"ISO-8859-1\", \"ISO8859-1\"]\n\\n处理编码的Ruby方法返回或接受编码实例作为参数（当方法接受编码实例作为参数时，可以改为传递编码名称或别名）。\\n \n  \"some string\".encoding\n  #=> #<Encoding:UTF-8>\n\n               |         |\n2\n  \"some string\".encode \"ISO-8859-1\"\n  #=> \"some string\"\n \\n <code>Encoding::ASCII_8BIT</code>是一种特殊编码，通常用于字节字符串，而不是字符串。但顾名思义，ASCII范围内的字符被认为是ASCII个字符。\\n当您将ASCII-8bit字符与其他ASCII兼容字符一起使用时，这非常有用。\\n \\n==更改编码\\n \\n可以用两种不同的方式更改字符串的关联编码。\\n \\n首先，可以将字符串的编码设置为新的编码，而不更改字符串的内部字节表示形式，使用字符串强制编码。这就是如何告诉Ruby字符串的正确编码。\\n \n  string\n  #=> \"R\\xC3\\xA9sum\\xC3\\xA9\"\n  string.encoding\n  #=> #<Encoding:ISO-8859-1>\n  string.force_encoding(Encoding::UTF_8)\n  #=> \"R\\u00E9sum\\u00E9\"\n \\n其次，可以转换字符串，即将其内部字节表示转换为另一种编码。其关联的编码也设置为其他编码。有关各种形式的转码，请参阅string encode，有关转码过程的附加控制，请参阅encoding:：converter类。\\n \n  string\n  #=> \"R\\u00E9sum\\u00E9\"\n  string.encoding\n  #=> #<Encoding:UTF-8>\n  string = string.encode!(Encoding::ISO_8859_1)\n  #=> \"R\\xE9sum\\xE9\"\n  string.encoding\n  #=> #<Encoding::ISO-8859-1>\n \\n==script encoding \\n \\n所有Ruby脚本代码都有关联的编码，源代码中创建的任何字符串文字都将与之关联。\\n \\n v2.0之后的默认脚本编码是<code>Encoding::UTF-8</code>，但它可以\\n通过源代码文件第一行（或第二行，如果第一行有shebang行）上的魔力注释进行更改。注释必须包含单词<code>coding</code>或<code>encoding</code>，后跟冒号、空格和编码名称或别名：\\n \n  # encoding: UTF-8\n103177\\n <code>__ENCODING__</code>关键字返回写入关键字的文件的脚本编码：\\n \n  # encoding: ISO-8859-1\n103179\\n <code>ruby -K</code>将更改默认的区域设置编码，但不建议这样做。Ruby源文件应该通过一个魔力注释声明其脚本编码，即使它们只依赖于US-ASCII字符串或正则表达式。\\n \\n==locale encoding \\n \\n环境的默认编码。通常来源于地区。\\n \\n请参阅encoding.locale_charmap，encoding.find（'locale'）\\n \\n==filesystem encoding \\n \\n环境文件系统中字符串的默认编码。\\n这用于文件名或路径的字符串。\\n \\n请参阅encoding.find（'filesystem'）\\n \\n==external encoding \\n \\n每个IO对象都有一个外部编码，表示Ruby将用来读取其数据的编码。默认情况下，Ruby将IO对象的外部编码设置为默认的外部编码。默认的外部编码由区域设置编码或解释器<code>-E</code>选项设置。\\n Encoding.default_external返回外部编码的当前值。\\n \n  ENV[\"LANG\"]\n  #=> \"UTF-8\"\n  Encoding.default_external\n  #=> #<Encoding:UTF-8>\n\n  $ ruby -E ISO-8859-1 -e \"p Encoding.default_external\"\n  #<Encoding:ISO-8859-1>\n\n  $ LANG=C ruby -e 'p Encoding.default_external'\n  #<Encoding:US-ASCII>\n \\n也可以通过编码设置默认的外部编码。默认值为，但不应这样做，因为更改前后创建的字符串将具有不一致的编码。相反，使用<code>ruby -E</code>使用正确的外部编码来调用Ruby。\\n \\n当您知道IO对象数据的实际编码不是默认的外部编码时，可以使用IO设置编码重置其外部编码或在IO对象创建时设置它（请参见IO.new选项）。\\n \\n==内部编码\\n \\n若要处理编码与外部编码不同的IO对象的数据，可以设置其内部编码。当从IO对象读取数据时，Ruby将使用此内部编码来对数据进行转码。\\n \\n相反，当数据写入IO对象时，它将从内部编码转换为IO对象的外部编码。\\n \\n IO对象的内部编码可以通过IO设置编码或在IO对象创建时设置（请参见IO.new选项）。\\n \\n内部编码是可选的，如果不设置，则使用Ruby默认内部编码。如果未显式设置，则默认内部编码为+nil+，这意味着默认情况下不会发生转码。\\n \\n预设内部编码可以用解释器选项\\n <code>-E</code>设定。Encoding.default_internal返回当前的内部编码。\\n \n   $ ruby -e 'p Encoding.default_internal'\n   nil\n\n   $ ruby -E ISO-8859-1:UTF-8 -e \"p [Encoding.default_external, \\\n     Encoding.default_internal]\"\n   [#<Encoding:ISO-8859-1>, #<Encoding:UTF-8>]\n \\n也可以通过编码来设置默认的内部编码。默认的\\u internal=，但不应这样做，因为更改前后创建的字符串将具有不一致的编码。相反，使用<code>ruby -E</code>来使用正确的内部编码来调用Ruby。\\n \\n==IO编码示例\\n \\n在下面的示例中，将utf-8编码的字符串“r\\u00e9sum\\u00e9”转换为输出到ISO-8859-1编码，然后重新读取并转换为utf-8:\\n \n  string = \"R\\u00E9sum\\u00E9\"\n\n  open(\"transcoded.txt\", \"w:ISO-8859-1\") do |io|\n    io.write(string)\n  end\n\n  puts \"raw text:\"\n  p File.binread(\"transcoded.txt\")\n  puts\n\n  open(\"transcoded.txt\", \"r:ISO-8859-1:UTF-8\") do |io|\n    puts \"transcoded text:\"\n    p io.read\n  end\n\\n而wr", "name": "locale_charmap", "namespace": "Encoding", "path": "Encoding.locale_charmap", "type": "class_method", "visibility": "public"}, "Encoding.name_list": {"description": "返回ASCII是否兼容。n \n  Encoding::UTF_8.ascii_compatible?     #=> true\n  Encoding::UTF_16BE.ascii_compatible?  #=> false", "name": "name_list", "namespace": "Encoding", "path": "Encoding.name_list", "type": "class_method", "visibility": "public"}, "Encoding::CompatibilityError": {"description": "对于伪编码返回true。\\n虚拟编码是字符处理未正确实现的编码。\\n它用于有状态编码。n \n  Encoding::ISO_2022_JP.dummy?       #=> true\n  Encoding::UTF_8.dummy?             #=> false", "name": "CompatibilityError", "namespace": "Encoding", "path": "Encoding::CompatibilityError", "type": "class", "visibility": "public"}, "Encoding::Converter": {"description": "", "name": "Converter", "namespace": "Encoding", "path": "Encoding::Converter", "type": "class", "visibility": "public"}, "Encoding::Converter#==": {"description": "", "name": "==", "namespace": "Encoding::Converter", "path": "Encoding::Converter#==", "type": "instance_method", "visibility": "public"}, "Encoding::Converter#convert": {"description": "返回表示程序员编码的字符串。n \n  Encoding::UTF_8.inspect       #=> \"#<Encoding:UTF-8>\"\n  Encoding::ISO_2022_JP.inspect #=> \"#<Encoding:ISO-2022-JP (dummy)>\"", "name": "convert", "namespace": "Encoding::Converter", "path": "Encoding::Converter#convert", "type": "instance_method", "visibility": "public"}, "Encoding::Converter#convpath": {"description": "返回编码的名称。\\n n   Encoding::UTF_8.name      #=> \"UTF-8\"", "name": "convpath", "namespace": "Encoding::Converter", "path": "Encoding::Converter#convpath", "type": "instance_method", "visibility": "public"}, "Encoding::Converter#destination_encoding": {"description": "返回编码的名称和别名列表。\\n n   Encoding::WINDOWS_31J.names  #=> [\"Windows-31J\", \"CP932\", \"csWindows31J\"]", "name": "destination_encoding", "namespace": "Encoding::Converter", "path": "Encoding::Converter#destination_encoding", "type": "instance_method", "visibility": "public"}, "Encoding::Converter#finish": {"description": "返回名称为“名称”的Enc_u的复制编码。\\n新编码应具有与ENC相同的字节结构。\\n如果名称被其他编码使用，则引发ArgumentError。", "name": "finish", "namespace": "Encoding::Converter", "path": "Encoding::Converter#finish", "type": "instance_method", "visibility": "public"}, "Encoding::Converter#initialize": {"description": "返回编码的名称。\\n n   Encoding::UTF_8.name      #=> \"UTF-8\"", "name": "initialize", "namespace": "Encoding::Converter", "path": "Encoding::Converter#initialize", "type": "instance_method", "visibility": "public"}, "Encoding::Converter#insert_output": {"description": "返回可用编码别名和原始编码名称的哈希。\\n \n  Encoding.aliases\n  #=> {\"BINARY\"=>\"ASCII-8BIT\", \"ASCII\"=>\"US-ASCII\", \"ANSI_X3.4-1986\"=>\"US-ASCII\",\n“sjis”=>“shift_-jis”，“EUC_JP”=>“EUC_JP”，“cp932”=>“windows-31j”", "name": "insert_output", "namespace": "Encoding::Converter", "path": "Encoding::Converter#insert_output", "type": "instance_method", "visibility": "public"}, "Encoding::Converter#inspect": {"description": "检查两个对象的兼容性。\\n \\n如果两个对象都是字符串，则它们在可连接时是兼容的。如果串联字符串兼容，则返回其编码；如果不兼容，则返回nil。\\n \n  Encoding.compatible?(\"\\xa1\".force_encoding(\"iso-8859-1\"), \"b\")\n  #=> #<Encoding:ISO-8859-1>\n\n  Encoding.compatible?(\n    \"\\xa1\".force_encoding(\"iso-8859-1\"),\n    \"\\xa1\\xa1\".force_encoding(\"euc-jp\"))\n  #=> nil\n \\n如果对象是非字符串，则当对象具有编码时，其编码是兼容的，并且：\\n*任一编码都是US-ASCII兼容的\\n*其中一个编码是7位编码", "name": "inspect", "namespace": "Encoding::Converter", "path": "Encoding::Converter#inspect", "type": "instance_method", "visibility": "public"}, "Encoding::Converter#last_error": {"description": "返回默认的外部编码。\\n \\n默认情况下，从以下位置创建的字符串使用默认外部编码：\\n \\n*csv \\n*从磁盘读取的文件数据\\n*SDBM \\n*stringio \\n*zlib:：GzipReader \\n*zlib:：GzipWriter \\n*string 35; inspect \\n*regexp inspect \\n \\n当从这些位置创建的字符串将使用此编码时，编码可能不会有效。一定要检查字符串的有效编码？.\\n\\n写入磁盘的文件数据将在写入时转换为默认的外部编码。\\n \\n默认的外部编码由locale或-e选项初始化。", "name": "last_error", "namespace": "Encoding::Converter", "path": "Encoding::Converter#last_error", "type": "instance_method", "visibility": "public"}, "Encoding::Converter#primitive_convert": {"description": "设置默认外部编码。您不应将ruby代码中的encoding:：default_external设置为更改值之前创建的字符串可能与更改值之后创建的字符串具有不同的编码。相反，您应使用<tt>ruby-e->tt>以使用正确的default_external调用ruby。\\n \\n有关如何使用默认外部编码的信息，请参阅encoding:：default_external。", "name": "primitive_convert", "namespace": "Encoding::Converter", "path": "Encoding::Converter#primitive_convert", "type": "instance_method", "visibility": "public"}, "Encoding::Converter#primitive_errinfo": {"description": "返回默认的内部编码。如果默认内部编码不是nil，则字符串将在以下位置转换为默认内部编码：\\n\\n*csv\\n*Etc.sysconfdir和Etc.systmpdir\\n*从磁盘读取的文件数据\\n*从dir读取的文件名\\n*integer chr\\n*string inspect和regexp inspect \\n*从readline返回的字符串\\n*从1003返回的字符串236 \\n*时区\\n*来自env的值\\n*ARGV中的值，包括$PROGRAM_NAME \\n \\n另外字符串编码和字符串编码！如果未指定编码，则使用默认的内部编码。\\n \\n区域设置编码（__ENCODING__）不是默认的\\u内部编码，用作创建字符串的编码。\\n \\n encoding:：default_internal由源文件的internal_encoding或-e选项初始化。", "name": "primitive_errinfo", "namespace": "Encoding::Converter", "path": "Encoding::Converter#primitive_errinfo", "type": "instance_method", "visibility": "public"}, "Encoding::Converter#putback": {"description": "设置默认内部编码或在通过nil时删除默认内部编码。不应将ruby代码中的encoding:：default_internal设置为更改前创建的字符串，该值可能与更改后创建的字符串具有不同的编码。相反，您应该使用\\n<tt>ruby-e</tt>来使用正确的default_internal来调用ruby。\\n \\n有关如何使用默认内部编码的信息，请参阅encoding:：default_internal。", "name": "putback", "namespace": "Encoding::Converter", "path": "Encoding::Converter#putback", "type": "instance_method", "visibility": "public"}, "Encoding::Converter#replacement": {"description": "使用指定的名称搜索编码。\\n<i>name.<i>应该是字符串。\\n \n  Encoding.find(\"US-ASCII\")  #=> #<Encoding:US-ASCII>\n \\n此方法接受的名称是编码名称和别名，包括以下特殊别名\\n \\n“external”：：默认外部编码\\n“internal”：：默认内部编码\\n“locale”：：locale encoding \\n“filesystem”：：filesystem encoding \\n \\n如果不使用<i>name进行编码，则会引发ArgumentError。但是，只有<code>Encoding.find(\"internal\")</code>在没有名为“internal”的编码时返回nil，换句话说，当ruby没有默认的内部编码时。", "name": "replacement", "namespace": "Encoding::Converter", "path": "Encoding::Converter#replacement", "type": "instance_method", "visibility": "public"}, "Encoding::Converter#replacement=": {"description": "返回已加载编码的列表。\\n \n  Encoding.list\n  #=> [#<Encoding:ASCII-8BIT>, #<Encoding:UTF-8>,\n        #<Encoding:ISO-2022-JP (dummy)>]\n\n  Encoding.find(\"US-ASCII\")\n  #=> #<Encoding:US-ASCII>\n\n  Encoding.list\n  #=> [#<Encoding:ASCII-8BIT>, #<Encoding:UTF-8>,\n<编码：US-ASCII>，<编码：ISO-2022-JP（虚拟）>]", "name": "replacement=", "namespace": "Encoding::Converter", "path": "Encoding::Converter#replacement=", "type": "instance_method", "visibility": "public"}, "Encoding::Converter#source_encoding": {"description": "返回区域设置charmap名称。\\n如果没有适当的信息，则返回nil。\\n \n  Debian GNU/Linux\n    LANG=C\n      Encoding.locale_charmap  #=> \"ANSI_X3.4-1968\"\n    LANG=ja_JP.EUC-JP\n      Encoding.locale_charmap  #=> \"EUC-JP\"\n\n  SunOS 5\n    LANG=C\n      Encoding.locale_charmap  #=> \"646\"\n    LANG=ja\n      Encoding.locale_charmap  #=> \"eucJP\"\n \\n结果高度依赖于平台。\\n所以encoding.find（encoding.locale_charmap）可能会导致错误。\\n如果您需要一些编码对象，即使对于未知的区域设置，也可以使用\\n encoding.find（“locale”）。", "name": "source_encoding", "namespace": "Encoding::Converter", "path": "Encoding::Converter#source_encoding", "type": "instance_method", "visibility": "public"}, "Encoding::Converter.asciicompat_encoding": {"description": "返回可用编码名称的列表。\\n \n  Encoding.name_list\n  #=> [\"US-ASCII\", \"ASCII-8BIT\", \"UTF-8\",\n        \"ISO-8859-1\", \"Shift_JIS\", \"EUC-JP\",\n        \"Windows-31J\",\n“二进制”、“cp932”、“eucjp”]", "name": "asciicompat_encoding", "namespace": "Encoding::Converter", "path": "Encoding::Converter.asciicompat_encoding", "type": "class_method", "visibility": "public"}, "Encoding::Converter.search_convpath": {"description": "当源编码与目标编码不兼容时，由编码和字符串方法引发。", "name": "search_convpath", "namespace": "Encoding::Converter", "path": "Encoding::Converter.search_convpath", "type": "class_method", "visibility": "public"}, "Encoding::Converter::AFTER_OUTPUT": {"description": "转换source_string并返回destination_string。\\n \\n source_string被假定为源的一部分。\\n即：在内部指定部分输入=>true。\\n应最后使用finish方法。\\n \n  ec = Encoding::Converter.new(\"utf-8\", \"euc-jp\")\n  puts ec.convert(\"\\u3042\").dump     #=> \"\\xA4\\xA2\"\n  puts ec.finish.dump                #=> \"\"\n\n  SunOS 5\n    LANG=C\n      Encoding.locale_charmap  #=> \"646\"\n    LANG=ja\n      Encoding.locale_charmap  #=> \"eucJP\"\n003256 \\n如果发生转换错误，将引发\\n encoding:：UndefinedConversionError或encoding:：InvalidByteSequenceError。\\n encoding:：converter convert不提供从这些异常中恢复或重新启动的方法。\\n要处理这些转换错误，请使用encoding:：converter primitive _convert。", "name": "AFTER_OUTPUT", "namespace": "Encoding::Converter", "path": "Encoding::Converter::AFTER_OUTPUT", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "Encoding::Converter::CRLF_NEWLINE_DECORATOR": {"description": "返回EC的转换路径。\\n \\n结果是一个转换数组。\\n \n  ec = Encoding::Converter.new(\"ISO-8859-1\", \"EUC-JP\", crlf_newline: true)\n  p ec.convpath\n  #=> [[#<Encoding:ISO-8859-1>, #<Encoding:UTF-8>],\n  #    [#<Encoding:UTF-8>, #<Encoding:EUC-JP>],\n  #    \"crlf_newline\"]\n \\n数组的每个元素都是一对编码或一个字符串。\\n pair表示编码转换。\\n字符串表示修饰符。\\n \\n在上述示例中，[<encoding:iso-8859-1>，<encoding:utf-8>]表示从iso-8859-1到utf-8的转换器。\\n“CRLF_NEWLINE”表示从lf到CRLF的换行转换器。", "name": "CRLF_NEWLINE_DECORATOR", "namespace": "Encoding::Converter", "path": "Encoding::Converter::CRLF_NEWLINE_DECORATOR", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "Encoding::Converter::CR_NEWLINE_DECORATOR": {"description": "将目标编码作为编码对象返回。", "name": "CR_NEWLINE_DECORATOR", "namespace": "Encoding::Converter", "path": "Encoding::Converter::CR_NEWLINE_DECORATOR", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "Encoding::Converter::INVALID_MASK": {"description": "完成转换器。\\n它返回已转换字符串的最后一部分。n \n  ec = Encoding::Converter.new(\"utf-8\", \"iso-2022-jp\")\n  p ec.convert(\"\\u3042\")     #=> \"\\e$B$\\\"\"\n  p ec.finish                #=> \"\\e(B\"", "name": "INVALID_MASK", "namespace": "Encoding::Converter", "path": "Encoding::Converter::INVALID_MASK", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "Encoding::Converter::INVALID_REPLACE": {"description": "可能的选项元素：\n  hash form:\n    :invalid => nil            # raise error on invalid byte sequence (default)\n    :invalid => :replace       # replace invalid byte sequence\n    :undef => nil              # raise error on undefined conversion (default)\n    :undef => :replace         # replace undefined conversion\n    :replace => string         # replacement string (\"?\" or \"\\uFFFD\" if not specified)\n    :newline => :universal     # decorator for converting CRLF and CR to LF\n    :newline => :crlf          # decorator for converting LF to CRLF\n    :newline => :cr            # decorator for converting LF to CR\n    :universal_newline => true # decorator for converting CRLF and CR to LF\n    :crlf_newline => true      # decorator for converting LF to CRLF\n    :cr_newline => true        # decorator for converting LF to CR\n    :xml => :text              # escape as XML CharData.\n    :xml => :attr              # escape as XML AttValue\n  integer form:\n    Encoding::Converter::INVALID_REPLACE\n    Encoding::Converter::UNDEF_REPLACE\n    Encoding::Converter::UNDEF_HEX_CHARREF\n    Encoding::Converter::UNIVERSAL_NEWLINE_DECORATOR\n    Encoding::Converter::CRLF_NEWLINE_DECORATOR\n    Encoding::Converter::CR_NEWLINE_DECORATOR\n    Encoding::Converter::XML_TEXT_DECORATOR\n    Encoding::Converter::XML_ATTR_CONTENT_DECORATOR\n    Encoding::Converter::XML_ATTR_QUOTE_DECORATOR\n\\n encoding:：converter.new创建encoding:：converter的实例。\\n \\n Source_encoding和destination_encoding应该是字符串或编码对象。\\n \\n opt应为nil、哈希或整数。\\n \\n convpath应该是一个数组。\\n convpath可以包含\\n- 包含编码或编码名称的两个元素数组，或\\n- 表示装饰器名称的字符串。\\n \\n encoding：：converter.new可选接受一个选项。\\n选项应为哈希或整数。\\n选项哈希可以包含:invalid=>nil等。\\n选项整数应为逻辑或常量，如encoding:：converter:：INVALID_REPLACE等。\\n\\n[：invalid=>nil]\n  Raise error on invalid byte sequence.  This is a default behavior.\n[：invalid=>：replace]\n  Replace invalid byte sequence by replacement string.\n[：undef=>nil]\n  Raise an error if a character in source_encoding is not defined in destination_encoding.\n  This is a default behavior.\n[：undef=>：replace]\n  Replace undefined character in destination_encoding with replacement string.\n[：replace=>string]\n  Specify the replacement string.\n  If not specified, \"\\uFFFD\" is used for Unicode encodings and \"?\" for others.\n[：universal\\u newline=>true]\n  Convert CRLF and CR to LF.\n[：crlf\\u newline=>true]\n  Convert LF to CRLF.\n[：cr_newline=>true]\n  Convert LF to CR.\n[：xml=>：text]\n  Escape as XML CharData.\n  This form can be used as an HTML 4.0 #PCDATA.\n  - '&' -> '&amp;'\n  - '<' -> '&lt;'\n  - '>' -> '&gt;'\n  - undefined characters in destination_encoding -> hexadecimal CharRef such as &#xHH;\n[：xml=>：attr]\n  Escape as XML AttValue.\n  The converted result is quoted as \"...\".\n  This form can be used as an HTML 4.0 attribute value.\n  - '&' -> '&amp;'\n  - '<' -> '&lt;'\n  - '>' -> '&gt;'\n  - '\"' -> '&quot;'\n  - undefined characters in destination_encoding -> hexadecimal CharRef such as &#xHH;\n\\n示例：\n  # UTF-16BE to UTF-8\n  ec = Encoding::Converter.new(\"UTF-16BE\", \"UTF-8\")\n\n  # Usually, decorators such as newline conversion are inserted last.\n  ec = Encoding::Converter.new(\"UTF-16BE\", \"UTF-8\", :universal_newline => true)\n  p ec.convpath #=> [[#<Encoding:UTF-16BE>, #<Encoding:UTF-8>],\n                #    \"universal_newline\"]\n103279\n  # But, if the last encoding is ASCII incompatible,\n  # decorators are inserted before the last conversion.\n  ec = Encoding::Converter.new(\"UTF-8\", \"UTF-16BE\", :crlf_newline => true)\n  p ec.convpath #=> [\"crlf_newline\",\n                #    [#<Encoding:UTF-8>, #<Encoding:UTF-16BE>]]\n\n  # Conversion path can be specified directly.\n  ec = Encoding::Converter.new([\"universal_newline\", [\"EUC-JP\", \"UTF-8\"], [\"UTF-8\", \"UTF-16BE\"]])\n  p ec.convpath #=> [\"universal_newline\",\n                #    [#<Encoding:EUC-JP>, #<Encoding:UTF-8>],\n", "name": "INVALID_REPLACE", "namespace": "Encoding::Converter", "path": "Encoding::Converter::INVALID_REPLACE", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "Encoding::Converter::PARTIAL_INPUT": {"description": "将字符串插入编码转换器。\\n在以后的转换中，字符串将转换为目标编码并输出。\\n \\n如果目标编码是有状态的，则会根据状态转换字符串，并更新状态。\\n \\n只有在发生转换错误时才应使用此方法。\\n \\n \\n ec=encod：：converter.new（“utf-8”，“iso-8859-1”）\\n src=“HiraganaLETTER a is \\u{3042}。”\\n dst=“\\n  p ec.primitive_convert(src, dst)    #=> :undefined_conversion \\n  puts \"[#{dst.dump}, #{src.dump}]\"   #=> [\"HIRAGANA LETTER A is \", \".\"] \\n ec.insert_outpu（“<err>“”）\\n  p ec.primitive_convert(src, dst)    #=> :finished \\n  puts \"[#{dst.dump}, #{src.dump}]\"   #=> [\"HIRAGANA LETTER A is <err>.\", \"\"] \\n \\n ec=encod：：converter.new（“utf-8”，“iso-2022-JP”）\\n src=“\\\\u 123306f 3041 3068 2661 3068 2661 30061 3002 \\\\35; u+2661在is 2022-2022-2022中不可在iso-2022-2022-2022中-jp \\n dst=“”\\n  p ec.primitive_convert(src, dst)    #=> :undefined_conversion \\n  puts \"[#{dst.dump}, #{src.dump}]\"   #=> [\"\\e$B$O$!$H\".force_encoding(\"ISO-2022-JP\"), \"\\xE3\\x80\\x82\"] \\n ec.insert_output“？”输出“”所需的状态更改？.\\n  p ec.primitive_convert(src, dst)    #=> :finished \\n  puts \"[#{dst.dump}, #{src.dump}]\"   #=> [\"\\e$B$O$!$H\\e(B?\\e$B!#\\e(B\".force_encoding(\"ISO-2022-JP\"), \"\"]", "name": "PARTIAL_INPUT", "namespace": "Encoding::Converter", "path": "Encoding::Converter::PARTIAL_INPUT", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "Encoding::Converter::UNDEF_HEX_CHARREF": {"description": "返回<i>ec的可打印版本", "name": "UNDEF_HEX_CHARREF", "namespace": "Encoding::Converter", "path": "Encoding::Converter::UNDEF_HEX_CHARREF", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "Encoding::Converter::UNDEF_MASK": {"description": "返回上次转换的异常对象。\\n如果上次转换没有产生错误，则返回nil。\\n \\n“错误”表示encoding:：InvalidByteSequenceError和encoding:：UndefinedConversionError用于encoding:：converter convert，而\\n:无效的字节序列，:incomplete_input和:undefined_conversion用于encoding:：converter primitive convert。\\n \\n ec=encoding:：converter.new（“utf-8”，“iso-8859-1”）\\n  p ec.primitive_convert(src=\"\\xf1abcd\", dst=\"\")       #=> :invalid_byte_sequence\\n  p ec.last_error      #=> #<Encoding::InvalidByteSequenceError: \"\\xF1\" followed by \"a\" on UTF-8>\\n  p ec.primitive_convert(src, dst, nil, 1)             #=> :destination_buffer_full\\n  p ec.last_error      #=> nil", "name": "UNDEF_MASK", "namespace": "Encoding::Converter", "path": "Encoding::Converter::UNDEF_MASK", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "Encoding::Converter::UNDEF_REPLACE": {"description": "可能的opt元素：\n  hash form:\n    :partial_input => true           # source buffer may be part of larger source\n    :after_output => true            # stop conversion after output before input\n  integer form:\n    Encoding::Converter::PARTIAL_INPUT\n    Encoding::Converter::AFTER_OUTPUT\n \\n可能的结果：\n   :invalid_byte_sequence\n   :incomplete_input\n   :undefined_conversion\n   :after_output\n   :destination_buffer_full\n   :source_buffer_empty\n   :finished\n \\n primitive_convert将source_buffer转换为destination_buffer。\\n \\n source_buffer应该是字符串或nil。\\n nil表示空字符串。\\n \\n destination_buffer应该是字符串。\\n \\n destination_byteoffset应为整数或nil。\\n nil表示destination_buffer结束。\\n如果省略，则假定为nil。\\n \\n destination_bytesize应为整数或nil。\\n nil表示无限制。\\n如果省略，则假定为nil。\\n \\n opt应为nil、哈希或整数。\\n nil表示没有标志。\\n如果省略，则假定为nil。\\n \\n primitive_convert从开始转换source_buffer的内容，并将结果存储到destination_buffer中。\\n \\n destination_byteoffset和destination_bytesize指定存储转换结果的区域。\\n destination_byteoffset以destination_buffer字节为单位指定起始位置。\\n如果destination_byteoffset是nil，则使用destination_buffer.Bytesize追加结果。\\n destination_bytesize指定最大字节数。\\n如果destination_bytesize是nil，则目标大小不受限制。\\n转换后，destination_buffer的大小调整为destination_byteoffset+实际产生的字节数。\\n同时，目标缓冲区的编码设置为destination_encoding。\\n \\n primitive_convert删除source_buffer的转换部分。\\n丢弃的部分在destination_buffer中转换或在encoding:：converter对象中缓冲。\\n \\n primitive_convert在满足下列条件之一时停止转换。\\n- 在源缓冲区中发现无效的字节序列（：invalid_byte_sequence）\n  +primitive_errinfo+ and +last_error+ methods returns the detail of the error.\n-意外的源缓冲区结尾（：incomplete_input）\n  this occur only when :partial_input is not specified.\n  +primitive_errinfo+ and +last_error+ methods returns the detail of the error.\n-输出编码中不可表示的字符（：undefined_conversion）\n  +primitive_errinfo+ and +last_error+ methods returns the detail of the error.\n-在生成某些输出之后，在完成输入之前（：after_output）\n  this occur only when :after_output is specified.\n-目标缓冲区已满（：destination_buffer_full）\n  this occur only when destination_bytesize is non-nil.\n-源缓冲区为空（：source_buffer_empty）\n  this occur only when :partial_input is specified.\n-转换完成（：finished）\\n\\n example:\n  ec = Encoding::Converter.new(\"UTF-8\", \"UTF-16BE\")\n  ret = ec.primitive_convert(src=\"pi\", dst=\"\", nil, 100)\n  p [ret, src, dst] #=> [:finished, \"\", \"\\x00p\\x00i\"]\n\n  ec = Encoding::Converter.new(\"UTF-8\", \"UTF-16BE\")\n  ret = ec.primitive_convert(src=\"pi\", dst=\"\", nil, 1)\n  p [ret, src, dst] #=> [:destination_buffer_full, \"i\", \"\\x00\"]\n  ret = ec.primitive_convert(src, dst=\"\", nil, 1)\n  p [ret, src, dst] #=> [:destination_buffer_full, \"\", \"p\"]\n  ret = ec.primitive_convert(src, dst=\"\", nil, 1)\n  p [ret, src, dst] #=> [:destination_buffer_full, \"\", \"\\x00\"]\n  ret = ec.primitive_convert(src, dst=\"\", nil, 1)\n  p [ret, src, dst] #=> [:finished, \"\", \"i\"]", "name": "UNDEF_REPLACE", "namespace": "Encoding::Converter", "path": "Encoding::Converter::UNDEF_REPLACE", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "Encoding::Converter::UNIVERSAL_NEWLINE_DECORATOR": {"description": "Primitive_ErrInfo以5元素数组的形式返回有关上一个错误的重要信息：\\n \n  [result, enc1, enc2, error_bytes, readagain_bytes]\n\\n result是primitive_convert的最后一个结果。\\n \\n只有当结果为\\n:invalid_byte_sequence、:incomplete_input或：undefined_conversion时，其他元素才有意义。\\n \\n enc1及enc2表示转换步骤为一对字符串。\\n例如，从euc-jp到iso-8859-1的转换器按如下方式转换字符串：euc-jp->utf-8->iso-8859-1。\\n因此[enc1，enc2]是[“EUC_JP”、“utf-8”]或[“utf-8”、“iso-8859-1”]。\\n \\n error_bytes及readagain_bytes表示造成错误的位元序列。\\n error_bytes是丢弃的部分。\\n readagain_bytes是缓冲区，下次转换时将再次读取。\\n \\n范例：\\n \n  # \\xff is invalid as EUC-JP.\n  ec = Encoding::Converter.new(\"EUC-JP\", \"Shift_JIS\")\n  ec.primitive_convert(src=\"\\xff\", dst=\"\", nil, 10)\n  p ec.primitive_errinfo\n  #=> [:invalid_byte_sequence, \"EUC-JP\", \"UTF-8\", \"\\xFF\", \"\"]\n\n  # HIRAGANA LETTER A (\\xa4\\xa2 in EUC-JP) is not representable in ISO-8859-1.\n  # Since this error is occur in UTF-8 to ISO-8859-1 conversion,\n  # error_bytes is HIRAGANA LETTER A in UTF-8 (\\xE3\\x81\\x82).\n  ec = Encoding::Converter.new(\"EUC-JP\", \"ISO-8859-1\")\n  ec.primitive_convert(src=\"\\xa4\\xa2\", dst=\"\", nil, 10)\n  p ec.primitive_errinfo\n  #=> [:undefined_conversion, \"UTF-8\", \"ISO-8859-1\", \"\\xE3\\x81\\x82\", \"\"]\n\n  # partial character is invalid\n  ec = Encoding::Converter.new(\"EUC-JP\", \"ISO-8859-1\")\n  ec.primitive_convert(src=\"\\xa4\", dst=\"\", nil, 10)\n  p ec.primitive_errinfo\n  #=> [:incomplete_input, \"EUC-JP\", \"UTF-8\", \"\\xA4\", \"\"]\n\n  # Encoding::Converter::PARTIAL_INPUT prevents invalid errors by\n  # partial characters.\n  ec = Encoding::Converter.new(\"EUC-JP\", \"ISO-8859-1\")\n  ec.primitive_convert(src=\"\\xa4\", dst=\"\", nil, 10, Encoding::Converter::PARTIAL_INPUT)\n  p ec.primitive_errinfo\n  #=> [:source_buffer_empty, nil, nil, nil, nil]\n\n  # \\xd8\\x00\\x00@ is invalid as UTF-16BE because\n  # no low surrogate after high surrogate (\\xd8\\x00).\n  # It is detected by 3rd byte (\\00) which is part of next character.\n  # So the high surrogate (\\xd8\\x00) is discarded and\n  # the 3rd byte is read again later.\n  # Since the byte is buffered in ec, it is dropped from src.\n  ec = Encoding::Converter.new(\"UTF-16BE\", \"UTF-8\")\n  ec.primitive_convert(src=\"\\xd8\\x00\\x00@\", dst=\"\", nil, 10)\n  p ec.primitive_errinfo\n  #=> [:invalid_byte_sequence, \"UTF-16BE\", \"UTF-8\", \"\\xD8\\x00\", \"\\x00\"]\n  p src\n  #=> \"@\"\n\n  # Similar to UTF-16BE, \\x00\\xd8@\\x00 is invalid as UTF-16LE.\n  # The problem is detected by 4th byte.\n  ec = Encoding::Converter.new(\"UTF-16LE\", \"UTF-8\")\n  ec.primitive_convert(src=\"\\x00\\xd8@\\x00\", dst=\"\", nil, 10)\n  p ec.primitive_errinfo\n  #=> [:invalid_byte_sequence, \"UTF-16LE\", \"UTF-8\", \"\\x00\\xD8\", \"@\\x00\"]\n  p src\n  #=> \"\"", "name": "UNIVERSAL_NEWLINE_DECORATOR", "namespace": "Encoding::Converter", "path": "Encoding::Converter::UNIVERSAL_NEWLINE_DECORATOR", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "Encoding::Converter::XML_ATTR_CONTENT_DECORATOR": {"description": "返回替换字符串。\\n \\n ec=编码：：converter.new（“EUC_JP”，“US_ASCII”）\\n  p ec.replacement    #=> \"?\" \\n \\n ec=编码：：converter.new（“EUC_JP”，“utf-8”）\\n  p ec.replacement    #=> \"\\uFFFD\"", "name": "XML_ATTR_CONTENT_DECORATOR", "namespace": "Encoding::Converter", "path": "Encoding::Converter::XML_ATTR_CONTENT_DECORATOR", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "Encoding::Converter::XML_ATTR_QUOTE_DECORATOR": {"description": "返回替换字符串。\\n \\n ec=编码：：converter.new（“EUC_JP”，“US_ASCII”）\\n  p ec.replacement    #=> \"?\" \\n \\n ec=编码：：converter.new（“EUC_JP”，“utf-8”）\\n  p ec.replacement    #=> \"\\uFFFD\"", "name": "XML_ATTR_QUOTE_DECORATOR", "namespace": "Encoding::Converter", "path": "Encoding::Converter::XML_ATTR_QUOTE_DECORATOR", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "Encoding::Converter::XML_TEXT_DECORATOR": {"description": "设置替换字符串。\\n \\n ec=encoding:：converter.new（“utf-8”，“US ASCII”，:undef=>：replace）\\n ec.replacement=“<undef>”\\n  p ec.convert(\"a \\u3042 b\")      #=> \"a <undef> b\"", "name": "XML_TEXT_DECORATOR", "namespace": "Encoding::Converter", "path": "Encoding::Converter::XML_TEXT_DECORATOR", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "Encoding::ConverterNotFoundError": {"description": "将源编码作为编码对象返回。", "name": "ConverterNotFoundError", "namespace": "Encoding", "path": "Encoding::ConverterNotFoundError", "type": "class", "visibility": "public"}, "Encoding::InvalidByteSequenceError": {"description": "返回相应的ASCII兼容编码。\\n \\n如果参数是ASCII兼容的编码，则返回nil。\\n \\n“对应的ASCII兼容编码”是ASCII兼容编码，它可以表示与给定的ASCII不兼容编码完全相同的字符。\\n因此，在两个编码之间转换时不会发生未定义的转换错误。n \n  Encoding::Converter.asciicompat_encoding(\"ISO-2022-JP\") #=> #<Encoding:stateless-ISO-2022-JP>\n  Encoding::Converter.asciicompat_encoding(\"UTF-16BE\") #=> #<Encoding:UTF-8>\n  Encoding::Converter.asciicompat_encoding(\"UTF-8\") #=> nil", "name": "InvalidByteSequenceError", "namespace": "Encoding", "path": "Encoding::InvalidByteSequenceError", "type": "class", "visibility": "public"}, "Encoding::InvalidByteSequenceError#destination_encoding": {"description": "源编码中有效字符的掩码，但目标编码中没有相关字符。", "name": "destination_encoding", "namespace": "Encoding::InvalidByteSequenceError", "path": "Encoding::InvalidByteSequenceError#destination_encoding", "type": "instance_method", "visibility": "public"}, "Encoding::InvalidByteSequenceError#destination_encoding_name": {"description": "替换目标编码中未定义的字节序列。", "name": "destination_encoding_name", "namespace": "Encoding::InvalidByteSequenceError", "path": "Encoding::InvalidByteSequenceError#destination_encoding_name", "type": "instance_method", "visibility": "public"}, "Encoding::InvalidByteSequenceError#error_bytes": {"description": "用于将lf转换为crlf的装饰符", "name": "error_bytes", "namespace": "Encoding::InvalidByteSequenceError", "path": "Encoding::InvalidByteSequenceError#error_bytes", "type": "instance_method", "visibility": "public"}, "Encoding::InvalidByteSequenceError#incomplete_input?": {"description": "用于将lf转换为cr的装饰器", "name": "incomplete_input?", "namespace": "Encoding::InvalidByteSequenceError", "path": "Encoding::InvalidByteSequenceError#incomplete_input?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Encoding::InvalidByteSequenceError#readagain_bytes": {"description": "无效字节序列的掩码", "name": "readagain_bytes", "namespace": "Encoding::InvalidByteSequenceError", "path": "Encoding::InvalidByteSequenceError#readagain_bytes", "type": "instance_method", "visibility": "public"}, "Encoding::InvalidByteSequenceError#source_encoding": {"description": "作为XML属性值转义", "name": "source_encoding", "namespace": "Encoding::InvalidByteSequenceError", "path": "Encoding::InvalidByteSequenceError#source_encoding", "type": "instance_method", "visibility": "public"}, "Encoding::InvalidByteSequenceError#source_encoding_name": {"description": "作为XML属性值转义", "name": "source_encoding_name", "namespace": "Encoding::InvalidByteSequenceError", "path": "Encoding::InvalidByteSequenceError#source_encoding_name", "type": "instance_method", "visibility": "public"}, "Encoding::UndefinedConversionError": {"description": "用XML十六进制字符引用替换目标编码中未定义的字节序列。这对XML转换有效。", "name": "UndefinedConversionError", "namespace": "Encoding", "path": "Encoding::UndefinedConversionError", "type": "class", "visibility": "public"}, "Encoding::UndefinedConversionError#destination_encoding": {"description": "源编码中有效字符的掩码，但目标编码中没有相关字符。", "name": "destination_encoding", "namespace": "Encoding::UndefinedConversionError", "path": "Encoding::UndefinedConversionError#destination_encoding", "type": "instance_method", "visibility": "public"}, "Encoding::UndefinedConversionError#destination_encoding_name": {"description": "替换目标编码中未定义的字节序列。", "name": "destination_encoding_name", "namespace": "Encoding::UndefinedConversionError", "path": "Encoding::UndefinedConversionError#destination_encoding_name", "type": "instance_method", "visibility": "public"}, "Encoding::UndefinedConversionError#error_char": {"description": "用于将CRLF和CR转换为LF的装饰器", "name": "error_char", "namespace": "Encoding::UndefinedConversionError", "path": "Encoding::UndefinedConversionError#error_char", "type": "instance_method", "visibility": "public"}, "Encoding::UndefinedConversionError#source_encoding": {"description": "作为XML属性值转义", "name": "source_encoding", "namespace": "Encoding::UndefinedConversionError", "path": "Encoding::UndefinedConversionError#source_encoding", "type": "instance_method", "visibility": "public"}, "Encoding::UndefinedConversionError#source_encoding_name": {"description": "作为XML属性值转义", "name": "source_encoding_name", "namespace": "Encoding::UndefinedConversionError", "path": "Encoding::UndefinedConversionError#source_encoding_name", "type": "instance_method", "visibility": "public"}, "Enumerable": {"description": "作为XML chardata转义", "name": "Enumerable", "namespace": "", "path": "Enumerable", "type": "module", "visibility": "public"}, "Enumerable#all?": {"description": "当命名编码与已知转换器不对应时，由转码方法引发。", "name": "all?", "namespace": "Enumerable", "path": "Enumerable#all?", "type": "module_function", "visibility": "public", "return": [["Boolean"], ""]}, "Enumerable#any?": {"description": "当被转码的字符串包含对源或目标编码无效的字节时，由Encoding和String方法引发。", "name": "any?", "namespace": "Enumerable", "path": "Enumerable#any?", "type": "module_function", "visibility": "public", "return": [["Boolean"], ""]}, "Enumerable#chunk": {"description": "将目标编码作为编码对象返回。", "name": "chunk", "namespace": "Enumerable", "path": "Enumerable#chunk", "type": "module_function", "visibility": "public"}, "Enumerable#chunk_while": {"description": "以字符串形式返回目标编码名称。", "name": "chunk_while", "namespace": "Enumerable", "path": "Enumerable#chunk_while", "type": "module_function", "visibility": "public"}, "Enumerable#collect": {"description": "为+self+中的每个元素调用一次<i>block，将该元素作为参数传递，将多个值从yield转换为\\n数组。\\n \\n如果没有给定块，则返回枚举器。\\n \n   class Foo\n     include Enumerable\n     def each\n       yield 1\n       yield 1, 2\n       yield\n     end\n   end\n   Foo.new.each_entry{ |o| p o }\n \\n产生时间：\\n \n   1\n   [1, 2]\n nil", "name": "collect", "namespace": "Enumerable", "path": "Enumerable#collect", "type": "module_function", "visibility": "public"}, "Enumerable#collect_concat": {"description": "对于<i>枚举中的每个元素，返回一个新数组，其中包含\\n<em>block<em>once的串联结果。\\n \\n如果没有给定块，则返回枚举器。n \n   [1, 2, 3, 4].flat_map { |e| [e, -e] } #=> [1, -1, 2, -2, 3, -3, 4, -4]\n   [[1, 2], [3, 4]].flat_map { |e| e + [100] } #=> [1, 2, 100, 3, 4, 100]", "name": "collect_concat", "namespace": "Enumerable", "path": "Enumerable#collect_concat", "type": "module_function", "visibility": "public"}, "Enumerable#count": {"description": "返回在发生编码：：InvalidByteSequenceError时要再次读取的字节。", "name": "count", "namespace": "Enumerable", "path": "Enumerable#count", "type": "module_function", "visibility": "public"}, "Enumerable#cycle": {"description": "将源编码作为编码对象返回。\\n \\n请注意，如果转换有多个步骤，则结果可能不等于编码转换器的源编码。\\n \\n ec=encoding:：converter.new（“iso-8859-1”，“EUC_JP”）iso-8859-1->utf-8->euc-jp\\n begin\n   ec.convert(\"\\xa0\") # NO-BREAK SPACE, which is available in UTF-8 but not in EUC-JP.\n rescue-encoding:：undefinedconversionError\n   p $!.source_encoding              #=> #<Encoding:UTF-8>\n   p $!.destination_encoding         #=> #<Encoding:EUC-JP>\n   p $!.source_encoding_name         #=> \"UTF-8\"\n   p $!.destination_encoding_name    #=> \"EUC-JP\"\n结束", "name": "cycle", "namespace": "Enumerable", "path": "Enumerable#cycle", "type": "module_function", "visibility": "public"}, "Enumerable#detect": {"description": "将集合的每个元素传递给给定的块。如果块返回的值不是<code>false</code>或<code>nil</code>，则该方法返回<code>true</code>。如果没有给出该块，Ruby会添加一个<code>{ |obj| obj }</code>的隐式块，它会导致任何？如果至少有一个集合成员不是+false+或+nil+，则返回+true+。\\n \\n如果提供了模式，则该方法将返回任何集合成员是否为<code>pattern === element</code>。n \n   %w[ant bear cat].any? { |word| word.length >= 3 } #=> true\n   %w[ant bear cat].any? { |word| word.length >= 4 } #=> true\n   %w[ant bear cat].any?(/d/)                        #=> false\n   [nil, true, 99].any?(Integer)                     #=> true\n   [nil, true, 99].any?                              #=> true\n   [].any?                                           #=> false", "name": "detect", "namespace": "Enumerable", "path": "Enumerable#detect", "type": "module_function", "visibility": "public"}, "Enumerable#drop": {"description": "转码操作失败时由编码和字符串方法引发。", "name": "drop", "namespace": "Enumerable", "path": "Enumerable#drop", "type": "module_function", "visibility": "public"}, "Enumerable#drop_while": {"description": "将目标编码作为编码对象返回。", "name": "drop_while", "namespace": "Enumerable", "path": "Enumerable#drop_while", "type": "module_function", "visibility": "public"}, "Enumerable#each_cons": {"description": "以字符串形式返回目标编码名称。", "name": "each_cons", "namespace": "Enumerable", "path": "Enumerable#each_cons", "type": "module_function", "visibility": "public"}, "Enumerable#each_entry": {"description": "返回导致编码：：UndefinedConversionError的一个字符串。\\n \\n ec=encoding:：converter.new（“iso-8859-1”，“EUC_JP”）\\n begin\n   ec.convert(\"\\xa0\")\n rescue encoding:：undefinedconversionError\n   puts $!.error_char.dump   #=> \"\\xC2\\xA0\"\n   p $!.error_char.encoding  #=> #<Encoding:UTF-8>\n结束", "name": "each_entry", "namespace": "Enumerable", "path": "Enumerable#each_entry", "type": "module_function", "visibility": "public"}, "Enumerable#each_slice": {"description": "将源编码作为编码对象返回。\\n \\n请注意，如果转换有多个步骤，则结果可能不等于编码转换器的源编码。\\n \\n ec=encoding:：converter.new（“iso-8859-1”，“EUC_JP”）iso-8859-1->utf-8->euc-jp\\n begin\n   ec.convert(\"\\xa0\") # NO-BREAK SPACE, which is available in UTF-8 but not in EUC-JP.\n救援编码：：UndefinedConversionError\n   p $!.source_encoding              #=> #<Encoding:UTF-8>\n   p $!.destination_encoding         #=> #<Encoding:EUC-JP>\n   p $!.source_encoding_name         #=> \"UTF-8\"\n   p $!.destination_encoding_name    #=> \"EUC-JP\"\n结束", "name": "each_slice", "namespace": "Enumerable", "path": "Enumerable#each_slice", "type": "module_function", "visibility": "public"}, "Enumerable#each_with_index": {"description": "以字符串形式返回源编码名称。", "name": "each_with_index", "namespace": "Enumerable", "path": "Enumerable#each_with_index", "type": "module_function", "visibility": "public"}, "Enumerable#each_with_object": {"description": "<code>Enumerable</code> mixin为集合类提供了几种遍历和搜索方法，并具有排序功能。类必须提供方法<code>each</code>，该方法生成集合的连续成员。如果使用了<code>Enumerable#max</code>、<code>#min</code>或<code>#sort</code>，则集合中的对象还必须实现一个有意义的<code><=></code>运算符，因为这些方法依赖于集合成员之间的顺序。", "name": "each_with_object", "namespace": "Enumerable", "path": "Enumerable#each_with_object", "type": "module_function", "visibility": "public"}, "Enumerable#entries": {"description": "返回一个两元素数组，其中包含\\n<i>Enum中分别对应于给定块的最小值和最大值的对象。\\n \\n如果没有给定块，则返回枚举器。n \n   a = %w(albatross dog horse)\n   a.minmax_by { |x| x.length }   #=> [\"dog\", \"albatross\"]", "name": "entries", "namespace": "Enumerable", "path": "Enumerable#entries", "type": "module_function", "visibility": "public"}, "Enumerable#find": {"description": "将集合的每个元素传递给给定的块。如果块返回的值不是<code>false</code>或<code>nil</code>，则该方法返回<code>true</code>。如果没有给出该块，Ruby会添加一个<code>{ |obj| obj }</code>的隐式块，它会导致任何？如果至少有一个集合成员不是+false+或+nil+，则返回+true+。\\n \\n如果提供了模式，则该方法将返回任何集合成员是否为<code>pattern === element</code>。n \n   %w[ant bear cat].any? { |word| word.length >= 3 } #=> true\n   %w[ant bear cat].any? { |word| word.length >= 4 } #=> true\n   %w[ant bear cat].any?(/d/)                        #=> false\n   [nil, true, 99].any?(Integer)                     #=> true\n   [nil, true, 99].any?                              #=> true\n   [].any?                                           #=> false", "name": "find", "namespace": "Enumerable", "path": "Enumerable#find", "type": "module_function", "visibility": "public"}, "Enumerable#find_all": {"description": "通过应用由一个名为方法或运算符的块或符号指定的二进制操作，组合<i>Enum的所有元素。\\n \\n<i>inject</i>and<i>reduce</i>methods are aliases.两者都没有性能优势。\\n \\n如果指定块，则对于<i>Enum中的每个元素，该块将传递一个累加器值（<i>Memo<i>）和该元素。\\n如果改为指定符号，则集合中的每个元素\\n都将传递给<i>memo的命名方法。\\n在这两种情况下，结果都将成为<i>备忘录的新值。\\n在迭代结束时，memo的最终值是方法的返回值。\\n \\n如果您没有明确指定<i>initial的值，则将collection的第一个元素用作<i>memo的初始值。\\n n \n   # Sum some numbers\n   (5..10).reduce(:+)                             #=> 45\n   # Same using a block and inject\n   (5..10).inject { |sum, n| sum + n }            #=> 45\n   # Multiply some numbers\n   (5..10).reduce(1, :*)                          #=> 151200\n   # Same using a block\n   (5..10).inject(1) { |product, n| product * n } #=> 151200\n   # find the longest word\n   longest = %w{ cat sheep bear }.inject do |memo, word|\n      memo.length > word.length ? memo : word\n   end\n   longest                                        #=> \"sheep\"", "name": "find_all", "namespace": "Enumerable", "path": "Enumerable#find_all", "type": "module_function", "visibility": "public"}, "Enumerable#find_index": {"description": "为每个分块元素创建枚举器。\\n块的开头由块定义。\\n \\n此方法使用接收器枚举器中的相邻元素\\n elt-before和\\n elt-after-u拆分每个块。\\n此方法在elt-before_u和elt-after之间拆分块，块返回<code>false</code>。\\n \\n块被称为接收器枚举器的长度减去1。\\n \\n结果枚举器将块元素作为数组生成。\\n因此，可以如下调用+each+方法：\\n \n  enum.chunk_while { |elt_before, elt_after| bool }.each { |ary| ... }\n \\n枚举器类和可枚举模块的其他方法（如+to_a+、+map+等）也可用。\\n \\n例如，一个接一个递增的子序列可以按如下方式分块：\\n \n  a = [1,2,4,9,10,11,12,15,16,19,20,21]\n  b = a.chunk_while {|i, j| i+1 == j }\n  p b.to_a #=> [[1, 2], [4], [9, 10, 11, 12], [15, 16], [19, 20, 21]]\n  c = b.map {|a| a.length < 3 ? a : \"#{a.first}-#{a.last}\" }\n  p c #=> [[1, 2], [4], \"9-12\", [15, 16], \"19-21\"]\n  d = c.join(\",\")\n  p d #=> \"1,2,4,9-12,15,16,19-21\"\n \\n递增（非递减）的子序列可以按如下方式分块：\\n \n  a = [0, 9, 2, 2, 3, 2, 7, 5, 9, 5]\n  p a.chunk_while {|i, j| i <= j }.to_a\n  #=> [[0, 9], [2, 2, 3], [2, 7], [5, 9], [5]]\n \\n相邻的偶数和赔率可以按如下方式分块：\\n（可枚举的分块是另一种方法。）\\n \n  a = [7, 5, 9, 2, 0, 7, 9, 4, 2, 0]\n  p a.chunk_while {|i, j| i.even? == j.even? }.to_a\n  #=> [[7, 5, 9], [2, 0], [7, 9], [4, 2, 0]]\n \\n可枚举的分片\\u何时执行相同操作，但在执行以下操作时拆分除外：E块返回<code>true</code>而不是<code>false</code>。", "name": "find_index", "namespace": "Enumerable", "path": "Enumerable#find_index", "type": "module_function", "visibility": "public"}, "Enumerable#first": {"description": "为<i>枚举中的每个元素返回一个新数组，并返回运行<em>block的结果。\\n \\n如果没有给定块，则返回枚举器。n \n   (1..4).map { |i| i*i }      #=> [1, 4, 9, 16]\n   (1..4).collect { \"cat\"  }   #=> [\"cat\", \"cat\", \"cat\", \"cat\"]", "name": "first", "namespace": "Enumerable", "path": "Enumerable#first", "type": "module_function", "visibility": "public"}, "Enumerable#flat_map": {"description": "对于<i>枚举中的每个元素，返回一个新数组，其中包含\\n<em>block<em>once的串联结果。\\n \\n如果没有给定块，则返回枚举器。n \n   [1, 2, 3, 4].flat_map { |e| [e, -e] } #=> [1, -1, 2, -2, 3, -3, 4, -4]\n   [[1, 2], [3, 4]].flat_map { |e| e + [100] } #=> [1, 2, 100, 3, 4, 100]", "name": "flat_map", "namespace": "Enumerable", "path": "Enumerable#flat_map", "type": "module_function", "visibility": "public"}, "Enumerable#grep": {"description": "通过枚举返回+enum+中的项数。\\n如果给定参数，则计数+enum+中等于+item+的项数。如果给定了一个块，它将计算生成真值的元素的数量。n \n   ary = [1, 2, 4, 2]\n   ary.count               #=> 4\n   ary.count(2)            #=> 2\n   ary.count{ |x| x%2==0 } #=> 3", "name": "grep", "namespace": "Enumerable", "path": "Enumerable#grep", "type": "module_function", "visibility": "public"}, "Enumerable#grep_v": {"description": "调用<i>block<i>for each element of<i>enum<i>repeated n_u \\n times or forever if none or +nil+ is given.如果给定非正数或集合为空，则不执行任何操作。如果循环已完成但未中断，则返回+nil+。\\n \\n Enumerable Cycle将元素保存在内部数组中，因此在第一次传递之后更改为<i>Enum</i>\\n \\n如果没有给定块，则返回枚举器。\\n \n   a = [\"a\", \"b\", \"c\"]\n   a.cycle { |x| puts x }  # print, a, b, c, a, b, c,.. forever.\n a.cycle（2）x puts x print，a，b，c，a，b，c.", "name": "grep_v", "namespace": "Enumerable", "path": "Enumerable#grep_v", "type": "module_function", "visibility": "public"}, "Enumerable#group_by": {"description": "将<i>枚举中的每个条目传递给<em>block。返回第一个<em>block<em>is not false.如果没有匹配的对象，则调用<i>ifnone<i>并在指定时返回其结果，否则返回<code>nil</code>。\\n \\n如果没有给定块，则返回枚举器。n \n   (1..100).detect  => #<Enumerator: 1..100:detect>\n   (1..100).find    => #<Enumerator: 1..100:find>\n\n   (1..10).detect\t{ |i| i % 5 == 0 and i % 7 == 0 }   #=> nil\n   (1..10).find\t{ |i| i % 5 == 0 and i % 7 == 0 }   #=> nil\n   (1..100).detect\t{ |i| i % 5 == 0 and i % 7 == 0 }   #=> 35\n   (1..100).find\t{ |i| i % 5 == 0 and i % 7 == 0 }   #=> 35", "name": "group_by", "namespace": "Enumerable", "path": "Enumerable#group_by", "type": "module_function", "visibility": "public"}, "Enumerable#include?": {"description": "用给定的任意对象迭代每个元素的给定块，并返回最初给定的对象。\\n \\n如果没有给定块，则返回枚举器。n \n    evens = (1..10).each_with_object([]) { |i, a| a << i*2 }\n    #=> [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]", "name": "include?", "namespace": "Enumerable", "path": "Enumerable#include?", "type": "module_function", "visibility": "public", "return": [["Boolean"], ""]}, "Enumerable#inject": {"description": "可枚举grep的反转版本。\\n返回<i>枚举中每个元素的数组，而不是<code>Pattern === element</code>。n \n   (1..10).grep_v 2..5   #=> [1, 6, 7, 8, 9, 10]\n   res =(1..10).grep_v(2..5) { |v| v * 2 }\n   res                    #=> [2, 12, 14, 16, 18, 20]", "name": "inject", "namespace": "Enumerable", "path": "Enumerable#inject", "type": "module_function", "visibility": "public"}, "Enumerable#lazy": {"description": "为每个连续的元素数组迭代给定的块。如果没有给定块，则返回枚举器。\\n \\n例如：\n    (1..10).each_cons(3) { |a| p a }\n    # outputs below\n    [1, 2, 3]\n    [2, 3, 4]\n    [3, 4, 5]\n    [4, 5, 6]\n    [5, 6, 7]\n    [6, 7, 8]\n    [7, 8, 9]\n[8、9、10]", "name": "lazy", "namespace": "Enumerable", "path": "Enumerable#lazy", "type": "module_function", "visibility": "public"}, "Enumerable#map": {"description": "为+self+中的每个元素调用一次<i>block，将该元素作为参数传递，将多个值从yield转换为\\n数组。\\n \\n如果没有给定块，则返回枚举器。\\n \n   class Foo\n     include Enumerable\n     def each\n       yield 1\n       yield 1, 2\n       yield\n     end\n   end\n   Foo.new.each_entry{ |o| p o }\n \\n产生时间：\\n \n   1\n   [1, 2]\n nil", "name": "map", "namespace": "Enumerable", "path": "Enumerable#map", "type": "module_function", "visibility": "public"}, "Enumerable#max": {"description": "为<n>元素的每个切片迭代给定的块。如果没有给定块，则返回枚举器。\\n \n    (1..10).each_slice(3) { |a| p a }\n    # outputs below\n    [1, 2, 3]\n    [4, 5, 6]\n    [7, 8, 9]\n[10]", "name": "max", "namespace": "Enumerable", "path": "Enumerable#max", "type": "module_function", "visibility": "public"}, "Enumerable#max_by": {"description": "使用两个参数调用<em>block，item及其索引，用于<i>enum中的每个项。给定的参数传递给each（）。\\n \\n如果没有给定块，则返回枚举器。n \n   hash = Hash.new\n   %w(cat dog wombat).each_with_index { |item, index|\n     hash[item] = index\n   }\n   hash   #=> {\"cat\"=>0, \"dog\"=>1, \"wombat\"=>2}", "name": "max_by", "namespace": "Enumerable", "path": "Enumerable#max_by", "type": "module_function", "visibility": "public"}, "Enumerable#member?": {"description": "用给定的任意对象迭代每个元素的给定块，并返回最初给定的对象。\\n \\n如果没有给定块，则返回枚举器。n \n    evens = (1..10).each_with_object([]) { |i, a| a << i*2 }\n    #=> [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]", "name": "member?", "namespace": "Enumerable", "path": "Enumerable#member?", "type": "module_function", "visibility": "public", "return": [["Boolean"], ""]}, "Enumerable#min": {"description": "返回包含<i>枚举中的项的数组。n \n   (1..7).to_a                       #=> [1, 2, 3, 4, 5, 6, 7]\n   { 'a'=>1, 'b'=>2, 'c'=>3 }.to_a   #=> [[\"a\", 1], [\"b\", 2], [\"c\", 3]]\n\n   require 'prime'\n   Prime.entries 10                  #=> [2, 3, 5, 7]", "name": "min", "namespace": "Enumerable", "path": "Enumerable#min", "type": "module_function", "visibility": "public"}, "Enumerable#min_by": {"description": "将<i>枚举中的每个条目传递给<em>block。返回第一个<em>block<em>is not false.如果没有匹配的对象，则调用<i>ifnone<i>并在指定时返回其结果，否则返回<code>nil</code>。\\n \\n如果没有给定块，则返回枚举器。n \n   (1..100).detect  => #<Enumerator: 1..100:detect>\n   (1..100).find    => #<Enumerator: 1..100:find>\n\n   (1..10).detect\t{ |i| i % 5 == 0 and i % 7 == 0 }   #=> nil\n   (1..10).find\t{ |i| i % 5 == 0 and i % 7 == 0 }   #=> nil\n   (1..100).detect\t{ |i| i % 5 == 0 and i % 7 == 0 }   #=> 35\n   (1..100).find\t{ |i| i % 5 == 0 and i % 7 == 0 }   #=> 35", "name": "min_by", "namespace": "Enumerable", "path": "Enumerable#min_by", "type": "module_function", "visibility": "public"}, "Enumerable#minmax": {"description": "返回一个包含+enum+的所有元素的数组\\n其中给定的+block+返回一个真值。\\n \\n如果没有给定块，则返回枚举器。\\n \\n \n   (1..10).find_all { |i|  i % 3 == 0 }   #=> [3, 6, 9]\n\n   [1,2,3,4,5].select { |num|  num.even?  }   #=> [2, 4]\n \\n另请参阅可枚举拒绝。", "name": "minmax", "namespace": "Enumerable", "path": "Enumerable#minmax", "type": "module_function", "visibility": "public"}, "Enumerable#minmax_by": {"description": "将<i>枚举中的每个条目与<em>值进行比较，或将其传递给<em>block。返回第一个索引，其计算值为非false。如果没有对象匹配，则返回<code>nil</code> \\n \\n如果既没有给出块也没有给出参数，则返回枚举器。n \n   (1..10).find_index  { |i| i % 5 == 0 and i % 7 == 0 }  #=> nil\n   (1..100).find_index { |i| i % 5 == 0 and i % 7 == 0 }  #=> 34\n   (1..100).find_index(50)                                #=> 49", "name": "minmax_by", "namespace": "Enumerable", "path": "Enumerable#minmax_by", "type": "module_function", "visibility": "public"}, "Enumerable#none?": {"description": "返回可枚举的第一个元素或前+n+元素。\\n如果可枚举为空，则第一个窗体返回<code>nil</code>，第二个窗体返回空数组。n \n  %w[foo bar baz].first     #=> \"foo\"\n  %w[foo bar baz].first(2)  #=> [\"foo\", \"bar\"]\n  %w[foo bar baz].first(10) #=> [\"foo\", \"bar\", \"baz\"]\n  [].first                  #=> nil\n  [].first(10)              #=> []", "name": "none?", "namespace": "Enumerable", "path": "Enumerable#none?", "type": "module_function", "visibility": "public", "return": [["Boolean"], ""]}, "Enumerable#one?": {"description": "对于<i>枚举中的每个元素，返回一个新数组，其中包含\\n<em>block<em>once的串联结果。\\n \\n如果没有给定块，则返回枚举器。n \n   [1, 2, 3, 4].flat_map { |e| [e, -e] } #=> [1, -1, 2, -2, 3, -3, 4, -4]\n   [[1, 2], [3, 4]].flat_map { |e| e + [100] } #=> [1, 2, 100, 3, 4, 100]", "name": "one?", "namespace": "Enumerable", "path": "Enumerable#one?", "type": "module_function", "visibility": "public", "return": [["Boolean"], ""]}, "Enumerable#partition": {"description": "返回<i>枚举中每个元素的数组，其中<code>Pattern === element</code>。如果提供了可选的<em>块，则会将每个匹配元素传递给它，并且块的结果存储在输出数组中。n \n   (1..100).grep 38..44   #=> [38, 39, 40, 41, 42, 43, 44]\n   c = IO.constants\n   c.grep(/SEEK/)         #=> [:SEEK_SET, :SEEK_CUR, :SEEK_END]\n   res = c.grep(/SEEK/) { |v| IO.const_get(v) }\n   res                    #=> [0, 1, 2]", "name": "partition", "namespace": "Enumerable", "path": "Enumerable#partition", "type": "module_function", "visibility": "public"}, "Enumerable#reduce": {"description": "可枚举grep的反转版本。\\n返回<i>枚举中每个元素的数组，而不是<code>Pattern === element</code>。n \n   (1..10).grep_v 2..5   #=> [1, 6, 7, 8, 9, 10]\n   res =(1..10).grep_v(2..5) { |v| v * 2 }\n   res                    #=> [2, 12, 14, 16, 18, 20]", "name": "reduce", "namespace": "Enumerable", "path": "Enumerable#reduce", "type": "module_function", "visibility": "public"}, "Enumerable#reject": {"description": "按块的结果对集合进行分组。返回一个哈希，其中键是块的计算结果，值是集合中与键对应的元素数组。\\n \\n如果没有给定块，则返回枚举器。\\n n    (1..6).group_by { |i| i%3 }   #=> {0=>[3, 6], 1=>[1, 4], 2=>[2, 5]}", "name": "reject", "namespace": "Enumerable", "path": "Enumerable#reject", "type": "module_function", "visibility": "public"}, "Enumerable#reverse_each": {"description": "如果<i>enum的任何成员等于\\n<i>obj，则返回<code>true</code>。使用<code>==</code>测试均匀性。n \n   IO.constants.include? :SEEK_SET          #=> true\n   IO.constants.include? :SEEK_NO_FURTHER   #=> false\n   IO.constants.member? :SEEK_SET          #=> true\n   IO.constants.member? :SEEK_NO_FURTHER   #=> false", "name": "reverse_each", "namespace": "Enumerable", "path": "Enumerable#reverse_each", "type": "module_function", "visibility": "public"}, "Enumerable#select": {"description": "通过应用由一个名为方法或运算符的块或符号指定的二进制操作，组合<i>Enum的所有元素。\\n \\n<i>inject</i>and<i>reduce</i>methods are aliases.两者都没有性能优势。\\n \\n如果指定块，则对于<i>Enum中的每个元素，该块将传递一个累加器值（<i>Memo<i>）和该元素。\\n如果改为指定符号，则集合中的每个元素\\n都将传递给<i>memo的命名方法。\\n在这两种情况下，结果都将成为<i>备忘录的新值。\\n在迭代结束时，memo的最终值是方法的返回值。\\n \\n如果您没有明确指定<i>initial的值，则将collection的第一个元素用作<i>memo的初始值。\\n n \n   # Sum some numbers\n   (5..10).reduce(:+)                             #=> 45\n   # Same using a block and inject\n   (5..10).inject { |sum, n| sum + n }            #=> 45\n   # Multiply some numbers\n   (5..10).reduce(1, :*)                          #=> 151200\n   # Same using a block\n   (5..10).inject(1) { |product, n| product * n } #=> 151200\n   # find the longest word\n   longest = %w{ cat sheep bear }.inject do |memo, word|\n      memo.length > word.length ? memo : word\n   end\n   longest                                        #=> \"sheep\"", "name": "select", "namespace": "Enumerable", "path": "Enumerable#select", "type": "module_function", "visibility": "public"}, "Enumerable#slice_after": {"description": "返回一个惰性枚举器，其方法map/collect、\\n flat-map/collect-concat、select/find-all、reject、grep、grep-v、zip、take、\\n take-while、drop和drop_while仅根据需要枚举值。但是，如果将块赋给zip，则立即枚举值。\\n \\n==example \\n \\n下列程序查找勾股儿三元组：\\n \n  def pythagorean_triples\n    (1..Float::INFINITY).lazy.flat_map {|z|\n      (1..z).flat_map {|x|\n        (x..z).select {|y|\n          x**2 + y**2 == z**2\n        }.map {|y|\n          [x, y, z]\n        }\n      }\n    }\n  end\n  # show first ten pythagorean triples\n  p pythagorean_triples.take(10).force # take is lazy, so force is needed\n  p pythagorean_triples.first(10)      # first is eager\n  # show pythagorean triples less than 100\n p pythagorean_triples。take_while*，z| z<100.force", "name": "slice_after", "namespace": "Enumerable", "path": "Enumerable#slice_after", "type": "module_function", "visibility": "public"}, "Enumerable#slice_before": {"description": "为<i>枚举中的每个元素返回一个新数组，并返回运行<em>block的结果。\\n \\n如果没有给定块，则返回枚举器。n \n   (1..4).map { |i| i*i }      #=> [1, 4, 9, 16]\n   (1..4).collect { \"cat\"  }   #=> [\"cat\", \"cat\", \"cat\", \"cat\"]", "name": "slice_before", "namespace": "Enumerable", "path": "Enumerable#slice_before", "type": "module_function", "visibility": "public"}, "Enumerable#slice_when": {"description": "返回枚举中具有最大值的对象。第一个窗体假定所有对象都实现<code>Comparable</code>；\\n第二个窗体使用块返回<em>a<=>b。\\n \n   a = %w(albatross dog horse)\n   a.max                                   #=> \"horse\"\n   a.max { |a, b| a.length <=> b.length }  #=> \"albatross\"\n \\n如果给定+n+参数，则最多返回+n+个元素作为数组，按降序排序。n \n   a = %w[albatross dog horse]\n   a.max(2)                                  #=> [\"horse\", \"dog\"]\n   a.max(2) {|a, b| a.length <=> b.length }  #=> [\"albatross\", \"horse\"]\n   [5, 1, 3, 4, 2].max(3)                    #=> [5, 4, 3]", "name": "slice_when", "namespace": "Enumerable", "path": "Enumerable#slice_when", "type": "module_function", "visibility": "public"}, "Enumerable#sort": {"description": "返回“枚举”中的对象，该对象给出给定块的最大值。\\n \\n如果没有给定块，则返回枚举器。\\n \n   a = %w(albatross dog horse)\n   a.max_by { |x| x.length }   #=> \"albatross\"\n \\n如果给定+n+参数，则以数组形式返回最多+n+个元素。这些+n+元素按给定块中的值降序排序。\\n \n   a = %w[albatross dog horse]\n   a.max_by(2) {|x| x.length } #=> [\"albatross\", \"horse\"]\n \\n enum.max_by（n）可用于实现加权随机抽样。\\n下面的示例实现并使用Enumerable wsample。\\n \n   module Enumerable\n     # weighted random sampling.\n     #\n     # Pavlos S. Efraimidis, Paul G. Spirakis\n     # Weighted random sampling with a reservoir\n     # Information Processing Letters\n     # Volume 97, Issue 5 (16 March 2006)\n     def wsample(n)\n       self.max_by(n) {|v| rand ** (1.0/yield(v)) }\n     end\n   end\n   e = (-20..20).to_a*10000\n   a = e.wsample(20000) {|x|\n     Math.exp(-(x/5.0)**2) # normal distribution\n   }\n   # a is 20000 samples from e.\n   p a.length #=> 20000\n   h = a.group_by {|x| x }\n   -10.upto(10) {|x| puts \"*\" * (h[x].length/30.0).to_i if h[x] }\n   #=> *\n   #   ***\n   #   ******\n   #   ***********\n   #   ******************\n   #   *****************************\n   #   *****************************************\n   #   ****************************************************\n   #   ***************************************************************\n   #   ********************************************************************\n   #   ***********************************************************************\n   #   ***********************************************************************\n   #   **************************************************************\n   #   ****************************************************\n   #   ***************************************\n   #   ***************************\n   #   ******************\n   #   ***********\n   #   *******\n   #   ***\n*", "name": "sort", "namespace": "Enumerable", "path": "Enumerable#sort", "type": "module_function", "visibility": "public"}, "Enumerable#sort_by": {"description": "如果<i>enum的任何成员等于\\n<i>obj，则返回<code>true</code>。使用<code>==</code>测试均匀性。n \n   IO.constants.include? :SEEK_SET          #=> true\n   IO.constants.include? :SEEK_NO_FURTHER   #=> false\n   IO.constants.member? :SEEK_SET          #=> true\n   IO.constants.member? :SEEK_NO_FURTHER   #=> false", "name": "sort_by", "namespace": "Enumerable", "path": "Enumerable#sort_by", "type": "module_function", "visibility": "public"}, "Enumerable#sum": {"description": "返回枚举中具有最小值的对象。第一个窗体假定所有对象都实现<code>Comparable</code>；\\n第二个窗体使用块返回<em>a<=>b。\\n \n   a = %w(albatross dog horse)\n   a.min                                   #=> \"albatross\"\n   a.min { |a, b| a.length <=> b.length }  #=> \"dog\"\n \\n如果给定+n+参数，则返回至少+n+个元素作为排序数组。n \n   a = %w[albatross dog horse]\n   a.min(2)                                  #=> [\"albatross\", \"dog\"]\n   a.min(2) {|a, b| a.length <=> b.length }  #=> [\"dog\", \"horse\"]\n   [5, 1, 3, 4, 2].min(3)                    #=> [1, 2, 3]", "name": "sum", "namespace": "Enumerable", "path": "Enumerable#sum", "type": "module_function", "visibility": "public"}, "Enumerable#take": {"description": "返回枚举中的对象，该枚举给出给定块的最小值。\\n \\n如果没有给定块，则返回枚举器。\\n \n   a = %w(albatross dog horse)\n   a.min_by { |x| x.length }   #=> \"dog\"\n \\n如果给定+n+参数，则返回至少+n+个元素作为数组。这些+n+元素按给定块中的值排序。n \n   a = %w[albatross dog horse]\n   p a.min_by(2) {|x| x.length } #=> [\"dog\", \"horse\"]", "name": "take", "namespace": "Enumerable", "path": "Enumerable#take", "type": "module_function", "visibility": "public"}, "Enumerable#take_while": {"description": "返回包含可枚举的最小值和最大值的两元素数组。第一个窗体假设所有对象实现<code>Comparable</code>；第二个窗体使用块返回<em>a<=>b。n \n   a = %w(albatross dog horse)\n   a.minmax                                  #=> [\"albatross\", \"horse\"]\n   a.minmax { |a, b| a.length <=> b.length } #=> [\"dog\", \"albatross\"]", "name": "take_while", "namespace": "Enumerable", "path": "Enumerable#take_while", "type": "module_function", "visibility": "public"}, "Enumerable#to_a": {"description": "返回一个两元素数组，其中包含\\n<i>Enum中分别对应于给定块的最小值和最大值的对象。\\n \\n如果没有给定块，则返回枚举器。n \n   a = %w(albatross dog horse)\n   a.minmax_by { |x| x.length }   #=> [\"dog\", \"albatross\"]", "name": "to_a", "namespace": "Enumerable", "path": "Enumerable#to_a", "type": "module_function", "visibility": "public"}, "Enumerable#to_h": {"description": "将集合的每个元素传递给给定的块。如果块从未为所有元素返回<code>true</code>，则该方法返回<code>true</code>。如果未给定块，则仅当集合成员中没有一个为真时，<code>none?</code>才会返回\\n <code>true</code>。\\n \\n如果提供的是模式，则该方法将返回是否<code>pattern === element</code>（对于所有集合成员）。n \n   %w{ant bear cat}.none? { |word| word.length == 5 } #=> true\n   %w{ant bear cat}.none? { |word| word.length >= 4 } #=> false\n   %w{ant bear cat}.none?(/d/)                        #=> true\n   [1, 3.14, 42].none?(Float)                         #=> false\n   [].none?                                           #=> true\n   [nil].none?                                        #=> true\n   [nil, false].none?                                 #=> true\n   [nil, false, true].none?                           #=> false", "name": "to_h", "namespace": "Enumerable", "path": "Enumerable#to_h", "type": "module_function", "visibility": "public"}, "Enumerable#uniq": {"description": "将集合的每个元素传递给给定的块。如果块只返回一次<code>true</code>，则该方法返回<code>true</code>。如果未给定块，则只有当集合成员中的一个为真时，<code>one?</code>才会返回\\n <code>true</code>。\\n \\n如果提供了模式，则该方法将返回一个集合成员是否为<code>pattern === element</code>。n \n   %w{ant bear cat}.one? { |word| word.length == 4 }  #=> true\n   %w{ant bear cat}.one? { |word| word.length > 4 }   #=> false\n   %w{ant bear cat}.one? { |word| word.length < 4 }   #=> false\n   %w{ant bear cat}.one?(/t/)                         #=> false\n   [ nil, true, 99 ].one?                             #=> false\n   [ nil, true, false ].one?                          #=> true\n   [ nil, true, 99 ].one?(Integer)                    #=> true\n   [].one?                                            #=> false", "name": "uniq", "namespace": "Enumerable", "path": "Enumerable#uniq", "type": "module_function", "visibility": "public"}, "Enumerable#zip": {"description": "返回两个数组，第一个数组包含块计算结果为“真”的\\n<i>枚举的元素，第二个数组包含其余的元素。\\n \\n如果没有给定块，则返回枚举器。\\n n    (1..6).partition { |v| v.even? }  #=> [[2, 4, 6], [1, 3, 5]]", "name": "zip", "namespace": "Enumerable", "path": "Enumerable#zip", "type": "module_function", "visibility": "public"}, "Enumerator": {"description": "通过应用由一个名为方法或运算符的块或符号指定的二进制操作，组合<i>Enum的所有元素。\\n \\n<i>inject</i>and<i>reduce</i>methods are aliases.两者都没有性能优势。\\n \\n如果指定块，则对于<i>Enum中的每个元素，该块将传递一个累加器值（<i>Memo<i>）和该元素。\\n如果改为指定符号，则集合中的每个元素\\n都将传递给<i>memo的命名方法。\\n在这两种情况下，结果都将成为<i>备忘录的新值。\\n在迭代结束时，memo的最终值是方法的返回值。\\n \\n如果您没有明确指定<i>initial的值，则将collection的第一个元素用作<i>memo的初始值。\\n n \n   # Sum some numbers\n   (5..10).reduce(:+)                             #=> 45\n   # Same using a block and inject\n   (5..10).inject { |sum, n| sum + n }            #=> 45\n   # Multiply some numbers\n   (5..10).reduce(1, :*)                          #=> 151200\n   # Same using a block\n   (5..10).inject(1) { |product, n| product * n } #=> 151200\n   # find the longest word\n   longest = %w{ cat sheep bear }.inject do |memo, word|\n      memo.length > word.length ? memo : word\n   end\n   longest                                        #=> \"sheep\"", "name": "Enumerator", "namespace": "", "path": "Enumerator", "type": "class", "visibility": "public"}, "Enumerator#each": {"description": "为给定的+block+返回<code>false</code>的所有元素返回一个数组。\\n \\n如果没有给定块，则返回枚举器。\\n \n   (1..10).reject { |i|  i % 3 == 0 }   #=> [1, 2, 4, 5, 7, 8, 10]\n\n   [1, 2, 3, 4, 5].reject { |num| num.even? } #=> [1, 3, 5]\n \\n另请参阅可枚举的“全部查找”。", "name": "each", "namespace": "Enumerator", "path": "Enumerator#each", "type": "instance_method", "visibility": "public"}, "Enumerator#each_with_index": {"description": "生成临时数组并按相反顺序遍历该数组。\\n \\n如果没有给定块，则返回枚举器。\\n \n    (1..3).reverse_each { |v| p v }\n\n  produces:\n\n    3\n    2\n 1", "name": "each_with_index", "namespace": "Enumerator", "path": "Enumerator#each_with_index", "type": "instance_method", "visibility": "public"}, "Enumerator#each_with_object": {"description": "通过删除+self+中的重复值返回新数组。\\n \\n另请参阅数组uniq。", "name": "each_with_object", "namespace": "Enumerator", "path": "Enumerator#each_with_object", "type": "instance_method", "visibility": "public"}, "Enumerator#feed": {"description": "为每个分块元素创建枚举器。\\n块的结尾由模式和块定义。\\n \\n如果<code>_pattern_ === _elt_</code>返回<code>true</code>或块为元素返回<code>true</code>，则元素是块的结尾。\\n \\n <code>===</code>和块_u从_enum的第一个元素调用到最后一个元素。\\n \\n结果枚举器将块元素作为数组生成。\\n因此+each+方法可以如下调用：\\n \n  enum.slice_after(pattern).each { |ary| ... }\n  enum.slice_after { |elt| bool }.each { |ary| ... }\n \\n枚举器类和可枚举模块的其他方法（如+map+等）也可用。\\n \\n例如，续行（以反斜杠结尾的行）可以按如下方式连接：\\n \n  lines = [\"foo\\n\", \"bar\\\\\\n\", \"baz\\n\", \"\\n\", \"qux\\n\"]\n  e = lines.slice_after(/(?<!\\\\)\\n\\z/)\n  p e.to_a\n  #=> [[\"foo\\n\"], [\"bar\\\\\\n\", \"baz\\n\"], [\"\\n\"], [\"qux\\n\"]]\n  p e.map {|ll| ll[0...-1].map {|l| l.sub(/\\\\\\n\\z/, \"\") }.join + ll.last }\n=>[“foo \\n”，“barbaz \\n”，“\\n”，“qux \\n”]", "name": "feed", "namespace": "Enumerator", "path": "Enumerator#feed", "type": "instance_method", "visibility": "public"}, "Enumerator#initialize": {"description": "为每个分块元素创建枚举器。\\n块的开头由模式和块定义。\\n \\n如果<code>_pattern_ === _elt_</code>返回<code>true</code>或块为元素返回<code>true</code>，则元素是块的开头。\\n \\n <code>===</code>和块_u从_enum的第一个元素调用到最后一个元素。忽略第一个元素的结果。\\n \\n结果枚举器将块元素作为数组生成。\\n因此+each+方法可以如下调用：\\n \n  enum.slice_before(pattern).each { |ary| ... }\n  enum.slice_before { |elt| bool }.each { |ary| ... }\n \\n枚举器类和可枚举模块的其他方法（如+to_a+、+map+等）也可用。\\n \\n例如，超过ChangeLog个条目的迭代可以实现如下所示：\\n \n  # iterate over ChangeLog entries.\n  open(\"ChangeLog\") { |f|\n    f.slice_before(/\\A\\S/).each { |e| pp e }\n  }\n\n  # same as above.  block is used instead of pattern argument.\n  open(\"ChangeLog\") { |f|\n    f.slice_before { |line| /\\A\\S/ === line }.each { |e| pp e }\n  }\n \\n \\n“SVN_PROPLIST_R”为每个文件生成多行输出。\\n它们可以按如下方式分块：\\n \n  IO.popen([{\"LC_ALL\"=>\"C\"}, \"svn\", \"proplist\", \"-R\"]) { |f|\n    f.lines.slice_before(/\\AProp/).each { |lines| p lines }\n  }\n  #=> [\"Properties on '.':\\n\", \"  svn:ignore\\n\", \"  svk:merge\\n\"]\n  #   [\"Properties on 'goruby.c':\\n\", \"  svn:eol-style\\n\"]\n  #   [\"Properties on 'complex.c':\\n\", \"  svn:mime-type\\n\", \"  svn:eol-style\\n\"]\n  #   [\"Properties on 'regparse.c':\\n\", \"  svn:eol-style\\n\"]\n  #   ...\n \\n如果块需要在多个元素上保持状态，则可以使用局部变量。\\n例如，可以按如下方式挤压三个或更多连续递增的数字（有关更好的方法，请参阅+chunk_while+）：\\n \n  a = [0, 2, 3, 4, 6, 7, 9]\n  prev = a[0]\n  p a.slice_before { |e|\n    prev, prev2 = e, prev\n    prev2 + 1 != e\n  }.map { |es|\n    es.length <= 2 ? es.join(\",\") : \"#{es.first}-#{es.last}\"\n  }.join(\",\")\n  #=> \"0,2-4,6,7,9\"\n\\n但是，如果结果枚举器被枚举两次或更多，则应小心使用局部变量。\\n应为每个枚举初始化局部变量。\\n Enumerator.new可用于执行此操作。\\n \n  # Word wrapping.  This assumes all characters have same width.\n  def wordwrap(words, maxwidth)\n    Enumerator.new {|y|\n      # cols is initialized in Enumerator.new.\n      cols = 0\n      words.slice_before { |w|\n        cols += 1 if cols != 0\n        cols += w.length\n        if maxwidth < cols\n          cols = w.length\n          true\n        else\n          false\n        end\n      }.each {|ws| y.yield ws }\n    }\n  end\n  text = (1..20).to_a.join(\" \")\n  enum = wordwrap(text.split(/\\s+/), 10)\n  puts \"-\"*10\n  enum.each { |ws| puts ws.join(\" \") } # first enumeration.\n  puts \"-\"*10\n  enum.each { |ws| puts ws.join(\" \") } # second enumeration generates same result as the first.\n  puts \"-\"*10\n  #=> ----------\n  #   1 2 3 4 5\n  #   6 7 8 9 10\n  #   11 12 13\n  #   14 15 16\n  #   17 18 19\n  #   20\n  #   ----------\n  #   1 2 3 4 5\n  #   6 7 8 9 10\n  #   11 12 13\n  #   14 15 16\n  #   17 18 19\n  #   20\n  #   ----------\n \\n mbox包含一系列以unix-from-line开头的邮件。\\n因此，每个邮件都可以在Unix之前从行中按切片提取。\\n \n  # parse mbox\n  open(\"mbox\") { |f|\n    f.slice_before { |line|\n      line.start_with? \"From \"\n    }.each { |mail|\n      unix_from = mail.shift\n      i = mail.index(\"\\n\")\n      header = mail[0...i]\n      body = mail[(i+1)..-1]\n      body.pop if body.last == \"\\n\"\n      fields = header.slice_before { |line| !\" \\t\".include?(line[0]) }.to_a\n      p unix_from\n      pp fields\n      pp body\n    }\n  }\n\n  # split mails in mbox (slice before Unix From line after an empty line)\n  open(\"mbox\") { |f|\n    emp = true\n    f.slice_before { |line|\n      prevemp = emp\n      emp = line == \"\\n\"\n      prevemp && line.start_with?(\"From \")\n    }.each { |mail|\n      mail.pop if mail.last == \"\\n\"\n      pp mail\n    }\n_", "name": "initialize", "namespace": "Enumerator", "path": "Enumerator#initialize", "type": "instance_method", "visibility": "public"}, "Enumerator#initialize_copy": {"description": ":nodoc:", "name": "initialize_copy", "namespace": "Enumerator", "path": "Enumerator#initialize_copy", "type": "instance_method", "visibility": "public"}, "Enumerator#inspect": {"description": "为每个分块元素创建枚举器。\\n块的开头由块定义。\\n \\n此方法使用接收器枚举器中的相邻元素\\n elt-before和\\n elt-after-u拆分每个块。\\n此方法在返回<code>true</code>的块之前和之后拆分elt_和elt_之间的块。\\n \\n块被称为接收器枚举器的长度减去1。\\n \\n结果枚举器将块元素作为数组生成。\\n因此+each+方法可以如下调用：\\n \n  enum.slice_when { |elt_before, elt_after| bool }.each { |ary| ... }\n \\n枚举器类和可枚举模块的其他方法（如+to_a+、+map+等）也可用。\\n \\n例如，一个接一个递增的子序列可以按如下方式分块：\\n \n  a = [1,2,4,9,10,11,12,15,16,19,20,21]\n  b = a.slice_when {|i, j| i+1 != j }\n  p b.to_a #=> [[1, 2], [4], [9, 10, 11, 12], [15, 16], [19, 20, 21]]\n  c = b.map {|a| a.length < 3 ? a : \"#{a.first}-#{a.last}\" }\n  p c #=> [[1, 2], [4], \"9-12\", [15, 16], \"19-21\"]\n  d = c.join(\",\")\n  p d #=> \"1,2,4,9-12,15,16,19-21\"\n \\n排序数组中的近元素（阈值：6）可以按如下方式分块：\\n \n  a = [3, 11, 14, 25, 28, 29, 29, 41, 55, 57]\n  p a.slice_when {|i, j| 6 < j - i }.to_a\n  #=> [[3], [11, 14], [25, 28, 29, 29], [41], [55, 57]]\n \\n递增（非递减）子序列可以按如下方式分块：\\n \n  a = [0, 9, 2, 2, 3, 2, 7, 5, 9, 5]\n  p a.slice_when {|i, j| i > j }.to_a\n  #=> [[0, 9], [2, 2, 3], [2, 7], [5, 9], [5]]\n \\n相邻的偶数和赔率可以按如下方式分块：\\n（可枚举分块是另一种方式要执行此操作。）\\n \n  a = [7, 5, 9, 2, 0, 7, 9, 4, 2, 0]\n  p a.slice_when {|i, j| i.even? != j.even? }.to_a\n  #=> [[7, 5, 9], [2, 0], [7, 9], [4, 2, 0]]\n \\n段落（带有尾随空行的非空行）可以分块如下：\\n（请参见Enumerable Chunk以忽略空行。）\\n \n  lines = [\"foo\\n\", \"bar\\n\", \"\\n\", \"baz\\n\", \"qux\\n\"]\n  p lines.slice_when {|l1, l2| /\\A\\s*\\z/ =~ l1 && /\\S/ =~ l2 }.to_a\n  #=> [[\"foo\\n\", \"bar\\n\", \"\\n\"], [\"baz\\n\", \"qux\\n\"]]\n \\n Enumerable Chunk_，同时执行相同操作，除非块返回<code>false</code>而不是<code>true</code>时拆分。", "name": "inspect", "namespace": "Enumerator", "path": "Enumerator#inspect", "type": "instance_method", "visibility": "public"}, "Enumerator#next": {"description": "返回一个数组，其中包含<i>Enum<i>Sorted中的项。\\n \\n排序的比较将使用items的own \\n <code><=></code>运算符或可选代码块完成。\\n \\n区块必须在+a+与+b+之间执行比较，并在+b+与+a+之后传回小于0的整数，在+a+与+b+相等时传回+0+，或在+a+与+b+之后传回大于0的整数。\\n \\n无法保证结果稳定。当两个元素的比较返回+0+时，元素的顺序是不可预测的。\\n \n   %w(rhea kea flea).sort           #=> [\"flea\", \"kea\", \"rhea\"]\n   (1..10).sort { |a, b| b <=> a }  #=> [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n \\n另请参阅可枚举的排序依据。它实现了一个施瓦兹变换，这在关键计算或比较昂贵时很有用。", "name": "next", "namespace": "Enumerator", "path": "Enumerator#next", "type": "instance_method", "visibility": "public"}, "Enumerator#next_values": {"description": "使用通过映射给定块中的值生成的一组键对<i>Enum进行排序。\\n \\n无法保证结果稳定。当两个键相等时，相应元素的顺序是不可预测的。\\n \\n如果没有给定块，则返回枚举器。\\n \n   %w{apple pear fig}.sort_by { |word| word.length }\n                 #=> [\"fig\", \"pear\", \"apple\"]\n \\n <code>sort_by</code>的当前实现生成包含原始集合元素和映射值的\\n元组数组。这使得<code>sort_by</code>在密钥集简单的情况下相当昂贵。\\n \n   require 'benchmark'\n\n   a = (1..100000).map { rand(100000) }\n\n   Benchmark.bm(10) do |b|\n     b.report(\"Sort\")    { a.sort }\n     b.report(\"Sort by\") { a.sort_by { |a| a } }\n   end\n \\n<em>products:-<em>\\n \n   user     system      total        real\n   Sort        0.180000   0.000000   0.180000 (  0.175469)\n   Sort by     1.980000   0.040000   2.020000 (  2.013586)\n \\n然而，考虑比较键的情况是一个非常重要的操作。下面的代码使用基本的<code>sort</code>方法在修改时对一些文件进行排序。\\n \n   files = Dir[\"*\"]\n   sorted = files.sort { |a, b| File.new(a).mtime <=> File.new(b).mtime }\n   sorted   #=> [\"mon\", \"tues\", \"wed\", \"thurs\"]\n \\n此排序效率低下：它在每次比较期间生成两个新的<code>File</code>对象。更好的技术是使用<code>Kernel#test</code>方法直接生成修改次数。\\n \n   files = Dir[\"*\"]\n   sorted = files.sort { |a, b|\n     test(?M, a) <=> test(?M, b)\n   }\n   sorted   #=> [\"mon\", \"tues\", \"wed\", \"thurs\"]\n \\n这仍会产生许多不必要的<code>Time</code>物件。一种更有效的技术是在排序之前缓存排序键（在本例中是\\n次修改）。Perl用户通常将这种方法称为Schwartzian转换，仅次于Randal Schwartz。我们构建一个临时数组，其中每个元素都是一个数组，其中包含排序键和文件名。我们对这个数组进行排序，然后从结果中提取文件名。\\n \n   sorted = Dir[\"*\"].collect { |f|\n      [test(?M, f), f]\n   }.sort.collect { |f| f[1] }\n   sorted   #=> [\"mon\", \"tues\", \"wed\", \"thurs\"]\n \\n这正是<code>sort_by</code>在内部所做的。n \n   sorted = Dir[\"*\"].sort_by { |f| test(?M, f) }\n   sorted   #=> [\"mon\", \"tues\", \"wed\", \"thurs\"]", "name": "next_values", "namespace": "Enumerator", "path": "Enumerator#next_values", "type": "instance_method", "visibility": "public"}, "Enumerator#peek": {"description": "返回可枚举的元素的和。\\n \\n如果给定了块，则在添加前将该块应用于每个元素。\\n \\n如果<i>枚举</i>为空，则返回<i>i n it。\\n \\n例如：\\n \n  { 1 => 10, 2 => 20 }.sum {|k, v| k * v }  #=> 50\n  (1..10).sum                               #=> 55\n  (1..10).sum {|v| v * 2 }                  #=> 110\n  [Object.new].each.sum                     #=> TypeError\n \\n此方法可以通过explicit<i>init<i>参数用于非数字对象。\\n \n  { 1 => 10, 2 => 20 }.sum([])                   #=> [1, 10, 2, 20]\n  \"a\\nb\\nc\".each_line.lazy.map(&:chomp).sum(\"\")  #=> \"abc\"\n \\n Enumerable Sum方法可能不考虑“+”\\n方法的方法重新定义，如integer+。", "name": "peek", "namespace": "Enumerator", "path": "Enumerator#peek", "type": "instance_method", "visibility": "public"}, "Enumerator#peek_values": {"description": "返回<i>枚举中的前n个元素。n \n   a = [1, 2, 3, 4, 5, 0]\n   a.take(3)             #=> [1, 2, 3]\n   a.take(30)            #=> [1, 2, 3, 4, 5, 0]", "name": "peek_values", "namespace": "Enumerator", "path": "Enumerator#peek_values", "type": "instance_method", "visibility": "public"}, "Enumerator#rewind": {"description": "将元素传递到块，直到块返回+nil+或+false+，然后停止迭代并返回所有先前元素的数组。\\n \\n如果没有给定块，则返回枚举器。n \n   a = [1, 2, 3, 4, 5, 0]\n   a.take_while { |i| i < 3 }   #=> [1, 2]", "name": "rewind", "namespace": "Enumerator", "path": "Enumerator#rewind", "type": "instance_method", "visibility": "public"}, "Enumerator#size": {"description": "返回包含<i>枚举中的项的数组。n \n   (1..7).to_a                       #=> [1, 2, 3, 4, 5, 6, 7]\n   { 'a'=>1, 'b'=>2, 'c'=>3 }.to_a   #=> [[\"a\", 1], [\"b\", 2], [\"c\", 3]]\n\n   require 'prime'\n   Prime.entries 10                  #=> [2, 3, 5, 7]", "name": "size", "namespace": "Enumerator", "path": "Enumerator#size", "type": "instance_method", "visibility": "public"}, "Enumerator#with_index": {"description": "返回将<i>enum<i>解释为\\n<tt>[key，value]<tt>对列表的结果。n \n   %i[hello world].each_with_index.to_h\n     # => {:hello => 0, :world => 1}", "name": "with_index", "namespace": "Enumerator", "path": "Enumerator#with_index", "type": "instance_method", "visibility": "public"}, "Enumerator#with_object": {"description": "通过删除+self+中的重复值返回新数组。\\n \\n另请参阅数组uniq。", "name": "with_object", "namespace": "Enumerator", "path": "Enumerator#with_object", "type": "instance_method", "visibility": "public"}, "Enumerator::Generator": {"description": "", "name": "Generator", "namespace": "Enumerator", "path": "Enumerator::Generator", "type": "class", "visibility": "public"}, "Enumerator::Generator#each": {"description": ":nodoc:", "name": "each", "namespace": "Enumerator::Generator", "path": "Enumerator::Generator#each", "type": "instance_method", "visibility": "public"}, "Enumerator::Generator#initialize": {"description": ":nodoc:", "name": "initialize", "namespace": "Enumerator::Generator", "path": "Enumerator::Generator#initialize", "type": "instance_method", "visibility": "public"}, "Enumerator::Generator#initialize_copy": {"description": ":nodoc:", "name": "initialize_copy", "namespace": "Enumerator::Generator", "path": "Enumerator::Generator#initialize_copy", "type": "instance_method", "visibility": "public"}, "Enumerator::Lazy": {"description": "", "name": "Lazy", "namespace": "Enumerator", "path": "Enumerator::Lazy", "type": "class", "visibility": "public"}, "Enumerator::Lazy#chunk": {"description": "", "name": "chunk", "namespace": "Enumerator::Lazy", "path": "Enumerator::Lazy#chunk", "type": "instance_method", "visibility": "public"}, "Enumerator::Lazy#chunk_while": {"description": "", "name": "chunk_while", "namespace": "Enumerator::Lazy", "path": "Enumerator::Lazy#chunk_while", "type": "instance_method", "visibility": "public"}, "Enumerator::Lazy#collect": {"description": "", "name": "collect", "namespace": "Enumerator::Lazy", "path": "Enumerator::Lazy#collect", "type": "instance_method", "visibility": "public"}, "Enumerator::Lazy#collect_concat": {"description": "根据该枚举器的构造对块进行迭代。\\n如果没有给出块和参数，则返回self。\\n \\n==示例\n  \"Hello, world!\".scan(/\\w+/)                     #=> [\"Hello\", \"world\"]\n  \"Hello, world!\".to_enum(:scan, /\\w+/).to_a      #=> [\"Hello\", \"world\"]\n  \"Hello, world!\".to_enum(:scan).each(/\\w+/).to_a #=> [\"Hello\", \"world\"]\n\n  obj = Object.new\n\n  def obj.each_arg(a, b=:b, *rest)\n    yield a\n    yield b\n    yield rest\n    :method_returned\n  end\n\n  enum = obj.to_enum :each_arg, :a, :x\n\n  enum.each.to_a                  #=> [:a, :x, []]\n  enum.each.equal?(enum)          #=> true\n  enum.each { |elm| elm }         #=> :method_returned\n\n  enum.each(:y, :z).to_a          #=> [:a, :x, [:y, :z]]\n  enum.each(:y, :z).equal?(enum)  #=> false\n  enum.each(:y, :z) { |elm| elm } #=> :method_returned", "name": "collect_concat", "namespace": "Enumerator::Lazy", "path": "Enumerator::Lazy#collect_concat", "type": "instance_method", "visibility": "public"}, "Enumerator::Lazy#drop": {"description": "", "name": "drop", "namespace": "Enumerator::Lazy", "path": "Enumerator::Lazy#drop", "type": "instance_method", "visibility": "public"}, "Enumerator::Lazy#drop_while": {"description": "", "name": "drop_while", "namespace": "Enumerator::Lazy", "path": "Enumerator::Lazy#drop_while", "type": "instance_method", "visibility": "public"}, "Enumerator::Lazy#enum_for": {"description": "使用任意对象+obj+对每个元素的给定块进行迭代，并返回+obj+ \\n \\n如果没有给定块，则返回新的枚举器。\\n \\n==示例\n  to_three = Enumerator.new do |y|\n    3.times do |x|\n      y << x\n    end\n  end\n\n  to_three_with_string = to_three.with_object(\"foo\")\n  to_three_with_string.each do |x,string|\n    puts \"#{string}: #{x}\"\n  end\n\n  # => foo:0\n  # => foo:1\n  # => foo:2", "name": "enum_for", "namespace": "Enumerator::Lazy", "path": "Enumerator::Lazy#enum_for", "type": "instance_method", "visibility": "public"}, "Enumerator::Lazy#find_all": {"description": "", "name": "find_all", "namespace": "Enumerator::Lazy", "path": "Enumerator::Lazy#find_all", "type": "instance_method", "visibility": "public"}, "Enumerator::Lazy#flat_map": {"description": "根据该枚举器的构造对块进行迭代。\\n如果没有给出块和参数，则返回self。\\n \\n==示例\n  \"Hello, world!\".scan(/\\w+/)                     #=> [\"Hello\", \"world\"]\n  \"Hello, world!\".to_enum(:scan, /\\w+/).to_a      #=> [\"Hello\", \"world\"]\n  \"Hello, world!\".to_enum(:scan).each(/\\w+/).to_a #=> [\"Hello\", \"world\"]\n\n  obj = Object.new\n\n  def obj.each_arg(a, b=:b, *rest)\n    yield a\n    yield b\n    yield rest\n    :method_returned\n  end\n\n  enum = obj.to_enum :each_arg, :a, :x\n\n  enum.each.to_a                  #=> [:a, :x, []]\n  enum.each.equal?(enum)          #=> true\n  enum.each { |elm| elm }         #=> :method_returned\n\n  enum.each(:y, :z).to_a          #=> [:a, :x, [:y, :z]]\n  enum.each(:y, :z).equal?(enum)  #=> false\n  enum.each(:y, :z) { |elm| elm } #=> :method_returned", "name": "flat_map", "namespace": "Enumerator::Lazy", "path": "Enumerator::Lazy#flat_map", "type": "instance_method", "visibility": "public"}, "Enumerator::Lazy#force": {"description": "", "name": "force", "namespace": "Enumerator::Lazy", "path": "Enumerator::Lazy#force", "type": "instance_method", "visibility": "public"}, "Enumerator::Lazy#grep": {"description": "", "name": "grep", "namespace": "Enumerator::Lazy", "path": "Enumerator::Lazy#grep", "type": "instance_method", "visibility": "public"}, "Enumerator::Lazy#grep_v": {"description": "", "name": "grep_v", "namespace": "Enumerator::Lazy", "path": "Enumerator::Lazy#grep_v", "type": "instance_method", "visibility": "public"}, "Enumerator::Lazy#initialize": {"description": "与枚举器和索引（0）相同，即没有起始偏移量。\\n \\n如果没有给定块，则返回包含索引的新枚举器。", "name": "initialize", "namespace": "Enumerator::Lazy", "path": "Enumerator::Lazy#initialize", "type": "instance_method", "visibility": "public"}, "Enumerator::Lazy#lazy": {"description": "", "name": "lazy", "namespace": "Enumerator::Lazy", "path": "Enumerator::Lazy#lazy", "type": "instance_method", "visibility": "public"}, "Enumerator::Lazy#map": {"description": "", "name": "map", "namespace": "Enumerator::Lazy", "path": "Enumerator::Lazy#map", "type": "instance_method", "visibility": "public"}, "Enumerator::Lazy#reject": {"description": "", "name": "reject", "namespace": "Enumerator::Lazy", "path": "Enumerator::Lazy#reject", "type": "instance_method", "visibility": "public"}, "Enumerator::Lazy#select": {"description": "", "name": "select", "namespace": "Enumerator::Lazy", "path": "Enumerator::Lazy#select", "type": "instance_method", "visibility": "public"}, "Enumerator::Lazy#slice_after": {"description": "", "name": "slice_after", "namespace": "Enumerator::Lazy", "path": "Enumerator::Lazy#slice_after", "type": "instance_method", "visibility": "public"}, "Enumerator::Lazy#slice_before": {"description": "", "name": "slice_before", "namespace": "Enumerator::Lazy", "path": "Enumerator::Lazy#slice_before", "type": "instance_method", "visibility": "public"}, "Enumerator::Lazy#slice_when": {"description": "", "name": "slice_when", "namespace": "Enumerator::Lazy", "path": "Enumerator::Lazy#slice_when", "type": "instance_method", "visibility": "public"}, "Enumerator::Lazy#take": {"description": "", "name": "take", "namespace": "Enumerator::Lazy", "path": "Enumerator::Lazy#take", "type": "instance_method", "visibility": "public"}, "Enumerator::Lazy#take_while": {"description": "", "name": "take_while", "namespace": "Enumerator::Lazy", "path": "Enumerator::Lazy#take_while", "type": "instance_method", "visibility": "public"}, "Enumerator::Lazy#to_enum": {"description": "使用任意对象+obj+对每个元素的给定块进行迭代，并返回+obj+ \\n \\n如果没有给定块，则返回新的枚举器。\\n \\n==示例\n  to_three = Enumerator.new do |y|\n    3.times do |x|\n      y << x\n    end\n  end\n\n  to_three_with_string = to_three.with_object(\"foo\")\n  to_three_with_string.each do |x,string|\n    puts \"#{string}: #{x}\"\n  end\n\n  # => foo:0\n  # => foo:1\n  # => foo:2", "name": "to_enum", "namespace": "Enumerator::Lazy", "path": "Enumerator::Lazy#to_enum", "type": "instance_method", "visibility": "public"}, "Enumerator::Lazy#uniq": {"description": "", "name": "uniq", "namespace": "Enumerator::Lazy", "path": "Enumerator::Lazy#uniq", "type": "instance_method", "visibility": "public"}, "Enumerator::Lazy#zip": {"description": "", "name": "zip", "namespace": "Enumerator::Lazy", "path": "Enumerator::Lazy#zip", "type": "instance_method", "visibility": "public"}, "Enumerator::Yielder": {"description": "", "name": "Yielder", "namespace": "Enumerator", "path": "Enumerator::Yielder", "type": "class", "visibility": "public"}, "Enumerator::Yielder#<<": {"description": ":nodoc:", "name": "<<", "namespace": "Enumerator::Yielder", "path": "Enumerator::Yielder#<<", "type": "instance_method", "visibility": "public"}, "Enumerator::Yielder#initialize": {"description": ":nodoc:", "name": "initialize", "namespace": "Enumerator::Yielder", "path": "Enumerator::Yielder#initialize", "type": "instance_method", "visibility": "public"}, "Enumerator::Yielder#yield": {"description": ":nodoc:", "name": "yield", "namespace": "Enumerator::Yielder", "path": "Enumerator::Yielder#yield", "type": "instance_method", "visibility": "public"}, "StopIteration": {"description": "设置+e+内下一个收益率返回的值。\\n \\n如果未设定值，收益率将传回nil。\\n \\n此值在生成后被清除。\\n \n  # Array#map passes the array's elements to \"yield\" and collects the\n  # results of \"yield\" as an array.\n  # Following example shows that \"next\" returns the passed elements and\n  # values passed to \"feed\" are collected as an array which can be\n  # obtained by StopIteration#result.\n  e = [1,2,3].map\n  p e.next           #=> 1\n  e.feed \"a\"\n  p e.next           #=> 2\n  e.feed \"b\"\n  p e.next           #=> 3\n  e.feed \"c\"\n  begin\n    e.next\n  rescue StopIteration\n    p $!.result      #=> [\"a\", \"b\", \"c\"]\n  end\n\n  o = Object.new\n  def o.each\n    x = yield         # (2) blocks\n    p x               # (5) => \"foo\"\n    x = yield         # (6) blocks\n    p x               # (8) => nil\n    x = yield         # (9) blocks\n    p x               # not reached w/o another e.next\n  end\n\n  e = o.to_enum\n  e.next              # (1)\n  e.feed \"foo\"        # (3)\n  e.next              # (4)\n  e.next              # (7)\n（10）", "name": "StopIteration", "namespace": "", "path": "StopIteration", "type": "class", "visibility": "public"}, "StopIteration#result": {"description": "创建一个新的枚举器对象，该对象可以用作\\n可枚举的。\\n \\n在第一种形式中，迭代是由给定的块定义的，其中“yielder”对象（作为块参数给定）可用于通过调用+yield+方法（别名为+<<+）生成值：\n  fib = Enumerator.new do |y|\n    a = b = 1\n    loop do\n      y << a\n      a, b = b, a + b\n    end\n  end\n\n  p fib.take(10) # => [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n \\n可选参数可用于指定如何以惰性方式计算大小（请参见枚举器大小）。它可以是值，也可以是可调用对象。\\n \\n在第二个不推荐使用的表单中，生成的枚举器使用给定的方法在给定的对象上迭代，并传递给定的参数。\\n \\n不鼓励使用此表单。使用kernel enum_for或kernel to_enum代替。\\n \n  e = Enumerator.new(ObjectSpace, :each_object)\n      #-> ObjectSpace.enum_for(:each_object)\n \\n   e.select { |obj| obj.is_a?(Class) }  #=> array of all classes", "name": "result", "namespace": "StopIteration", "path": "StopIteration#result", "type": "instance_method", "visibility": "public"}, "Warning": {"description": "创建可打印版本的。", "name": "Warning", "namespace": "", "path": "Warning", "type": "module", "visibility": "public"}, "Warning#warn": {"description": "返回枚举器中的下一个对象，并向前移动内部位置。当到达末端位置时，上升StopIteration。\\n \\n==示例\n  a = [1,2,3]\n  e = a.to_enum\n  p e.next   #=> 1\n  p e.next   #=> 2\n  p e.next   #=> 3\n  p e.next   #raises StopIteration\n \\n请注意，+next+的枚举序列不会影响其他非外部枚举方法，除非基础迭代方法本身具有副作用，例如IO每行。", "name": "warn", "namespace": "Warning", "path": "Warning#warn", "type": "module_function", "visibility": "public"}, "Warning::buffer": {"description": "", "name": "buffer", "namespace": "Warning", "path": "Warning::buffer", "type": "class", "visibility": "public"}, "Warning::buffer#write": {"description": "", "name": "write", "namespace": "Warning::buffer", "path": "Warning::buffer#write", "type": "instance_method", "visibility": "public"}, "Errno": {"description": "以枚举器中的数组形式返回下一个对象，并向前移动内部位置。当到达末端位置时，升高StopIteration。\\n \\n此方法可用于区分<code>yield</code>和<code>yield\nnil</code>。\\n \\n==示例\n  o = Object.new\n  def o.each\n    yield\n    yield 1\n    yield 1, 2\n    yield nil\n    yield [1, 2]\n  end\n  e = o.to_enum\n  p e.next_values\n  p e.next_values\n  p e.next_values\n  p e.next_values\n  p e.next_values\n  e = o.to_enum\n  p e.next\n  p e.next\n  p e.next\n  p e.next\n  p e.next\n\n  ## yield args       next_values      next\n  #  yield            []               nil\n  #  yield 1          [1]              1\n  #  yield 1, 2       [1, 2]           [1, 2]\n  #  yield nil        [nil]            nil\n  #  yield [1, 2]     [[1, 2]]         [1, 2]\n \\n请注意，+next_values+不会影响其他非外部枚举方法，除非基础迭代方法本身具有副作用，例如\\n IO每行。", "name": "Errno", "namespace": "", "path": "Errno", "type": "module", "visibility": "public"}, "StandardError": {"description": "返回枚举器中的下一个对象，但不向前移动内部位置。如果位置已经在末尾，则将提升StopIteration\\n。\\n \\n==示例\n  a = [1,2,3]\n  e = a.to_enum\n  p e.next   #=> 1\n  p e.peek   #=> 2\n  p e.peek   #=> 2\n  p e.peek   #=> 2\n  p e.next   #=> 2\n  p e.next   #=> 3\n P e.peek引发StopIteration", "name": "StandardError", "namespace": "", "path": "StandardError", "type": "class", "visibility": "public"}, "SystemExit": {"description": "以数组形式返回下一个对象，类似于枚举器下一个值，但不向前移动内部位置。如果位置已经在末端，则提升StopIteration。\\n \\n==示例\n  o = Object.new\n  def o.each\n    yield\n    yield 1\n    yield 1, 2\n  end\n  e = o.to_enum\n  p e.peek_values    #=> []\n  e.next\n  p e.peek_values    #=> [1]\n  p e.peek_values    #=> [1]\n  e.next\n  p e.peek_values    #=> [1, 2]\n  e.next\n P e.peek_values引发StopIteration", "name": "SystemExit", "namespace": "", "path": "SystemExit", "type": "class", "visibility": "public"}, "SystemExit#initialize": {"description": "将枚举序列倒回开头。\\n \\n如果封闭的对象响应“rewind”方法，则调用该方法。", "name": "initialize", "namespace": "SystemExit", "path": "SystemExit#initialize", "type": "instance_method", "visibility": "public"}, "SystemExit#status": {"description": "返回枚举器的大小，如果不能延迟计算，则返回+nil+。n \n  (1..100).to_a.permutation(4).size # => 94109400\n  loop.size # => Float::INFINITY\n  (1..100).drop_while.size # => nil", "name": "status", "namespace": "SystemExit", "path": "SystemExit#status", "type": "instance_method", "visibility": "public"}, "SystemExit#success?": {"description": "使用索引（从+offset+开始）迭代每个元素的给定块。如果没有给定块，则返回包含索引的新枚举器，从+offset+开始\\n\\n+offset+：：要使用的起始索引", "name": "success?", "namespace": "SystemExit", "path": "SystemExit#success?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "SignalException": {"description": "使用任意对象+obj+对每个元素的给定块进行迭代，并返回+obj+ \\n \\n如果没有给定块，则返回新的枚举器。\\n \\n==示例\n  to_three = Enumerator.new do |y|\n    3.times do |x|\n      y << x\n    end\n  end\n\n  to_three_with_string = to_three.with_object(\"foo\")\n  to_three_with_string.each do |x,string|\n    puts \"#{string}: #{x}\"\n  end\n\n  # => foo:0\n  # => foo:1\n  # => foo:2", "name": "SignalException", "namespace": "", "path": "SignalException", "type": "class", "visibility": "public"}, "SignalException#initialize": {"description": "对于<i>lazy>中的每个元素，返回一个新的lazy枚举器，该枚举器具有串联的运行结果\\n<i>block.<i>once。\\n \n  [\"foo\", \"bar\"].lazy.flat_map {|i| i.each_char.lazy}.force\n  #=> [\"f\", \"o\", \"o\", \"b\", \"a\", \"r\"]\n \\n如果以下任一条件为真，则返回值<i>x</i>returned by<i>block</i>is discorporated:\\n \n  a) <i>x</i> responds to both each and force, which means that\n     <i>x</i> is a lazy enumerator.\n  b) <i>x</i> is an array or responds to to_ary.\n \\n否则，<i>x</i>is contained as is i n the return value.n \n  [{a:1}, {b:2}].lazy.flat_map {|i| i}.force\n  #=> [{:a=>1}, {:b=>2}]", "name": "initialize", "namespace": "SignalException", "path": "SignalException#initialize", "type": "instance_method", "visibility": "public"}, "SignalException#signo": {"description": "与kernel to枚举类似，只是它返回一个懒惰的枚举器。\\n这使得定义可枚举方法变得容易，如果从惰性枚举器调用，这些方法自然会保持惰性。\\n \\n例如，从kernel中的示例继续到\\u enum:\\n \n  # See Kernel#to_enum for the definition of repeat\n  r = 1..Float::INFINITY\n  r.repeat(2).first(5) # => [1, 1, 2, 2, 3]\n  r.repeat(2).class # => Enumerator\n  r.repeat(2).map{|n| n ** 2}.first(5) # => endless loop!\n  # works naturally on lazy enumerator:\n  r.lazy.repeat(2).class # => Enumerator::Lazy\n  r.lazy.repeat(2).map{|n| n ** 2}.first(5) # => [1, 1, 4, 4, 9]", "name": "signo", "namespace": "SignalException", "path": "SignalException#signo", "type": "instance_method", "visibility": "public"}, "Interrupt": {"description": "对于<i>lazy>中的每个元素，返回一个新的lazy枚举器，该枚举器具有串联的运行结果\\n<i>block.<i>once。\\n \n  [\"foo\", \"bar\"].lazy.flat_map {|i| i.each_char.lazy}.force\n  #=> [\"f\", \"o\", \"o\", \"b\", \"a\", \"r\"]\n \\n如果以下任一条件为真，则值<i>x</i>returned by<i>block</i>is discorporated:\\n \n  a) <i>x</i> responds to both each and force, which means that\n     <i>x</i> is a lazy enumerator.\n  b) <i>x</i> is an array or responds to to_ary.\n \\n否则，<i>x</i>is contained as is i n the return value.n \n  [{a:1}, {b:2}].lazy.flat_map {|i| i}.force\n  #=> [{:a=>1}, {:b=>2}]", "name": "Interrupt", "namespace": "", "path": "Interrupt", "type": "class", "visibility": "public"}, "Interrupt#initialize": {"description": ":nodoc:", "name": "initialize", "namespace": "Interrupt", "path": "Interrupt#initialize", "type": "instance_method", "visibility": "public"}, "TypeError": {"description": "创建新的惰性枚举器。当实际枚举枚举器时（例如通过调用force），将枚举+obj+并将每个值传递给给定的块。块可以使用+yielder+返回值。\\n例如，要以懒惰和非懒惰的方式创建方法+filter_map+，请执行以下操作：\\n \n  module Enumerable\n    def filter_map(&block)\n      map(&block).compact\n    end\n  end\n\n  class Enumerator::Lazy\n    def filter_map\n      Lazy.new(self) do |yielder, *values|\n        result = yield *values\n        yielder << result if result\n      end\n    end\n  end\n\n  (1..Float::INFINITY).lazy.filter_map{|i| i*i if i.even?}.first(5)\n      # => [4, 16, 36, 64, 100]", "name": "TypeError", "namespace": "", "path": "TypeError", "type": "class", "visibility": "public"}, "ArgumentError": {"description": "与kernel to枚举类似，只是它返回一个懒惰的枚举器。\\n这使得定义可枚举方法变得容易，如果从惰性枚举器调用，这些方法自然会保持惰性。\\n \\n例如，从kernel中的示例继续到\\u enum:\\n \n  # See Kernel#to_enum for the definition of repeat\n  r = 1..Float::INFINITY\n  r.repeat(2).first(5) # => [1, 1, 2, 2, 3]\n  r.repeat(2).class # => Enumerator\n  r.repeat(2).map{|n| n ** 2}.first(5) # => endless loop!\n  # works naturally on lazy enumerator:\n  r.lazy.repeat(2).class # => Enumerator::Lazy\n  r.lazy.repeat(2).map{|n| n ** 2}.first(5) # => [1, 1, 4, 4, 9]", "name": "ArgumentError", "namespace": "", "path": "ArgumentError", "type": "class", "visibility": "public"}, "IndexError": {"description": "引发以停止迭代，特别是由枚举器next引发。它被内核循环挽救。\\n \n  loop do\n    puts \"Hello\"\n    raise StopIteration\n    puts \"World\"\n  end\n  puts \"Done!\"\n \\n<em>生成：.<em>\\n \n  Hello\n done！", "name": "IndexError", "namespace": "", "path": "IndexError", "type": "class", "visibility": "public"}, "KeyError": {"description": "返回迭代器的返回值。\\n \n  o = Object.new\n  def o.each\n    yield 1\n    yield 2\n    yield 3\n    100\n  end\n\n  e = o.to_enum\n\n  puts e.next                   #=> 1\n  puts e.next                   #=> 2\n  puts e.next                   #=> 3\n\n  begin\n    e.next\n  rescue StopIteration => ex\n    puts ex.result              #=> 100\n结束", "name": "KeyError", "namespace": "", "path": "KeyError", "type": "class", "visibility": "public"}, "KeyError#key": {"description": "警告模块包含一个名为warn的方法，该模块自行扩展，使<code>Warning.warn</code>可用。\\n对于Ruby发出的所有警告，将调用Warning.warn。\\n默认情况下，警告将打印到$stderr。\\n \\n通过覆盖warning.warn，您可以更改Ruby处理警告的方式，或者过滤一些警告，和/或将警告输出到$stderr以外的其他地方。当Warning.warn被重写时，可以调用super以获取将警告打印到$stderr的默认行为。", "name": "key", "namespace": "KeyError", "path": "KeyError#key", "type": "instance_method", "visibility": "public"}, "KeyError#receiver": {"description": "将警告消息+msg+写入$stderr，如果消息未以新行结尾，则后面跟着新行。Ruby为所有发出的警告调用此方法。", "name": "receiver", "namespace": "KeyError", "path": "KeyError#receiver", "type": "instance_method", "visibility": "public"}, "RangeError": {"description": "Ruby异常对象是<code>Exception</code>的子类。但是，操作系统通常使用普通整数报告错误。模块<code>Errno</code>是动态创建的，用于将这些操作系统错误映射到Ruby类，每个错误号生成自己的子类<code>SystemCallError</code>。\\n在模块<code>Errno</code>中创建子类时，其名称将从<code>Errno::</code>开始。\\n \\n <code>Errno::</code>类的名称取决于运行ruby的环境。在典型的UNIX或Windows平台上，有<code>Errno</code>个类，如<code>Errno::EACCES</code>、<code>Errno::EAGAIN</code>、<code>Errno::EINTR</code>等。\\n \\n与特定错误对应的整数操作系统错误号作为类常量<code>Errno::</code><em>error提供。\\n \n   Errno::EACCES::Errno   #=> 13\n   Errno::EAGAIN::Errno   #=> 11\n   Errno::EINTR::Errno    #=> 4\n \\n特定平台上操作系统错误的完整列表可用作<code>Errno</code>的常量。\\n n    Errno.constants   #=> :E2BIG, :EACCES, :EADDRINUSE, :EADDRNOTAVAIL, ...", "name": "RangeError", "namespace": "", "path": "RangeError", "type": "class", "visibility": "public"}, "ScriptError": {"description": "最标准的错误类型是StandardError的子类。没有显式异常类的rescue子句将拯救所有StandardErrors（并且只拯救那些）。\\n \n   def foo\n     raise \"Oups\"\n   end\n   foo rescue \"Hello\"   #=> \"Hello\"\n \\n另一方面：\\n \n   require 'does/not/exist' rescue \"Hi\"\n \\n<em>raises the exception:.</em>\\n \\n LoadError:no such file to load--does/not/exist", "name": "ScriptError", "namespace": "", "path": "ScriptError", "type": "class", "visibility": "public"}, "SyntaxError": {"description": "由+exit+引发，以启动脚本终止。", "name": "SyntaxError", "namespace": "", "path": "SyntaxError", "type": "class", "visibility": "public"}, "SyntaxError#initialize": {"description": "创建具有给定状态和消息的新+SystemExit+异常。\\n状态为真、假或整数。\\n如果未给定状态，则使用true。", "name": "initialize", "namespace": "SyntaxError", "path": "SyntaxError#initialize", "type": "instance_method", "visibility": "public"}, "LoadError": {"description": "返回与此系统出口关联的状态值。", "name": "LoadError", "namespace": "", "path": "LoadError", "type": "class", "visibility": "public"}, "NotImplementedError": {"description": "如果退出成功，返回+true+；否则返回+false+。", "name": "NotImplementedError", "namespace": "", "path": "NotImplementedError", "type": "class", "visibility": "public"}, "NameError": {"description": "收到信号时引发。\\n \n   begin\n     Process.kill('HUP',Process.pid)\n     sleep # wait for receiver to handle signal sent by Process.kill\n   rescue SignalException => e\n     puts \"received Exception #{e}\"\n   end\n \\n<em>产生：.<em>\\n \\n Received exception sighup", "name": "NameError", "namespace": "", "path": "NameError", "type": "class", "visibility": "public"}, "NameError#initialize": {"description": "构造一个新的SignalException对象。+sig_name+应该是一个已知的\\n信号名称。", "name": "initialize", "namespace": "NameError", "path": "NameError#initialize", "type": "instance_method", "visibility": "public"}, "NameError#local_variables": {"description": "返回信号号。", "name": "local_variables", "namespace": "NameError", "path": "NameError#local_variables", "type": "instance_method", "visibility": "public"}, "NameError#name": {"description": "接收到中断信号时引发，通常是因为用户按下了Control-C（在大多数POSIX平台上）。因此，它是+SignalException+的一个子类。\\n \n   begin\n     puts \"Press ctrl-C when you get bored\"\n     loop {}\n   rescue Interrupt => e\n     puts \"Note: You will typically use Signal.trap instead.\"\n   end\n \\n<em>生成：.<em>\\n \n   Press ctrl-C when you get bored\n \\n<em>then waities until it is interrupted with control-c and then prints:.<em>\\n\\n note:You will typically use Signal.trap instead.", "name": "name", "namespace": "NameError", "path": "NameError#name", "type": "instance_method", "visibility": "public"}, "NameError#receiver": {"description": "遇到不属于预期类型的对象时引发。\\n \n   [1, 2, 3].first(\"two\")\n \\n<em>引发异常：.<em>\\n\\n TypeError:no implicit conversion of string into integer", "name": "receiver", "namespace": "NameError", "path": "NameError#receiver", "type": "instance_method", "visibility": "public"}, "NameError::message": {"description": ":nodoc:", "name": "message", "namespace": "NameError", "path": "NameError::message", "type": "class", "visibility": "public"}, "NameError::message#==": {"description": ":nodoc:", "name": "==", "namespace": "NameError::message", "path": "NameError::message#==", "type": "instance_method", "visibility": "public"}, "NameError::message#_dump": {"description": ":nodoc:", "name": "_dump", "namespace": "NameError::message", "path": "NameError::message#_dump", "type": "instance_method", "visibility": "public"}, "NameError::message#to_str": {"description": ":nodoc:", "name": "to_str", "namespace": "NameError::message", "path": "NameError::message#to_str", "type": "instance_method", "visibility": "public"}, "NameError::message._load": {"description": ":nodoc:", "name": "_load", "namespace": "NameError::message", "path": "NameError::message._load", "type": "class_method", "visibility": "public"}, "NoMethodError": {"description": "当参数错误且没有更具体的异常类时引发。\\n \\n ex:传递错误数目的参数\n   [1, 2, 3].first(4, 5)\n \\n<em>引发异常：.-\\n \n   ArgumentError: wrong number of arguments (given 2, expected 1)\n \\n ex:传递一个不可接受的参数：\\n \n   [1, 2, 3].first(-4)\n \\n<em>引发异常：.-\\n \\n ArgumentError:负数组大小", "name": "NoMethodError", "namespace": "", "path": "NoMethodError", "type": "class", "visibility": "public"}, "NoMethodError#args": {"description": "当给定索引无效时引发。n \n   a = [:foo, :bar]\n   a.fetch(0)   #=> :foo\n   a[4]         #=> nil\n   a.fetch(4)   #=> IndexError: index 4 outside of array bounds: -2...2", "name": "args", "namespace": "NoMethodError", "path": "NoMethodError#args", "type": "instance_method", "visibility": "public"}, "NoMethodError#initialize": {"description": "在找不到指定键时引发。它是IndexError的一个子类。n \n   h = {\"foo\" => :bar}\n   h.fetch(\"foo\") #=> :bar\n   h.fetch(\"baz\") #=> KeyError: key not found: \"baz\"", "name": "initialize", "namespace": "NoMethodError", "path": "NoMethodError#initialize", "type": "instance_method", "visibility": "public"}, "NoMethodError#private_call?": {"description": "", "name": "private_call?", "namespace": "NoMethodError", "path": "NoMethodError#private_call?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "FrozenError": {"description": "返回导致此KeyError异常的密钥。", "name": "FrozenError", "namespace": "", "path": "FrozenError", "type": "class", "visibility": "public"}, "RuntimeError": {"description": "返回与此KeyError异常关联的接收器。", "name": "RuntimeError", "namespace": "", "path": "RuntimeError", "type": "class", "visibility": "public"}, "SecurityError": {"description": "当给定的数值超出范围时引发。\\n \n   [1, 2, 3].drop(1 << 100)\n \\n<em>引发异常：.<em>\\n\\n RangeError:bignum too big to convert into'long'", "name": "SecurityError", "namespace": "", "path": "SecurityError", "type": "class", "visibility": "public"}, "NoMemoryError": {"description": "ScriptError是当由于+LoadError+、+NotImplementedError+或+SyntaxError+而无法执行脚本时引发的错误的超类。注意，这些类型的+ScriptErrors+不是+StandardError+，除非明确指定（或其祖先+Exception+），否则不会被挽救。", "name": "NoMemoryError", "namespace": "", "path": "NoMemoryError", "type": "class", "visibility": "public"}, "SystemCallError": {"description": "遇到语法无效的Ruby代码时引发。\\n \n   eval(\"1+1=2\")\n \\n<em>引发异常：</em>\\n\\n SyntaxError:（eval）：1:语法错误，意外的“=”，应为$end", "name": "SystemCallError", "namespace": "", "path": "SystemCallError", "type": "class", "visibility": "public"}, "SystemCallError#errno": {"description": "构造SyntaxError异常。", "name": "errno", "namespace": "SystemCallError", "path": "SystemCallError#errno", "type": "instance_method", "visibility": "public"}, "SystemCallError#initialize": {"description": "在加载所需文件（Ruby脚本、扩展库等）失败时引发。\\n \n   require 'this/file/does/not/exist'\n \\n<em>引发异常：</em>\\n\\n LoadError:no such file to load--this/file/does/not/exist", "name": "initialize", "namespace": "SystemCallError", "path": "SystemCallError#initialize", "type": "instance_method", "visibility": "public"}, "SystemCallError.===": {"description": "在当前平台上未实现功能时引发。例如，如果底层操作系统或Ruby运行时不支持，则依赖于+fsync+或+fork+系统调用的方法可能会引发此异常。\\n \\n请注意，如果+fork+引发+NotImplementedError+，则\\n <code>respond_to?(:fork)</code>返回+false+。", "name": "===", "namespace": "SystemCallError", "path": "SystemCallError.===", "type": "class_method", "visibility": "public"}, "EncodingError": {"description": "当给定名称无效或未定义时引发。\\n \n   puts foo\n \\n<em>引发异常：-\\n \n   NameError: undefined local variable or method `foo' for main:Object\n \\n since constant names must start with a capital:\\n \n   Integer.const_set :answer, 42\n \\n<em>raises the exception:-\\n \\n NameError:wrong constant name answer", "name": "EncodingError", "namespace": "", "path": "EncodingError", "type": "class", "visibility": "public"}, "fatal": {"description": "构造新的NameError异常。如果给定了<i>名称</i>\\n参数，则随后可以使用<code>NameError.name</code>方法检查。", "name": "fatal", "namespace": "", "path": "fatal", "type": "class", "visibility": "public"}, "Exception": {"description": "返回在引发NameError异常的位置定义的局部变量名列表。\\n \\n仅供内部使用。", "name": "Exception", "namespace": "", "path": "Exception", "type": "class", "visibility": "public"}, "Exception#==": {"description": "返回与此NameError异常关联的名称。", "name": "==", "namespace": "Exception", "path": "Exception#==", "type": "instance_method", "visibility": "public"}, "Exception#backtrace": {"description": "返回与此NameError异常关联的接收器。", "name": "backtrace", "namespace": "Exception", "path": "Exception#backtrace", "type": "instance_method", "visibility": "public"}, "Exception#backtrace_locations": {"description": "当对未定义方法且也无法用+method_missing+响应的接收器调用方法时引发。\\n \n   \"hello\".to_ary\n \\n<em>引发异常：</em>\\n \\n NoMethodError:Undefined method'to \\u ary'for“hello”：string", "name": "backtrace_locations", "namespace": "Exception", "path": "Exception#backtrace_locations", "type": "instance_method", "visibility": "public"}, "Exception#cause": {"description": "将作为第三个参数传入的参数返回给构造函数。", "name": "cause", "namespace": "Exception", "path": "Exception#cause", "type": "instance_method", "visibility": "public"}, "Exception#exception": {"description": "如果errno对应于已知的系统错误代码，则为该错误构造相应的<code>Errno</code>类，否则构造通用的<code>SystemCallError</code>对象。随后可通过<code>errno</code>方法获得错误号。", "name": "exception", "namespace": "Exception", "path": "Exception#exception", "type": "instance_method", "visibility": "public"}, "Exception#full_message": {"description": "在尝试修改冻结对象时引发。\\n \n   [1, 2, 3].freeze << 4\n \\n<em>引发异常：</em>\\n\\n FrozenError:can't modify frozen array", "name": "full_message", "namespace": "Exception", "path": "Exception#full_message", "type": "instance_method", "visibility": "public"}, "Exception#initialize": {"description": "尝试无效操作时引发的一般性错误类。\\n如果未指定异常类，kernel raise将引发RuntimeError。\\n \n   raise \"ouch\"\n \\n<em>引发异常：</em>\\n\\n RuntimeError:ouch", "name": "initialize", "namespace": "Exception", "path": "Exception#initialize", "type": "instance_method", "visibility": "public"}, "Exception#inspect": {"description": "在尝试潜在的不安全操作时引发，通常在$SAFE级别提升到0以上时引发。\\n \n   foo = \"bar\"\n   proc = Proc.new do\n     $SAFE = 3\n     foo.untaint\n   end\n   proc.call\n \\n<em>引发异常：</em>\\n\\n SecurityError:不安全：不安全操作“untaint”at level 3", "name": "inspect", "namespace": "Exception", "path": "Exception#inspect", "type": "instance_method", "visibility": "public"}, "Exception#message": {"description": "内存分配失败时引发。", "name": "message", "namespace": "Exception", "path": "Exception#message", "type": "instance_method", "visibility": "public"}, "Exception#set_backtrace": {"description": "SystemCallerrror是所有与平台相关的低级错误的基类。\\n \\n当前平台上可用的错误是SystemCallError的子类，在errno模块中定义。\\n \n   File.open(\"does/not/exist\")\n \\n<em>引发异常：</em>\\n\\n errno:：ENOENT:no such file or directory-does/not/exist", "name": "set_backtrace", "namespace": "Exception", "path": "Exception#set_backtrace", "type": "instance_method", "visibility": "public"}, "Exception#to_s": {"description": "返回SystemCallError的错误号。", "name": "to_s", "namespace": "Exception", "path": "Exception#to_s", "type": "instance_method", "visibility": "public"}, "Exception.exception": {"description": "如果errno对应于已知的系统错误代码，则为该错误构造相应的<code>Errno</code>类，否则构造通用的<code>SystemCallError</code>对象。随后可通过<code>errno</code>方法获得错误号。", "name": "exception", "namespace": "Exception", "path": "Exception.exception", "type": "class_method", "visibility": "public"}, "Exception.to_tty?": {"description": "如果接收器是通用的+SystemCallError+，或者错误号+self+和其他相同，则返回+true+。", "name": "to_tty?", "namespace": "Exception", "path": "Exception.to_tty?", "type": "class_method", "visibility": "public", "return": [["Boolean"], ""]}, "FileTest": {"description": "encodingerror是编码错误的基类。", "name": "FileTest", "namespace": "", "path": "FileTest", "type": "class", "visibility": "public"}, "IO": {"description": "Fatal是Ruby遇到错误时引发的异常，必须退出。你无法拯救死亡。", "name": "IO", "namespace": "", "path": "IO", "type": "class", "visibility": "public"}, "IO#<<": {"description": "类异常的后代用于在<code>begin ... end</code>块中的内核引发和+rescue+语句之间进行通信。\\n exception对象包含有关异常的信息——异常的类型（异常的类名）、可选的描述性字符串和可选的回溯信息。异常子类可以添加其他信息，如NameError名称。\\n \\n程式可以建立例外的子类别，通常为StandardError或RuntimeError，以提供自订类别并新增其他资讯。\\n有关+raise+和+rescue+的默认值，请参阅下面的子类列表。\\n \\n当已引发异常但尚未处理时（在+rescue+、+ensure+、+at_exit+和+END+块中），全局变量<code>$!</code> \\n将包含当前异常，<code>$@</code>包含当前异常的回溯。\\n \\n建议库应具有StandardError或RuntimeError的一个子类，并具有从中继承的特定异常类型。这允许用户挽救通用异常类型，以捕获库可能引发的所有异常，即使库的未来版本添加了新的异常子类。\\n \\n例如：\\n \n  class MyLibrary\n    class Error < RuntimeError\n    end\n\n    class WidgetError < Error\n    end\n\n    class FrobError < Error\n    end\n\n  end\n \\n若要同时处理WidgetError和FrobError，库用户可以援救MyLibrary:：error。\\n \\n exception的内置子类为：\\n \\n*NoMemoryError \\n*scriptError\n  * LoadError\n  * NotImplementedError\n  * SyntaxError\n*SecurityError \\n*signalException\n  * Interrupt\n*StandardError--默认为+rescue+\n  * ArgumentError\n    * UncaughtThrowError\n  * EncodingError\n  * FiberError\n  * IOError\n    * EOFError\n  * IndexError\n    * KeyError\n    * StopIteration\n  * LocalJumpError\n  * NameError\n    * NoMethodError\n  * RangeError\n    * FloatDomainError\n  * RegexpError\n  * RuntimeError -- default for +raise+\n    * FrozenError\n  * SystemCallError\n    * Errno::*\n  * ThreadError\n  * TypeError\n  * ZeroDivisionError\n*SystemExit \\n*SystemStackError \\n*fatal--无法救援", "name": "<<", "namespace": "IO", "path": "IO#<<", "type": "instance_method", "visibility": "public"}, "IO#__read_nonblock": {"description": ":nodoc:", "name": "__read_nonblock", "namespace": "IO", "path": "IO#__read_nonblock", "type": "instance_method", "visibility": "private"}, "IO#__write_nonblock": {"description": ":nodoc:", "name": "__write_nonblock", "namespace": "IO", "path": "IO#__write_nonblock", "type": "instance_method", "visibility": "private"}, "IO#advise": {"description": "equality-if<i>obj<i>is not an <code>Exception</code>，returns <code>false</code>.否则，如果<i>exc<i>和\\n<i>obj<i>share same class，messages，and backtrace，则返回<code>true</code>。", "name": "advise", "namespace": "IO", "path": "IO#advise", "type": "instance_method", "visibility": "public"}, "IO#autoclose=": {"description": "返回与异常关联的任何回溯。backtrace是一个字符串数组，每个字符串都包含``filename:lineno:in\\n`method'''或``filename:lineno.''\\n \n   def a\n     raise \"boom\"\n   end\n\n   def b\n     a()\n   end\n003919\\n<em>products:<em>\\n \n   prog.rb:2:in `a'\n   prog.rb:6:in `b'\n prog.rb:10", "name": "autoclose=", "namespace": "IO", "path": "IO#autoclose=", "type": "instance_method", "visibility": "public"}, "IO#autoclose?": {"description": "返回与异常关联的任何回溯。此方法类似于异常回溯，但回溯是线程：：回溯：：位置的数组。\\n \\n现在，此方法不受异常set_backtrace（）的影响。", "name": "autoclose?", "namespace": "IO", "path": "IO#autoclose?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "IO#binmode": {"description": "返回上一个异常（$！）在引发此异常时。\\n这对于包装异常并保留原始异常信息非常有用。", "name": "binmode", "namespace": "IO", "path": "IO#binmode", "type": "instance_method", "visibility": "public"}, "IO#binmode?": {"description": "call seq:\n   exc.exception(string)  ->  an_exception or exc\n \\n不带参数，或者如果参数与接收器相同，则返回接收器。否则，创建一个与接收者属于同一类但消息等于<code>string.to_str</code>的新异常对象。", "name": "binmode?", "namespace": "IO", "path": "IO#binmode?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "IO#bytes": {"description": "返回一个新哈希，并为每个键运行一次块的结果。\\n此方法不会更改值。\\n \n   h = { a: 1, b: 2, c: 3 }\n   h.transform_keys {|k| k.to_s }  #=> { \"a\" => 1, \"b\" => 2, \"c\" => 3 }\n   h.transform_keys(&:to_s)        #=> { \"a\" => 1, \"b\" => 2, \"c\" => 3 }\n   h.transform_keys.with_index {|k, i| \"#{k}.#{i}\" }\n                                   #=> { \"a.0\" => 1, \"b.1\" => 2, \"c.2\" => 3 }\n \\n如果没有给定块，则返回枚举器。", "name": "bytes", "namespace": "IO", "path": "IO#bytes", "type": "instance_method", "visibility": "public"}, "IO#chars": {"description": "为<i>hsh中的每个键调用一次给定的块，将其替换为块返回的新键，然后返回<i>hsh。\\n此方法不会更改值。\\n \n   h = { a: 1, b: 2, c: 3 }\n   h.transform_keys! {|k| k.to_s }  #=> { \"a\" => 1, \"b\" => 2, \"c\" => 3 }\n   h.transform_keys!(&:to_sym)      #=> { a: 1, b: 2, c: 3 }\n   h.transform_keys!.with_index {|k, i| \"#{k}.#{i}\" }\n                                    #=> { \"a.0\" => 1, \"b.1\" => 2, \"c.2\" => 3 }\n \\n如果没有给定块，则返回枚举器。", "name": "chars", "namespace": "IO", "path": "IO#chars", "type": "instance_method", "visibility": "public"}, "IO#close": {"description": "返回此异常的类名和消息", "name": "close", "namespace": "IO", "path": "IO#close", "type": "instance_method", "visibility": "public"}, "IO#close_on_exec=": {"description": "返回调用<code>exception.to_s</code>的结果。\\n通常，这会返回异常的消息或名称。", "name": "close_on_exec=", "namespace": "IO", "path": "IO#close_on_exec=", "type": "instance_method", "visibility": "public"}, "IO#close_on_exec?": {"description": "设置与+exc+关联的回溯信息。+backtrace+必须是字符串对象数组或单个字符串，格式如异常回溯所述。", "name": "close_on_exec?", "namespace": "IO", "path": "IO#close_on_exec?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "IO#close_read": {"description": "返回异常的消息（如果未设置消息，则返回异常的名称）。", "name": "close_read", "namespace": "IO", "path": "IO#close_read", "type": "instance_method", "visibility": "public"}, "IO#close_write": {"description": "call seq:\n   exc.exception(string)  ->  an_exception or exc\n \\n不带参数，或者如果参数与接收器相同，则返回接收器。否则，创建一个与接收者属于同一类但消息等于<code>string.to_str</code>的新异常对象。", "name": "close_write", "namespace": "IO", "path": "IO#close_write", "type": "instance_method", "visibility": "public"}, "IO#closed?": {"description": "如果异常消息将发送到tty，则返回+true+。", "name": "closed?", "namespace": "IO", "path": "IO#closed?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "IO#codepoints": {"description": "将其他哈希的内容添加到。如果没有指定块，则具有重复键的项将被_other_hash_uu中的值覆盖，否则每个重复键的值将通过使用键调用块、其hsh_u中的值以及其在\\n_other_hash中的值来确定。\\n \n   h1 = { \"a\" => 100, \"b\" => 200 }\n   h2 = { \"b\" => 254, \"c\" => 300 }\n   h1.merge!(h2)   #=> {\"a\"=>100, \"b\"=>254, \"c\"=>300}\n   h1              #=> {\"a\"=>100, \"b\"=>254, \"c\"=>300}\n\n   h1 = { \"a\" => 100, \"b\" => 200 }\n   h2 = { \"b\" => 254, \"c\" => 300 }\n   h1.merge!(h2) { |key, v1, v2| v1 }\n                   #=> {\"a\"=>100, \"b\"=>200, \"c\"=>300}\n   h1              #=> {\"a\"=>100, \"b\"=>200, \"c\"=>300}", "name": "codepoints", "namespace": "IO", "path": "IO#codepoints", "type": "instance_method", "visibility": "public"}, "IO#each": {"description": "如果IOS的基础文件描述符将在其完成时自动关闭，则返回+true+，否则返回+false+。", "name": "each", "namespace": "IO", "path": "IO#each", "type": "instance_method", "visibility": "public"}, "IO#each_byte": {"description": "字符串输出-写入<i>obj<i>to<em>ios<em>。\\n<i>obj<i>将使用<code>to_s</code>转换为字符串。\\n \n   $stdout << \"Hello \" << \"world!\\n\"\n \\n<em>生成：.<em>\\n \\n Hello World！", "name": "each_byte", "namespace": "IO", "path": "IO#each_byte", "type": "instance_method", "visibility": "public"}, "IO#each_char": {"description": "以特定模式宣布从当前文件访问数据的意图。在不支持\\n<em>posix_fadvise（2）.<em>系统调用的平台上，此方法是一个no-op。\\n\\n advice是以下符号之一：\\n\\n:normal:：no advice to give; the default assumption for a n open file.\\n:Sequential：：将按顺序访问数据\n              with lower offsets read before higher ones.\n:Random：：将按随机顺序访问数据。\\n:willneed：：将在不久的将来访问数据。\\n:Dontned：：在不久的将来将无法访问数据。\\n:noreuse：：数据只能访问一次。\\n \\n一条建议的语义依赖于平台。有关详细信息，请参阅\\n<em>man 2 posix_fadvise。\\n \\n“data”是指当前文件中以偏移量\\开始并扩展\\ len字节的区域。如果len为0，则区域\\n以文件的最后一个字节结束。默认情况下，“偏移量”和“长度”都为0，这意味着建议适用于整个文件。\\n \\n如果发生错误，将引发以下异常之一：\\n \\n <code>IOError</code>：：<code>IO</code>流已关闭。\\n <code>Errno::EBADF</code>:：\n  The file descriptor of the current file is invalid.\n<code>Errno::EINVAL</code>：：给出的建议值无效。\\n <code>Errno::ESPIPE</code>:：\n  The file descriptor of the current file refers to a FIFO or\n  pipe. (Linux raises <code>Errno::EINVAL</code> in this case).\n<code>TypeError</code>:：\n  Either _advice_ was not a Symbol, or one of the\n  other arguments was not an <code>Integer</code>.\n<code>RangeError</code>:：给定的参数之一太大/太小。\\n \\n此列表不是exhaustive;。也可能有其他errno：：异常。", "name": "each_char", "namespace": "IO", "path": "IO#each_char", "type": "instance_method", "visibility": "public"}, "IO#each_codepoint": {"description": "设置自动关闭标志。\\n \n   f = open(\"/dev/null\")\n   IO.for_fd(f.fileno)\n   # ...\n   f.gets # may cause IOError\n\n   f = open(\"/dev/null\")\n   IO.for_fd(f.fileno).autoclose = true\n   # ...\n f.gets不会导致ioerror", "name": "each_codepoint", "namespace": "IO", "path": "IO#each_codepoint", "type": "instance_method", "visibility": "public"}, "IO#each_line": {"description": "如果IOS的基础文件描述符将在其完成时自动关闭，则返回+true+，否则返回+false+。", "name": "each_line", "namespace": "IO", "path": "IO#each_line", "type": "instance_method", "visibility": "public"}, "IO#eof": {"description": "如果<em>ios<em>is binmode，则返回<code>true</code>。", "name": "eof", "namespace": "IO", "path": "IO#eof", "type": "instance_method", "visibility": "public"}, "IO#eof?": {"description": "如果<em>ios<em>is binmode，则返回<code>true</code>。", "name": "eof?", "namespace": "IO", "path": "IO#eof?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "IO#external_encoding": {"description": "这是<code>each_byte</code>的不推荐使用的别名。", "name": "external_encoding", "namespace": "IO", "path": "IO#external_encoding", "type": "instance_method", "visibility": "public"}, "IO#fcntl": {"description": "这是<code>each_char</code>的不推荐使用的别名。", "name": "fcntl", "namespace": "IO", "path": "IO#fcntl", "type": "instance_method", "visibility": "public"}, "IO#fdatasync": {"description": "关闭<em>ios，并刷新对操作系统的任何挂起写入。流对于任何进一步的数据operations;都不可用\\n如果尝试这样做，将引发<code>IOError</code>。当垃圾收集器声明I/O流时，这些流将自动关闭。\\n \\n if<em>ios</em>is opened by <code>IO.popen</code>，\\n <code>close</code> sets <code>$?</code>.\\n \\n自从Ruby 2.3以来，对已关闭的IO对象调用此方法被忽略。", "name": "fdatasync", "namespace": "IO", "path": "IO#fdatasync", "type": "instance_method", "visibility": "public"}, "IO#fileno": {"description": "如果执行时关闭IOS，则返回<code>true</code>。n \n   f = open(\"/dev/null\")\n   f.close_on_exec?                 #=> false\n   f.close_on_exec = true\n   f.close_on_exec?                 #=> true\n   f.close_on_exec = false\n   f.close_on_exec?                 #=> false", "name": "to_i", "namespace": "IO", "path": "IO#to_i", "type": "instance_method", "visibility": "public"}, "IO#to_i": {"description": "如果执行时关闭IOS，则返回<code>true</code>。n \n   f = open(\"/dev/null\")\n   f.close_on_exec?                 #=> false\n   f.close_on_exec = true\n   f.close_on_exec?                 #=> true\n   f.close_on_exec = false\n   f.close_on_exec?                 #=> false", "name": "to_i", "namespace": "IO", "path": "IO#to_i", "type": "instance_method", "visibility": "public"}, "IO#flush": {"description": "关闭双工I/O流的读取端（即同时包含读取流和写入流（如管道））。如果流不是双工的，将引发\\n <code>IOError</code>。\\n \n   f = IO.popen(\"/bin/sh\",\"r+\")\n   f.close_read\n   f.readlines\n \\n<em>产生：.-\\n \n   prog.rb:3:in `readlines': not opened for reading (IOError)\n   \tfrom prog.rb:3\n \\n在closed io object上调用此方法只是从ruby 2.3开始被忽略。", "name": "flush", "namespace": "IO", "path": "IO#flush", "type": "instance_method", "visibility": "public"}, "IO#fsync": {"description": "关闭双工I/O流的写入端（即同时包含读取流和写入流（如管道））。如果流不是双工的，将引发\\n <code>IOError</code>。\\n \n   f = IO.popen(\"/bin/sh\",\"r+\")\n   f.close_write\n   f.print \"nowhere\"\n \\n<em>生成：.<em>\\n \n   prog.rb:3:in `write': not opened for writing (IOError)\n   \tfrom prog.rb:3:in `print'\n   \tfrom prog.rb:3\n \\n在closed io object上调用此方法只是因为ruby 2.3而被忽略。", "name": "fsync", "namespace": "IO", "path": "IO#fsync", "type": "instance_method", "visibility": "public"}, "IO#getbyte": {"description": "如果IOS<em>ios<em>完全关闭（对于双工流，读写器和写入器），则返回<code>true</code>，否则返回<code>false</code>\\n。n \n   f = File.new(\"testfile\")\n   f.close         #=> nil\n   f.closed?       #=> true\n   f = IO.popen(\"/bin/sh\",\"r+\")\n   f.close_write   #=> nil\n   f.closed?       #=> false\n   f.close_read    #=> nil\n   f.closed?       #=> true", "name": "getbyte", "namespace": "IO", "path": "IO#getbyte", "type": "instance_method", "visibility": "public"}, "IO#getc": {"description": "这是<code>each_codepoint</code>的不推荐使用的别名。", "name": "getc", "namespace": "IO", "path": "IO#getc", "type": "instance_method", "visibility": "public"}, "IO#gets": {"description": "ios.each_line（sep=$/[，getline_args]）_line block->ios\n   ios.each_line(limit [, getline_args])      {|line| block } -> ios\n   ios.each_line(sep, limit [, getline_args]) {|line| block } -> ios\n   ios.each_line(...)                        -> an_enumerator\n\\n对<em>ios中的每一行执行块，其中行由<i>sep分隔。必须打开iOS进行读取，否则将引发<code>IOError</code>。\\n \\n如果没有给定块，则返回枚举器。\\n \n   f = File.new(\"testfile\")\n   f.each {|line| puts \"#{f.lineno}: #{line}\" }\n \\n<em>products:-<em>\\n \n   1: This is line one\n   2: This is line two\n   3: This is line three\n   4: And so on...\n \\n see IO.readlines for details about getline_args.", "name": "gets", "namespace": "IO", "path": "IO#gets", "type": "instance_method", "visibility": "public"}, "IO#initialize": {"description": "为<em>ios中的每个字节（0..255）调用一次给定的块，将字节作为参数传递。必须打开流进行读取，否则将引发<code>IOError</code>。\\n \\n如果没有给定块，则返回枚举器。n \n   f = File.new(\"testfile\")\n   checksum = 0\n   f.each_byte {|x| checksum ^= x }   #=> #<File:testfile>\n   checksum                           #=> 12", "name": "initialize", "namespace": "IO", "path": "IO#initialize", "type": "instance_method", "visibility": "public"}, "IO#initialize_copy": {"description": ":nodoc:", "name": "initialize_copy", "namespace": "IO", "path": "IO#initialize_copy", "type": "instance_method", "visibility": "public"}, "IO#inspect": {"description": "为<em>ios中的每个字符调用一次给定的块，将字符作为参数传递。必须打开流进行读取，否则将引发<code>IOError</code>。\\n \\n如果没有给定块，则返回枚举器。n \n   f = File.new(\"testfile\")\n   f.each_char {|c| print c, ' ' }   #=> #<File:testfile>", "name": "inspect", "namespace": "IO", "path": "IO#inspect", "type": "instance_method", "visibility": "public"}, "IO#internal_encoding": {"description": "传递<i>ios中每个字符的<code>Integer</code>序数，将代码点作为参数传递。必须打开流进行读取，否则将引发<code>IOError</code>。\\n \\n如果没有给定块，则返回枚举器。", "name": "internal_encoding", "namespace": "IO", "path": "IO#internal_encoding", "type": "instance_method", "visibility": "public"}, "IO#ioctl": {"description": "ios.each_line（sep=$/[，getline_args]）_line block->ios\n   ios.each_line(limit [, getline_args])      {|line| block } -> ios\n   ios.each_line(sep, limit [, getline_args]) {|line| block } -> ios\n   ios.each_line(...)                        -> an_enumerator\n\\n对<em>ios中的每一行执行块，其中行由<i>sep分隔。必须打开iOS进行读取，否则将引发<code>IOError</code>。\\n \\n如果没有给定块，则返回枚举器。\\n \n   f = File.new(\"testfile\")\n   f.each {|line| puts \"#{f.lineno}: #{line}\" }\n \\n<em>products:->em>\\n \n   1: This is line one\n   2: This is line two\n   3: This is line three\n   4: And so on...\n \\n see IO.readlines for details about getline_args.", "name": "ioctl", "namespace": "IO", "path": "IO#ioctl", "type": "instance_method", "visibility": "public"}, "IO#isatty": {"description": "使用<code>IO#getbyte</code>读取字节，但在文件结尾处引发\\n <code>EOFError</code>。", "name": "isatty", "namespace": "IO", "path": "IO#isatty", "type": "instance_method", "visibility": "public"}, "IO#lineno": {"description": "如果<em>ios<em>位于文件末尾，则返回true，这意味着没有更多数据可读取。\\n必须打开流进行读取，否则将引发<code>IOError</code>。\\n \n   f = File.new(\"testfile\")\n   dummy = f.readlines\n   f.eof   #=> true\n \\n if<em>ios</em>is a stream such as pipe or socket，<code>IO#eof?</code> \\n blocks until the other end sends some data or close it.\\n \n   r, w = IO.pipe\n   Thread.new { sleep 1; w.close }\n   r.eof?  #=> true after 1 second blocking\n\n  enum.slice_before(pattern).each { |ary| ... }\n  enum.slice_before { |elt| bool }.each { |ary| ... }\n036\n   r, w = IO.pipe\n   r.eof?  # blocks forever\n \\n请注意，<code>IO#eof?</code>将数据读取到输入字节缓冲区。\\n因此，<code>IO#sysread</code>的行为可能与<code>IO#eof?</code>不符，除非您首先调用<code>IO#rewind</code>（对于某些流不可用）。", "name": "lineno", "namespace": "IO", "path": "IO#lineno", "type": "instance_method", "visibility": "public"}, "IO#lineno=": {"description": "返回表示文件编码的编码对象。\\n如果IO处于写入模式且未指定编码，则返回+nil+。", "name": "lineno=", "namespace": "IO", "path": "IO#lineno=", "type": "instance_method", "visibility": "public"}, "IO#lines": {"description": "argf.each_line（sep=$/）line block->ARGF\n   ARGF.each_line(sep=$/, limit) {|line| block }  -> ARGF\n   ARGF.each_line(...)                            -> an_enumerator\n \\n返回一个枚举器，该枚举器在+ARGV+中的每个文件的每一行上迭代（由默认为平台换行符的_sep_uu分隔）。如果提供了一个块，那么每一行都将依次生成该块，否则将返回一个枚举器。\\n可选的limit参数是+Integer+，指定每个line;长行的最大长度将根据此限制拆分。\\n \\n此方法允许您将命令行上提供的文件视为单个文件，由每个命名文件的串联组成。返回第一个文件的最后一行后，返回第二个文件的第一行。可以使用+ARGF.filename+和+ARGF.lineno+方法分别确定当前行的文件名和行号。\\n \\n例如，下面的代码打印出每个命名文件的每一行，并以其行号作为前缀，每个文件显示一次文件名：\\n \n   ARGF.each_line do |line|\n     puts ARGF.filename if ARGF.lineno == 1\n     puts \"#{ARGF.lineno}: #{line}\"\n end", "name": "lines", "namespace": "IO", "path": "IO#lines", "type": "instance_method", "visibility": "public"}, "IO#pid": {"description": "立即将<em>ios中的所有缓冲数据写入磁盘。\\n \\n如果基础操作系统不支持<em>fdata-sync（2）.<em>，\\n <code>IO#fsync</code> is called instead（which may raise a <code>NotImplementedError</code>）.", "name": "pid", "namespace": "IO", "path": "IO#pid", "type": "instance_method", "visibility": "public"}, "IO#pos": {"description": "将给定字符串写入<em>ios<em>at<i>offset<i>using pwrite（）\\n system call。这有利于将IO seek和IO write结合起来，因为它是原子的，允许多个线程/进程共享相同的IO对象，以便在不同的位置读取文件。\\n这将绕过IO层的任何用户空间缓冲。\\n返回写入的字节数。\\n出错时引发<code>SystemCallError</code>，如果平台未实现系统调用，则引发<code>NotImplementedError</code>。\\n \n   File.open(\"out\", \"w\") do |f|\n     f.pwrite(\"ABCDEF\", 3)   #=> 6\n   end\n \\n    File.read(\"out\")          #=> \"\\u0000\\u0000\\u0000ABCDEF\"", "name": "pos", "namespace": "IO", "path": "IO#pos", "type": "instance_method", "visibility": "public"}, "IO#pos=": {"description": "返回表示iOS数字文件描述符的整数。n \n   $stdin.fileno    #=> 0\n   $stdout.fileno   #=> 1", "name": "pos=", "namespace": "IO", "path": "IO#pos=", "type": "instance_method", "visibility": "public"}, "IO#pread": {"description": "将<em>ios中的任何缓冲数据刷新到基础操作系统（请注意，这是Ruby Internal Buffering only;\\n操作系统也可以缓冲数据）。\\n \n   $stdout.print \"no newline\"\n   $stdout.flush\n \\n<em>生成：.<em>\\n \\n no newline", "name": "pread", "namespace": "IO", "path": "IO#pread", "type": "instance_method", "visibility": "public"}, "IO#print": {"description": "以+IO+或+File+对象的形式返回当前文件。\\n当当前文件为STDIN时，返回<code>$stdin</code>。\\n \\n例如：\\n \n   $ echo \"foo\" > foo\n   $ echo \"bar\" > bar\n\n   $ ruby argf.rb foo bar\n\n   ARGF.file      #=> #<File:foo>\n   ARGF.read(5)   #=> \"foo\\nb\"\n   ARGF.file      #=> #<File:bar>", "name": "print", "namespace": "IO", "path": "IO#print", "type": "instance_method", "visibility": "public"}, "IO#printf": {"description": "返回当前文件名。“当当前文件为STDIN时返回。\\n \\n例如：\\n \n   $ echo \"foo\" > foo\n   $ echo \"bar\" > bar\n   $ echo \"glark\" > glark\n\n   $ ruby argf.rb foo bar glark\n\n   ARGF.filename  #=> \"foo\"\n   ARGF.read(5)   #=> \"foo\\nb\"\n   ARGF.filename  #=> \"bar\"\n   ARGF.skip\n   ARGF.filename  #=> \"glark\"", "name": "printf", "namespace": "IO", "path": "IO#printf", "type": "instance_method", "visibility": "public"}, "IO#putc": {"description": "返回表示当前文件的数字文件描述符的整数。如果没有当前文件，则引发+ArgumentError+。\\n n    ARGF.fileno    #=> 3", "name": "putc", "namespace": "IO", "path": "IO#putc", "type": "instance_method", "visibility": "public"}, "IO#puts": {"description": "从+ARGF+获取下一个8位字节（0..255）。如果在流结尾调用，则返回+nil+。\\n \\n例如：\\n \n   $ echo \"foo\" > file\n   $ ruby argf.rb file\n\n   ARGF.getbyte #=> 102\n   ARGF.getbyte #=> 111\n   ARGF.getbyte #=> 111\n   ARGF.getbyte #=> 10\n   ARGF.getbyte #=> nil", "name": "puts", "namespace": "IO", "path": "IO#puts", "type": "instance_method", "visibility": "public"}, "IO#pwrite": {"description": "返回给定整数文件描述符+fd+和+mode+字符串的新IO对象（流）。+opt+可用于以更可读的方式指定+mode+的部分。参见IO.sysopen和IO.\\n \\n IO.new由各种文件和IO打开方法调用，如IO：：open、\\n kernel open和file：：open。\\n \\n==打开模式\\n \\n当+mode+是整数时，它必须是在\\n file:：constants（+file:：RDONLY+，<code>File::WRONLY|File::CREAT</code>）中定义的模式的组合。\\n有关详细信息，请参阅“打开（2）”手册页。\\n \\n当+mode+是字符串时，它必须采用以下形式之一：\\n \n  fmode\n  fmode \":\" ext_enc\n  fmode \":\" ext_enc \":\" int_enc\n  fmode \":\" \"BOM|UTF-*\"\n \\n +fmode+是IO打开模式字符串，+ext_enc+是IO的外部编码，+int_enc+是内部编码。\\n \\n===IO打开模式\\n \\n ruby允许以下打开模式：\\n \\n“r”只读，从文件开头开始（默认模式）。\\n \\n“r+”读写，从文件开头开始。\\n \\n“w”只写，将现有文件\\n截断为零长度或创建一个新文件进行写入。\\n \\n“w+”读写，将现有文件截断为零长度\\n或创建一个新的文件进行读写。\\n \\n“a”只写，每个写调用在文件结尾附加数据。\\n如果文件不存在，则创建一个新文件进行写入。\\n \\n“a+”读写，每个写调用在file.\n    Creates a new file for reading and writing if file does\n    not exist.\n结尾附加数据\\n下列模式必须单独使用，以及上面看到的一个或多个模式。\\n \\n“b”二进制文件模式\\n在Windows上禁止EOL<->CRLF转换。并且\\n将外部编码设置为ASCII-8bit，除非明确指定。\\n \\n“t”文本文件模式\\n \\n当原始IO的打开模式为只读时，无法将该模式更改为可写。同样，不能将打开模式从只写更改为可读。\\n \\n尝试进行此类更改时，根据平台在不同位置引发错误。\\n \\n==io encoding \\n \\n当指定+ext_enc+时，读取的字符串将在读取时由编码标记，写入时字符串输出将转换为指定的编码。\\n \\n当指定+ext_enc+和+int_enc+时，输入时读取字符串将从+ext_enc+转换为+int_enc+，输出时写入字符串将从+int_enc+转换为+ext_enc+。有关输入和输出转码的详细信息，请参阅编码。\\n \\n如果使用“bom utf-8”、“bom utf-16le”或“bom utf16-be”，ruby将检查输入文档中的unicode bom以帮助确定编码。对于UTF-16编码，文件打开模式必须是二进制的。当存在时，将剥离物料清单\\n并使用来自物料清单的外部编码。当bom丢失时，给定的unicode编码用作+ext_enc+。（bom set encoding选项不区分大小写，因此“bom utf-8”也有效。）\\n \\n==选项\\n \\n +opt+可代替+mode+以提高可读性。支持下列密钥：\\n\\n :mode:：\n  Same as +mode+ parameter\n\\n :flags:：\n  Specifies file open flags as integer.\n  If +mode+ parameter is given, this parameter will be bitwise-ORed.\n\\n:\\external_encoding:：\n  External encoding for the IO.\n\\n:\\internal_encoding:：\n  Internal encoding for the IO.  \"-\" is a synonym for the default internal\n  encoding.\n\n  If the value is +nil+ no conversion occurs.\n\\n :encoding:：\n  Specifies external and internal encodings as \"extern:intern\".\n\\n :textmode:：\n  If the value is truth value, same as \"t\" in argument +mode+.\n\\n :binmode:：\n  If the value is truth value, same as \"b\" in argument +mode+.\n\\n :autoclose:：\n  If the value is +false+, the +fd+ will be kept open after this IO\n  instance gets finalized.\n\\n此外，+opt+可以在字符串中具有相同的密钥encode以控制外部编码之间的转换\\n以及内部编码。\\n \\n==示例1 \\n \n  fd = IO.sysopen(\"/dev/tty\", \"w\")\n  a = IO.new(fd,\"w\")\n  $stderr.puts \"Hello\"\n  a.puts \"World\"\n \\n生成：\\n \n  Hello\n  World\n \\n==示例2 \\n \n  require 'fcntl'\n1008\n  fd = STDERR.fcntl(Fcntl::F_DUPFD)\n  io = IO.new(fd, mode: 'w', cr_newline: true,\n              external_encoding: Encoding::UTF_16LE)\n  io.puts \"Hello, World!\"\n \\n上面的两个都打印“你好，世界！”以utf-16le格式转换为标准错误输出，并将<code>puts</code>生成的EOL转换为CR。", "name": "pwrite", "namespace": "IO", "path": "IO#pwrite", "type": "instance_method", "visibility": "public"}, "IO#read": {"description": "返回描述此IO对象的字符串。", "name": "read", "namespace": "IO", "path": "IO#read", "type": "instance_method", "visibility": "public"}, "IO#readbyte": {"description": "如果指定了转换，则返回内部字符串的编码。否则返回+nil+。", "name": "readbyte", "namespace": "IO", "path": "IO#readbyte", "type": "instance_method", "visibility": "public"}, "IO#readchar": {"description": "提供用于发出低级命令以控制或查询I/O设备的机制。参数和结果依赖于平台。如果\\n<i>arg</i>是一个数字，则直接传递其值。如果是字符串，则将其解释为二进制字节序列。在UNIX平台上，有关详细信息，请参阅<code>ioctl(2)</code>。未在所有平台上实现。", "name": "readchar", "namespace": "IO", "path": "IO#readchar", "type": "instance_method", "visibility": "public"}, "IO#readline": {"description": "如果与终端设备（tty）关联，则返回<code>true</code>，否则返回<code>false</code>。n \n   File.new(\"testfile\").isatty   #=> false\n   File.new(\"/dev/tty\").isatty   #=> true", "name": "readline", "namespace": "IO", "path": "IO#readline", "type": "instance_method", "visibility": "public"}, "IO#readlines": {"description": "返回<em>ios中的当前行号。必须打开流进行读取。<code>lineno</code>统计调用gets的次数，而不是遇到的换行数。如果用换行符以外的分隔符调用gets，这两个值将不同。\\n \\n使用<code>$/</code>的方法，如每个、行和readline，也将增加<code>lineno</code>。\\n \\n另请参阅<code>$.</code>变量。n \n   f = File.new(\"testfile\")\n   f.lineno   #=> 0\n   f.gets     #=> \"This is line one\\n\"\n   f.lineno   #=> 1\n   f.gets     #=> \"This is line two\\n\"\n   f.lineno   #=> 2", "name": "readlines", "namespace": "IO", "path": "IO#readlines", "type": "instance_method", "visibility": "public"}, "IO#readpartial": {"description": "手动将当前行号设置为给定值。\\n <code>$.</code>仅在下次读取时更新。n \n   f = File.new(\"testfile\")\n   f.gets                     #=> \"This is line one\\n\"\n   $.                         #=> 1\n   f.lineno = 1000\n   f.lineno                   #=> 1000\n   $.                         #=> 1         # lineno of last read\n   f.gets                     #=> \"This is line two\\n\"\n   $.                         #=> 1001      # lineno of last read", "name": "readpartial", "namespace": "IO", "path": "IO#readpartial", "type": "instance_method", "visibility": "public"}, "IO#reopen": {"description": "这是<code>each_line</code>的不推荐使用的别名。", "name": "reopen", "namespace": "IO", "path": "IO#reopen", "type": "instance_method", "visibility": "public"}, "IO#rewind": {"description": "返回与IOS关联的子进程的进程ID。这将在<code>IO.popen</code>之前设置。\\n \n   pipe = IO.popen(\"-\")\n   if pipe\n     $stderr.puts \"In parent, child pid is #{pipe.pid}\"\n   else\n     $stderr.puts \"In child, pid is #{$$}\"\n   end\n \\n<em>产生：.<em>\\n \n   In child, pid is 26209\n in parent，child pid is 26209", "name": "rewind", "namespace": "IO", "path": "IO#rewind", "type": "instance_method", "visibility": "public"}, "IO#seek": {"description": "返回<em>ios的当前偏移量（以字节为单位）。n \n   f = File.new(\"testfile\")\n   f.pos    #=> 0\n   f.gets   #=> \"This is line one\\n\"\n   f.pos    #=> 17", "name": "seek", "namespace": "IO", "path": "IO#seek", "type": "instance_method", "visibility": "public"}, "IO#set_encoding": {"description": "在iOS中查找给定位置（以字节为单位）。\\n当<em>ios<em>\\n是textmode时，不能保证寻找正确的位置。n \n   f = File.new(\"testfile\")\n   f.pos = 17\n   f.gets   #=> \"This is line two\\n\"", "name": "set_encoding", "namespace": "IO", "path": "IO#set_encoding", "type": "instance_method", "visibility": "public"}, "IO#stat": {"description": "使用pread系统调用从<em>ios读取<i>maxlen<i>bytes，并将其作为字符串返回，而不修改基础描述符偏移量。与IO seek和IO read的组合相比，这是一种优势，因为它是原子的，允许多个线程/进程共享同一个IO对象，以便在不同位置读取文件。\\n这将绕过IO层的任何用户空间缓冲。\\n如果存在可选的<i>outbuf->argument，它必须引用一个字符串，该字符串将接收数据。\\n出错时引发<code>SystemCallError</code>，文件结尾处引发<code>EOFError</code>，如果平台未实现系统调用，则引发<code>NotImplementedError</code>。\\n \n   File.write(\"testfile\", \"This is line one\\nThis is line two\\n\")\n   File.open(\"testfile\") do |f|\n     p f.read           # => \"This is line one\\nThis is line two\\n\"\n     p f.pread(12, 0)   # => \"This is line\"\n     p f.pread(9, 8)    # => \"line one\\n\"\n结束", "name": "stat", "namespace": "IO", "path": "IO#stat", "type": "instance_method", "visibility": "public"}, "IO#sync": {"description": "将给定对象写入<em>ios。返回+nil+。\\n \\n必须打开流进行写入。\\n每个非字符串的给定对象都将通过调用其<code>to_s</code>方法进行转换。\\n在没有参数的情况下调用时，打印<code>$_</code>的内容。\\n \\n如果输出字段分隔符（<code>$,</code>）不是+nil+，则在对象之间插入该分隔符。\\n如果输出记录分隔符（<code>$\\\\</code>）不是+nil+，则会将其追加到输出中。\\n \n   $stdout.print(\"This is \", 100, \" percent.\\n\")\n \\n<em>产生：.<em>\\n \\n This is 100 percent.", "name": "sync", "namespace": "IO", "path": "IO#sync", "type": "instance_method", "visibility": "public"}, "IO#sync=": {"description": "", "name": "sync=", "namespace": "IO", "path": "IO#sync=", "type": "instance_method", "visibility": "public"}, "IO#sysread": {"description": "格式化并写入IOS，在格式字符串的控制下转换参数。有关详细信息，请参阅<code>Kernel#sprintf</code> \\n。", "name": "sysread", "namespace": "IO", "path": "IO#sysread", "type": "instance_method", "visibility": "public"}, "IO#sysseek": {"description": "如果<i>obj<i>是<code>Numeric</code>，则写入代码是<i>obj的最低有效字节的字符。\\n如果obj<i>is <code>String</code>，则写入<i>obj<i>to<em>ios<em>的第一个字符。\\n否则，提升<code>TypeError</code>。\\n \n   $stdout.putc \"A\"\n   $stdout.putc 65\n \\n<em>产生：.<em>\\n\\n aa", "name": "sysseek", "namespace": "IO", "path": "IO#sysseek", "type": "instance_method", "visibility": "public"}, "IO#syswrite": {"description": "将给定对象写入<em>ios。\\n在任何尚未以换行序列结尾的字符后写入换行符。返回+nil+。\\n \\n必须打开流进行写入。\\n如果使用数组参数调用，则在新行中写入每个元素。\\n将通过调用其+to_s+方法来转换不是字符串或数组的每个给定对象。\\n如果不带参数调用，则输出单个换行符。\\n \n   $stdout.puts(\"this\", \"is\", [\"a\", \"test\"])\n \\n<em>产生：.<em>\\n \n   this\n   is\n   a\n   test\n \\n注意+puts+总是使用换行符，并且不受输出记录分隔符（<code>$\\\\</code>）的影响。", "name": "syswrite", "namespace": "IO", "path": "IO#syswrite", "type": "instance_method", "visibility": "public"}, "IO#tell": {"description": "将给定字符串写入<em>ios<em>at<i>offset<i>using pwrite（）\\n system call。这有利于将IO seek和IO write结合起来，因为它是原子的，允许多个线程/进程共享相同的IO对象，以便在不同的位置读取文件。\\n这将绕过IO层的任何用户空间缓冲。\\n返回写入的字节数。\\n出错时引发<code>SystemCallError</code>，如果平台未实现系统调用，则引发<code>NotImplementedError</code>。\\n \n   File.open(\"out\", \"w\") do |f|\n     f.pwrite(\"ABCDEF\", 3)   #=> 6\n   end\n \\n    File.read(\"out\")          #=> \"\\u0000\\u0000\\u0000ABCDEF\"", "name": "tell", "namespace": "IO", "path": "IO#tell", "type": "instance_method", "visibility": "public"}, "IO#to_io": {"description": "从I/O流读取长度字节。\\n \\n长度必须是非负整数或+nil+。\\n \\n如果长度为正整数，+read+将尝试在不进行任何转换的情况下读取长度字节（二进制模式）。\\n如果在读取任何内容之前遇到EOF，则返回+nil+。\\n如果在读取过程中遇到EOF，则返回的长度小于字节数。\\n对于整数\\长度\\的情况，生成的字符串始终采用ASCII-8bit编码。\\n \\n如果省略长度或长度为+nil+，则读取到eof \\n，并应用编码转换（如果适用）。\\n即使在读取任何数据之前遇到EOF，也会返回字符串。\\n \\n如果长度为零，则返回空字符串（<code>\"\"</code>）。\\n \\n如果存在可选的outbuf参数，它必须引用将接收数据的字符串。\\n outbuf将只包含方法调用后接收的数据，即使它在开始时不是空的。\\n \\n当在文件结尾调用此方法时，它将返回+nil+ \\n或<code>\"\"</code>，具体取决于\\n +read+，<code>read(nil)</code>，and <code>read(0)</code> return \\n <code>\"\"</code>，\\n<code>read（<i>positive_integer</i>）.<code>returns +nil+.\\n \n   f = File.new(\"testfile\")\n   f.read(16)   #=> \"This is line one\"\n\n   # read whole file\n   open(\"file\") do |f|\n     data = f.read   # This returns a string even if the file is empty.\n     # ...\n   end\n\n   # iterate over fixed length records\n   open(\"fixed-record-file\") do |f|\n     while record = f.read(256)\n       # ...\n     end\n   end\n\n   # iterate over variable length records,\n   # each record is prefixed by its 32-bit length\n   open(\"variable-record-file\") do |f|\n     while len = f.read(4)\n       len = len.unpack(\"N\")[0]   # 32-bit length\n       record = f.read(len)       # This returns a string even if len is 0.\n     end\n   end\n \\n请注意，此方法的行为类似于C中的fread（）函数。\\n这意味着它会重试调用read（2）系统调用以读取指定长度（或直到eof）的数据。\\n即使<i>ios<i>处于非阻塞模式，此行为也会保留。\\n（此方法与其他方法一样不区分块标志。）\\n如果您需要类似于单个读取（2）系统调用的行为，请考虑readpartial、read35u nonblock和sysread。", "name": "to_io", "namespace": "IO", "path": "IO#to_io", "type": "instance_method", "visibility": "public"}, "IO#tty?": {"description": "使用<code>IO#getbyte</code>读取字节，但在文件结尾处引发\\n <code>EOFError</code>。", "name": "tty?", "namespace": "IO", "path": "IO#tty?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "IO#ungetbyte": {"description": "从<em>ios读取一个字符串。在文件结尾处引发\\n <code>EOFError</code>。n \n   f = File.new(\"testfile\")\n   f.readchar   #=> \"h\"\n   f.readchar   #=> \"e\"", "name": "ungetbyte", "namespace": "IO", "path": "IO#ungetbyte", "type": "instance_method", "visibility": "public"}, "IO#ungetc": {"description": "使用<code>IO#gets</code>读取一行，但在文件结尾处引发\\n <code>EOFError</code>。", "name": "ungetc", "namespace": "IO", "path": "IO#ungetc", "type": "instance_method", "visibility": "public"}, "IO#write": {"description": "读取<em>ios中的所有行，并在数组中返回它们。行由可选的<i>sep>sep隔开。如果\\n<i>sep<i>is +nil+，则流的其余部分作为单个记录返回。\\n如果第一个参数是整数，或者给定了\\n可选的第二个参数，则返回的字符串将不会长于以字节为单位的给定值。必须打开流进行读取，否则将引发<code>IOError</code>。\\n \n   f = File.new(\"testfile\")\n   f.readlines[0]   #=> \"This is line one\\n\"\n\n   f = File.new(\"testfile\", chomp: true)\n   f.readlines[0]   #=> \"This is line one\"\n \\n有关getline_args的详细信息，请参阅IO.readlines。", "name": "write", "namespace": "IO", "path": "IO#write", "type": "instance_method", "visibility": "public"}, "IO.binread": {"description": "最多从I/O流读取<i>maxlen</i>bytes。\\n只有当<em>ios<em>没有立即可用的数据时，它才会阻止。\\n如果某些数据可用，它不会阻止。\\n \\n如果存在可选的outbuf参数，它必须引用将接收数据的字符串。\\n outbuf将只包含方法调用后接收的数据，即使它在开始时不是空的。\\n \\n在文件结尾处引发<code>EOFError</code>。\\n \\n readpartial是为管道、套接字、tty等流设计的。\\n它仅在没有立即可用的数据时阻塞。\\n这意味着只有在满足所有条件时才会阻止。\\n*IO对象中的字节缓冲区为空。\\n*流的内容为空。\\n*流未到达eof。\\n \\n readpartial块时，它在流上等待数据或eof。\\n如果到达某些数据，readpartial将随数据返回。\\n如果达到eof，readpartial将引发eoferror。\\n \\n当readpartial不阻塞时，它会立即返回或引发。\\n如果字节缓冲区不为空，则返回缓冲区中的数据。\\n否则，如果流包含某些内容，则返回流中的数据。\\n否则，如果流到达eof，它将引发eoferror。\\n \n   r, w = IO.pipe           #               buffer          pipe content\n   w << \"abc\"               #               \"\"              \"abc\".\n   r.readpartial(4096)      #=> \"abc\"       \"\"              \"\"\n   r.readpartial(4096)      # blocks because buffer and pipe is empty.\n\n   r, w = IO.pipe           #               buffer          pipe content\n   w << \"abc\"               #               \"\"              \"abc\"\n   w.close                  #               \"\"              \"abc\" EOF\n   r.readpartial(4096)      #=> \"abc\"       \"\"              EOF\n   r.readpartial(4096)      # raises EOFError\n\n   r, w = IO.pipe           #               buffer          pipe content\n   w << \"abc\\ndef\\n\"        #               \"\"              \"abc\\ndef\\n\"\n   r.gets                   #=> \"abc\\n\"     \"def\\n\"         \"\"\n   w << \"ghi\\n\"             #               \"def\\n\"         \"ghi\\n\"\n   r.readpartial(4096)      #=> \"def\\n\"     \"\"              \"ghi\\n\"\n   r.readpartial(4096)      #=> \"ghi\\n\"     \"\"              \"\"\n \\n请注意，read分部的行为类似于sysread。\\n差异为：\\n*如果字节缓冲区不为空，则从字节缓冲区读取而不是“缓冲IO的sysread（ioerror）”。\\n*不会导致errno:：EWOULDBLOCK和errno:：EINTR。当readpartial通过read系统调用满足EWOULDBLOCK和EINTR时，readpartial重试系统调用。\\n \\n后者表示readpartial不区分阻塞标志。\\n它在IO sysread的情况下阻塞，导致errno:：EWOULDBLOCK，就好像fd是阻塞模式一样。", "name": "binread", "namespace": "IO", "path": "IO.binread", "type": "class_method", "visibility": "public"}, "IO.binwrite": {"description": "将<em>ios与在\\n<i>other_i o中给定的I/O流重新关联\\n<i>or to a new stream opened o n<i>path.<i>。这可能会动态地更改此流的实际类。n \n   f1 = File.new(\"testfile\")\n   f2 = File.new(\"testfile\")\n   f2.readlines[0]   #=> \"This is line one\\n\"\n   f2.reopen(f1)     #=> #<File:testfile>\n   f2.readlines[0]   #=> \"This is line one\\n\"", "name": "binwrite", "namespace": "IO", "path": "IO.binwrite", "type": "class_method", "visibility": "public"}, "IO.copy_stream": {"description": "positions<em>ios<em>to the begin of input，resetting <code>lineno</code> to zero.\\n \n   f = File.new(\"testfile\")\n   f.readline   #=> \"This is line one\\n\"\n   f.rewind     #=> 0\n   f.lineno     #=> 0\n   f.readline   #=> \"This is line one\\n\"\n \\n请注意，它不能与管道、tty和套接字等流一起使用。", "name": "copy_stream", "namespace": "IO", "path": "IO.copy_stream", "type": "class_method", "visibility": "public"}, "IO.for_fd": {"description": "根据<i>Whence的值，在流中查找给定的偏移量<i>Aninteger</i>：\\n \n  :CUR or IO::SEEK_CUR  | Seeks to _amount_ plus current position\n  ----------------------+--------------------------------------------------\n  :END or IO::SEEK_END  | Seeks to _amount_ plus end of stream (you\n                        | probably want a negative value for _amount_)\n  ----------------------+--------------------------------------------------\n  :SET or IO::SEEK_SET  | Seeks to the absolute location given by _amount_\n\\n示例：\\n \n   f = File.new(\"testfile\")\n   f.seek(-13, IO::SEEK_END)   #=> 0\n   f.readline                  #=> \"And so on...\\n\"", "name": "for_fd", "namespace": "IO", "path": "IO.for_fd", "type": "class_method", "visibility": "public"}, "IO.foreach": {"description": "如果指定了单个参数，则会使用指定的编码标记IO中的读取字符串。如果编码是以冒号分隔的两个编码名称“A:B”，则读取字符串将从编码A（外部编码）转换为编码B（内部编码），然后用B标记。如果指定了两个参数，则这些参数必须是编码对象或编码名称，第一个是外部编码，第二个是内部编码惯性导航与制导。\\n如果指定了外部编码和内部编码，则\\n可选哈希参数指定转换选项。", "name": "foreach", "namespace": "IO", "path": "IO.foreach", "type": "class_method", "visibility": "public"}, "IO.new": {"description": ":nodoc:", "name": "new", "namespace": "IO", "path": "IO.new", "type": "class_method", "visibility": "public"}, "IO.open": {"description": "将<em>ios的状态信息作为<code>File::Stat</code>类型的对象返回。n \n   f = File.new(\"testfile\")\n   s = f.stat\n   \"%o\" % s.mode   #=> \"100644\"\n   s.blksize       #=> 4096\n   s.atime         #=> Wed Apr 09 08:53:54 CDT 2003", "name": "open", "namespace": "IO", "path": "IO.open", "type": "class_method", "visibility": "public"}, "IO.pipe": {"description": "返回<em>ios的当前“同步模式”。当sync模式为true时，所有输出都会立即刷新到底层操作系统，并且不会被ruby内部缓冲。另见<code>IO#fsync</code>。n \n   f = File.new(\"testfile\")\n   f.sync   #=> false", "name": "pipe", "namespace": "IO", "path": "IO.pipe", "type": "class_method", "visibility": "public"}, "IO.popen": {"description": "使用低级读取从<em>ios读取<i>maxlen<i>bytes，并将其作为字符串返回。不要与从<em>ios读取的其他方法混合，否则可能会得到不可预知的结果。\\n \\n如果存在可选的outbuf参数，它必须引用将接收数据的字符串。\\n outbuf将只包含方法调用后接收的数据，即使它在开始时不是空的。\\n \\n发生错误时引发<code>SystemCallError</code>，在文件结尾引发<code>EOFError</code>。n \n   f = File.new(\"testfile\")\n   f.sysread(16)   #=> \"This is line one\"", "name": "popen", "namespace": "IO", "path": "IO.popen", "type": "class_method", "visibility": "public"}, "IO.read": {"description": "根据<i>whence的值在流中查找给定的<i>偏移量</i>（请参见<code>IO#seek</code>以获取\\n<i>whence的值）。将新偏移量返回到文件中。n \n   f = File.new(\"testfile\")\n   f.sysseek(-13, IO::SEEK_END)   #=> 53\n   f.sysread(10)                  #=> \"And so on.\"", "name": "read", "namespace": "IO", "path": "IO.read", "type": "class_method", "visibility": "public"}, "IO.readlines": {"description": "使用低级写入将给定字符串写入<em>ios。\\n返回写入的字节数。不要与写入<em>ios的其他方法混合，否则可能会得到不可预知的结果。\\n出错时引发<code>SystemCallError</code>。n \n   f = File.new(\"out\", \"w\")\n   f.syswrite(\"ABCDEF\")   #=> 6", "name": "readlines", "namespace": "IO", "path": "IO.readlines", "type": "class_method", "visibility": "public"}, "IO.select": {"description": "返回<em>ios的当前偏移量（以字节为单位）。n \n   f = File.new(\"testfile\")\n   f.pos    #=> 0\n   f.gets   #=> \"This is line one\\n\"\n   f.pos    #=> 17", "name": "select", "namespace": "IO", "path": "IO.select", "type": "class_method", "visibility": "public"}, "IO.sysopen": {"description": "返回iOS。", "name": "sysopen", "namespace": "IO", "path": "IO.sysopen", "type": "class_method", "visibility": "public"}, "IO.try_convert": {"description": "如果与终端设备（TTY）关联，则返回<code>true</code>，否则返回<code>false</code>。n \n   File.new(\"testfile\").isatty   #=> false\n   File.new(\"/dev/tty\").isatty   #=> true", "name": "try_convert", "namespace": "IO", "path": "IO.try_convert", "type": "class_method", "visibility": "public"}, "IO.write": {"description": "将字节（作为参数传递）向后推到<em>ios上，以便随后的缓冲读取将返回该字节。在随后的读取操作之前，只能向后推一个字节（即，您将只能读取被向后推的几个字节中的最后一个）。对未缓冲的读取没有影响（如<code>IO#sysread</code>）。n \n   f = File.new(\"testfile\")   #=> #<File:testfile>\n   b = f.getbyte              #=> 0x38\n   f.ungetbyte(b)             #=> nil\n   f.getbyte                  #=> 0x38", "name": "write", "namespace": "IO", "path": "IO.write", "type": "class_method", "visibility": "public"}, "IO::EAGAINWaitReadable": {"description": "", "name": "EAGAINWaitReadable", "namespace": "IO", "path": "IO::EAGAINWaitReadable", "type": "class", "visibility": "public"}, "IO::EAGAINWaitWritable": {"description": "", "name": "EAGAINWaitWritable", "namespace": "IO", "path": "IO::EAGAINWaitWritable", "type": "class", "visibility": "public"}, "IO::EINPROGRESSWaitReadable": {"description": "", "name": "EINPROGRESSWaitReadable", "namespace": "IO", "path": "IO::EINPROGRESSWaitReadable", "type": "class", "visibility": "public"}, "IO::EINPROGRESSWaitWritable": {"description": "", "name": "EINPROGRESSWaitWritable", "namespace": "IO", "path": "IO::EINPROGRESSWaitWritable", "type": "class", "visibility": "public"}, "IO::EWOULDBLOCKWaitReadable": {"description": "将一个字符（作为参数传递）向后推到<em>ios上，这样随后的缓冲字符读取将返回该字符。在随后的读取操作之前，只能向后推一个字符（即，您将只能读取被向后推的几个字符中的最后一个）。对未缓冲的读取没有影响（如<code>IO#sysread</code>）。n \n   f = File.new(\"testfile\")   #=> #<File:testfile>\n   c = f.getc                 #=> \"8\"\n   f.ungetc(c)                #=> nil\n   f.getc                     #=> \"8\"", "name": "EWOULDBLOCKWaitReadable", "namespace": "IO", "path": "IO::EWOULDBLOCKWaitReadable", "type": "constant", "return": ["Class", ""], "visibility": "public"}, "IO::EWOULDBLOCKWaitWritable": {"description": "将给定字符串写入<em>ios。必须打开流进行写入。非字符串的参数将使用<code>to_s</code>转换为字符串。返回总写入字节数。\\n \n   count = $stdout.write(\"This is\", \" a test\\n\")\n   puts \"That was #{count} bytes of data\"\n \\n<em>产生：.<em>\\n \n   This is a test\n that was 15 bytes of data", "name": "EWOULDBLOCKWaitWritable", "namespace": "IO", "path": "IO::EWOULDBLOCKWaitWritable", "type": "constant", "return": ["Class", ""], "visibility": "public"}, "IO::SEEK_CUR": {"description": "打开文件，可选择查找给定的“偏移量”，然后返回\\n“长度”（长度）（默认为文件的其余部分）。\\n <code>binread</code>确保返回前关闭文件。\\n打开模式为“rb:ASCII-8bit”。n \n   IO.binread(\"testfile\")           #=> \"This is line one\\nThis is line two\\nThis is line three\\nAnd so on...\\n\"\n   IO.binread(\"testfile\", 20)       #=> \"This is line one\\nThi\"\n   IO.binread(\"testfile\", 20, 10)   #=> \"ne one\\nThis is line \"", "name": "SEEK_CUR", "namespace": "IO", "path": "IO::SEEK_CUR", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "IO::SEEK_DATA": {"description": "与<code>IO.write</code>相同，除了以二进制模式打开文件和ASCII-8bit编码（“wb:ASCII-8bit”）。", "name": "SEEK_DATA", "namespace": "IO", "path": "IO::SEEK_DATA", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "IO::SEEK_END": {"description": "io.copy_stream copies<i>src.<i>to<i>dst.<i>\\n<i>src.<i>and<i>dst.<i>is either a filename or a n io like object.\\n IO-like object for<i>SRC</i>should have <code>readpartial</code> or <code>read</code> method.\\n io-like object for<i>dst</i>should have <code>write</code> method.\\n（可以在适当的情况下使用专门的机制，如sendfile系统调用。）\\n \\n此方法返回复制的字节数。\\n \\n如果未给定可选参数，则副本的起始位置是文件名的起始位置或IO的当前文件偏移量。\\n副本的结束位置是文件的结尾。\\n \\n如果给定了“复制长度”，则不超过“复制长度”。\\n \\n如果给定了<i>src_offset</i>，则指定副本的起始位置。\\n \\n当指定了<i>src_offset</i>并且\\n<i>src</i>是IO时，IO.copy_stream不会移动当前文件偏移量。", "name": "SEEK_END", "namespace": "IO", "path": "IO::SEEK_END", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "IO::SEEK_HOLE": {"description": "<code>IO.new</code>的同义词。", "name": "SEEK_HOLE", "namespace": "IO", "path": "IO::SEEK_HOLE", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "IO::SEEK_SET": {"description": "对指定的I/O端口中的每一行执行块，其中行由<em>sep>分隔。\\n \\n如果没有给定块，则返回枚举器。\\n \n   IO.foreach(\"testfile\") {|x| print \"GOT \", x }\n \\n<em>产生：.-\\n \n   GOT This is line one\n   GOT This is line two\n   GOT This is line three\n   GOT And so on...\n \\n如果最后一个参数是哈希，则是要打开的关键字参数。\\n有关getline_args的详细信息，请参阅IO.readlines。\\n有关open_args的详细信息，请参阅IO.read。", "name": "SEEK_SET", "namespace": "IO", "path": "IO::SEEK_SET", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "IO::WaitReadable": {"description": "", "name": "WaitReadable", "namespace": "IO", "path": "IO::WaitReadable", "type": "module", "visibility": "public"}, "IO::WaitWritable": {"description": "", "name": "WaitWritable", "namespace": "IO", "path": "IO::WaitWritable", "type": "module", "visibility": "public"}, "ObjectSpace": {"description": "call seq:\n   IO.open(fd, mode=\"r\" [, opt])                -> io\n   IO.open(fd, mode=\"r\" [, opt]) {|io| block }  -> obj\n \\n如果没有关联的块，<code>IO.open</code>是io.new的同义词。如果给定了可选代码块，它将作为参数传递+io+，并且IO对象将在块终止时自动关闭。\\n在此实例中，IO.open返回块的值。\\n \\n有关+fd+、+mode+和+opt+参数的描述，请参阅IO.new。", "name": "ObjectSpace", "namespace": "", "path": "ObjectSpace", "type": "module", "visibility": "public"}, "ObjectSpace#_id2ref": {"description": "尝试使用to_io方法将<i>obj<i>转换为IO。\\n如果由于任何原因无法转换，则返回converted io或+nil+。n \n   IO.try_convert(STDOUT)     #=> STDOUT\n   IO.try_convert(\"STDOUT\")   #=> nil\n\n   require 'zlib'\n   f = open(\"/tmp/zz.gz\")       #=> #<File:/tmp/zz.gz>\n   z = Zlib::GzipReader.open(f) #=> #<Zlib::GzipReader:0x81d8744>\n   IO.try_convert(z)            #=> #<File:/tmp/zz.gz>", "name": "_id2ref", "namespace": "ObjectSpace", "path": "ObjectSpace#_id2ref", "type": "module_function", "visibility": "private"}, "ObjectSpace#count_objects": {"description": "打开文件，可选择查找给定的“偏移量”（Offset），“写入”（Writes），然后返回写入的长度。\\n <code>write</code>确保返回前关闭文件。\\n如果在写入模式下未给定<i>offset</i>，则文件被截断。\\n否则，它不会被截断。\\n \n  IO.write(\"testfile\", \"0123456789\", 20)  #=> 10\n  # File could contain:  \"This is line one\\nThi0123456789two\\nThis is line three\\nAnd so on...\\n\"\n  IO.write(\"testfile\", \"0123456789\")      #=> 10\n  # File would now read: \"0123456789\"\n \\n如果最后一个参数是哈希，则指定内部open（）的选项。它接受以下键：\\n\\n:编码：：\n  string or encoding\n\n  Specifies the encoding of the read string.\n  See Encoding.aliases for possible encodings.\n\\n:模式：：\n  string or integer\n\n  Specifies the <i>mode</i> argument for open().  It must start\n  with \"w\", \"a\", or \"r+\", otherwise it will cause an error.\n  See IO.new for the list of possible modes.\n\\n:排列：：\n  integer\n\n  Specifies the <i>perm</i> argument for open().\n\\n:打开参数：：\n  array\n100443此键不能与其他键组合使用。", "name": "count_objects", "namespace": "ObjectSpace", "path": "ObjectSpace#count_objects", "type": "module_function", "visibility": "private"}, "ObjectSpace#define_finalizer": {"description": "：eagainwaitreadable", "name": "define_finalizer", "namespace": "ObjectSpace", "path": "ObjectSpace#define_finalizer", "type": "module_function", "visibility": "private"}, "ObjectSpace#each_object": {"description": "：eagainwaitwritable", "name": "each_object", "namespace": "ObjectSpace", "path": "ObjectSpace#each_object", "type": "module_function", "visibility": "private"}, "ObjectSpace#garbage_collect": {"description": "正在运行的文件的路径", "name": "garbage_collect", "namespace": "ObjectSpace", "path": "ObjectSpace#garbage_collect", "type": "module_function", "visibility": "private"}, "ObjectSpace#undefine_finalizer": {"description": "将I/O位置设置为包含数据的下一个位置", "name": "undefine_finalizer", "namespace": "ObjectSpace", "path": "ObjectSpace#undefine_finalizer", "type": "module_function", "visibility": "private"}, "ObjectSpace._id2ref": {"description": "尝试使用to_io方法将<i>obj<i>转换为IO。\\n如果由于任何原因无法转换，则返回converted io或+nil+。n \n   IO.try_convert(STDOUT)     #=> STDOUT\n   IO.try_convert(\"STDOUT\")   #=> nil\n\n   require 'zlib'\n   f = open(\"/tmp/zz.gz\")       #=> #<File:/tmp/zz.gz>\n   z = Zlib::GzipReader.open(f) #=> #<Zlib::GzipReader:0x81d8744>\n   IO.try_convert(z)            #=> #<File:/tmp/zz.gz>", "name": "_id2ref", "namespace": "ObjectSpace", "path": "ObjectSpace._id2ref", "type": "module_function", "visibility": "public"}, "ObjectSpace.count_objects": {"description": "打开文件，可选择查找给定的“偏移量”（Offset），“写入”（Writes），然后返回写入的长度。\\n <code>write</code>确保返回前关闭文件。\\n如果在写入模式下未给定<i>offset</i>，则文件被截断。\\n否则，它不会被截断。\\n \n  IO.write(\"testfile\", \"0123456789\", 20)  #=> 10\n  # File could contain:  \"This is line one\\nThi0123456789two\\nThis is line three\\nAnd so on...\\n\"\n  IO.write(\"testfile\", \"0123456789\")      #=> 10\n  # File would now read: \"0123456789\"\n \\n如果最后一个参数是哈希，则指定内部open（）的选项。它接受以下键：\\n\\n:编码：：\n  string or encoding\n\n  Specifies the encoding of the read string.\n  See Encoding.aliases for possible encodings.\n\\n:模式：：\n  string or integer\n\n  Specifies the <i>mode</i> argument for open().  It must start\n  with \"w\", \"a\", or \"r+\", otherwise it will cause an error.\n  See IO.new for the list of possible modes.\n\\n:排列：：\n  integer\n\n  Specifies the <i>perm</i> argument for open().\n\\n:打开参数：：\n  array\n100443此键不能与其他键组合使用。", "name": "count_objects", "namespace": "ObjectSpace", "path": "ObjectSpace.count_objects", "type": "module_function", "visibility": "public"}, "ObjectSpace.define_finalizer": {"description": "：eagainwaitreadable", "name": "define_finalizer", "namespace": "ObjectSpace", "path": "ObjectSpace.define_finalizer", "type": "module_function", "visibility": "public"}, "ObjectSpace.each_object": {"description": "：eagainwaitwritable", "name": "each_object", "namespace": "ObjectSpace", "path": "ObjectSpace.each_object", "type": "module_function", "visibility": "public"}, "ObjectSpace.garbage_collect": {"description": "正在运行的文件的路径", "name": "garbage_collect", "namespace": "ObjectSpace", "path": "ObjectSpace.garbage_collect", "type": "module_function", "visibility": "public"}, "ObjectSpace.undefine_finalizer": {"description": "将I/O位置设置为包含数据的下一个位置", "name": "undefine_finalizer", "namespace": "ObjectSpace", "path": "ObjectSpace.undefine_finalizer", "type": "module_function", "visibility": "public"}, "ObjectSpace::WeakMap": {"description": "从末端设置I/O位置", "name": "WeakMap", "namespace": "ObjectSpace", "path": "ObjectSpace::WeakMap", "type": "class", "visibility": "public"}, "ObjectSpace::WeakMap#[]": {"description": "将I/O位置设置为下一个孔", "name": "[]", "namespace": "ObjectSpace::WeakMap", "path": "ObjectSpace::WeakMap#[]", "type": "instance_method", "visibility": "public"}, "ObjectSpace::WeakMap#[]=": {"description": "从开始设置I/O位置", "name": "[]=", "namespace": "ObjectSpace::WeakMap", "path": "ObjectSpace::WeakMap#[]=", "type": "instance_method", "visibility": "public"}, "ObjectSpace::WeakMap#each": {"description": "删除<i>obj>的所有终结器。", "name": "each", "namespace": "ObjectSpace::WeakMap", "path": "ObjectSpace::WeakMap#each", "type": "instance_method", "visibility": "public"}, "ObjectSpace::WeakMap#each_key": {"description": "删除<i>obj>的所有终结器。", "name": "each_key", "namespace": "ObjectSpace::WeakMap", "path": "ObjectSpace::WeakMap#each_key", "type": "instance_method", "visibility": "public"}, "ObjectSpace::WeakMap#each_pair": {"description": "删除<i>obj>的所有终结器。", "name": "each_pair", "namespace": "ObjectSpace::WeakMap", "path": "ObjectSpace::WeakMap#each_pair", "type": "instance_method", "visibility": "public"}, "ObjectSpace::WeakMap#each_value": {"description": "删除<i>obj>的所有终结器。", "name": "each_value", "namespace": "ObjectSpace::WeakMap", "path": "ObjectSpace::WeakMap#each_value", "type": "instance_method", "visibility": "public"}, "ObjectSpace::WeakMap#finalize": {"description": "", "name": "finalize", "namespace": "ObjectSpace::WeakMap", "path": "ObjectSpace::WeakMap#finalize", "type": "instance_method", "visibility": "private"}, "ObjectSpace::WeakMap#include?": {"description": "将对象ID转换为对该对象的引用。不能对作为参数传递给终结器的对象ID调用。n \n   s = \"I am a string\"                    #=> \"I am a string\"\n   r = ObjectSpace._id2ref(s.object_id)   #=> \"I am a string\"\n   r == s                                 #=> true", "name": "include?", "namespace": "ObjectSpace::WeakMap", "path": "ObjectSpace::WeakMap#include?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "ObjectSpace::WeakMap#inspect": {"description": "", "name": "inspect", "namespace": "ObjectSpace::WeakMap", "path": "ObjectSpace::WeakMap#inspect", "type": "instance_method", "visibility": "public"}, "ObjectSpace::WeakMap#key?": {"description": "将对象ID转换为对该对象的引用。不能对作为参数传递给终结器的对象ID调用。n \n   s = \"I am a string\"                    #=> \"I am a string\"\n   r = ObjectSpace._id2ref(s.object_id)   #=> \"I am a string\"\n   r == s                                 #=> true", "name": "key?", "namespace": "ObjectSpace::WeakMap", "path": "ObjectSpace::WeakMap#key?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "ObjectSpace::WeakMap#keys": {"description": "删除<i>obj>的所有终结器。", "name": "keys", "namespace": "ObjectSpace::WeakMap", "path": "ObjectSpace::WeakMap#keys", "type": "instance_method", "visibility": "public"}, "ObjectSpace::WeakMap#length": {"description": "", "name": "length", "namespace": "ObjectSpace::WeakMap", "path": "ObjectSpace::WeakMap#length", "type": "instance_method", "visibility": "public"}, "ObjectSpace::WeakMap#member?": {"description": "将对象ID转换为对该对象的引用。不能对作为参数传递给终结器的对象ID调用。n \n   s = \"I am a string\"                    #=> \"I am a string\"\n   r = ObjectSpace._id2ref(s.object_id)   #=> \"I am a string\"\n   r == s                                 #=> true", "name": "member?", "namespace": "ObjectSpace::WeakMap", "path": "ObjectSpace::WeakMap#member?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "ObjectSpace::WeakMap#size": {"description": "", "name": "size", "namespace": "ObjectSpace::WeakMap", "path": "ObjectSpace::WeakMap#size", "type": "instance_method", "visibility": "public"}, "ObjectSpace::WeakMap#values": {"description": "对按类型分组的所有对象进行计数。\\n \\n它返回一个哈希，例如：\\n \\n:TOTAL=>10000、\\n:FREE=>3011、\\n:T_OBJECT=>6、\\n:T_CLASS=>404、\\n……\\n \\n \\n传回的杂凑内容是实作特定的。\\n将来可能会更改。\\n \\n以+开头的键表示活动对象。\\n例如，+：T_ARRAY+是阵列数目。\\n+：FREE+表示现在未使用的对象插槽。\\n+：TOTAL+表示以上总和。\\n \\n如果给定可选参数+result_hash+，它将被覆盖并返回。这是为了避免探针效应。\\n \n  h = {}\n  ObjectSpace.count_objects(h)\n  puts h\n  # => { :TOTAL=>10000, :T_CLASS=>158280, :T_MODULE=>20672, :T_STRING=>527249 }\n \\n此方法只适用于C Ruby。", "name": "values", "namespace": "ObjectSpace::WeakMap", "path": "ObjectSpace::WeakMap#values", "type": "instance_method", "visibility": "public"}, "Hash": {"description": "添加<i>aprc->i>作为终结器，以便在<i>obj-\\n was destroyed之后调用。<i>obj的对象ID将作为参数传递给<i>aprc。如果<i>aproc<i>是lambda或方法，请确保可以使用单个参数调用它。", "name": "Hash", "namespace": "", "path": "Hash", "type": "class", "visibility": "public"}, "Hash#<": {"description": "在这个Ruby进程中，为每个活动的非即时对象调用一次该块。如果指定了<i>模块，则仅为匹配的类或模块（或是模块的子类）调用块\\n<i>module</i>。返回找到的对象数。即时对象（<code>Fixnum</code>s、<code>Symbol</code>s <code>true</code>、<code>false</code>和<code>nil</code>）永远不会返回。在下面的示例中，<code>each_object</code> \\n返回我们定义的数字和在<code>Math</code>模块中定义的几个常量。\\n \\n如果没有给定块，则返回枚举器。\\n \n   a = 102.7\n   b = 95       # Won't be returned\n   c = 12345678987654321\n   count = ObjectSpace.each_object(Numeric) {|x| p x }\n   puts \"Total count: #{count}\"\n \\n<em>产生：.<em>\\n \n   12345678987654321\n   102.7\n   2.71828182845905\n   3.14159265358979\n   2.22044604925031e-16\n   1.7976931348623157e+308\n   2.2250738585072e-308\n total count:7", "name": "<", "namespace": "Hash", "path": "Hash#<", "type": "instance_method", "visibility": "public"}, "Hash#<=": {"description": "启动垃圾收集，除非手动禁用。\\n \\n此方法是用默认为true的关键字参数定义的：\\n \n   def GC.start(full_mark: true, immediate_sweep: true); end\n \\n使用full_-mark:false执行次要GC。\\n使用immediate_-sweep:false推迟扫描（使用lazy-sweep）。\\n \\n注意：这些关键字参数依赖于实现和版本。它们不能保证将来兼容，如果底层实现不支持它们，则可以忽略它们。", "name": "<=", "namespace": "Hash", "path": "Hash#<=", "type": "instance_method", "visibility": "public"}, "Hash#==": {"description": "删除<i>obj>的所有终结器。", "name": "==", "namespace": "Hash", "path": "Hash#==", "type": "instance_method", "visibility": "public"}, "Hash#>": {"description": "ObjectSpace:：WeakMap对象包含对任何对象的引用，但这些对象可能会被垃圾收集。\\n \\n此类主要由WeakRef内部使用，请使用\\n+lib/weakref.rb+作为公共接口。", "name": ">", "namespace": "Hash", "path": "Hash#>", "type": "instance_method", "visibility": "public"}, "Hash#>=": {"description": "使用给定的键检索弱引用的对象", "name": ">=", "namespace": "Hash", "path": "Hash#>=", "type": "instance_method", "visibility": "public"}, "Hash#[]": {"description": "创建从给定键到给定值的弱引用", "name": "[]", "namespace": "Hash", "path": "Hash#[]", "type": "instance_method", "visibility": "public"}, "Hash#[]=": {"description": "", "name": "[]=", "namespace": "Hash", "path": "Hash#[]=", "type": "instance_method", "visibility": "public"}, "Hash#any?": {"description": "迭代弱引用对象中的键和对象", "name": "any?", "namespace": "Hash", "path": "Hash#any?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Hash#assoc": {"description": "迭代弱引用对象中的键和对象", "name": "assoc", "namespace": "Hash", "path": "Hash#assoc", "type": "instance_method", "visibility": "public"}, "Hash#clear": {"description": "迭代弱引用对象中的键和对象", "name": "clear", "namespace": "Hash", "path": "Hash#clear", "type": "instance_method", "visibility": "public"}, "Hash#compact": {"description": "迭代弱引用对象中的键和对象", "name": "compact", "namespace": "Hash", "path": "Hash#compact", "type": "instance_method", "visibility": "public"}, "Hash#compact!": {"description": "如果+key+已注册，则返回+true+", "name": "compact!", "namespace": "Hash", "path": "Hash#compact!", "type": "instance_method", "visibility": "public"}, "Hash#compare_by_identity": {"description": "如果+key+已注册，则返回+true+", "name": "compare_by_identity", "namespace": "Hash", "path": "Hash#compare_by_identity", "type": "instance_method", "visibility": "public"}, "Hash#compare_by_identity?": {"description": "迭代弱引用对象中的键和对象", "name": "compare_by_identity?", "namespace": "Hash", "path": "Hash#compare_by_identity?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Hash#default": {"description": "如果注册了+key+，则返回+true+", "name": "default", "namespace": "Hash", "path": "Hash#default", "type": "instance_method", "visibility": "public"}, "Hash#default=": {"description": "迭代弱引用对象中的值和对象", "name": "default=", "namespace": "Hash", "path": "Hash#default=", "type": "instance_method", "visibility": "public"}, "Hash#default_proc": {"description": "哈希是一个类似字典的唯一键及其值的集合。\\n也称为关联数组，它们与数组相似，但当数组使用整数作为索引时，哈希允许您使用任何对象类型。\\n \\n哈希按插入相应键的顺序枚举其值。\\n \\n散列可以通过使用其隐式形式轻松创建：\\n \n  grades = { \"Jane Doe\" => 10, \"Jim Doe\" => 6 }\n \\n散列允许为符号的键使用备用语法。\\n不是\n  options = { :font_size => 10, :font_family => \"Arial\" }\n \\n您可以将其写为：\\n \n  options = { font_size: 10, font_family: \"Arial\" }\n \\n每个命名的键都是可以在哈希中访问的符号：\\n \n  options[:font_size]  # => 10\n \\n哈希也可以通过其：：new方法创建：\n  grades = Hash.new\n  grades[\"Dorothy Doe\"] = 9\n \\n哈希具有访问哈希中不存在的键时返回的<em>默认值。如果未设置默认值，则使用+nil+。\\n您可以通过将默认值作为参数发送到hash来设置该值。new:\\n \n  grades = Hash.new(0)\n \\n或者使用default=方法来设置该值：\\n \n  grades = {\"Timmy Doe\" => 8}\n  grades.default = 0\n \\n访问hash中的值需要使用其键：\\n \n  puts grades[\"Jane Doe\"] # => 0\n \\n==常用\\n \\n hash是表示数据结构的简单方法，例如\n  books         = {}\n  books[:matz]  = \"The Ruby Programming Language\"\n  books[:black] = \"The Well-Grounded Rubyist\"\n \\n hash也常用作名称的方法。函数中的d参数。请注意，下面没有使用括号。如果哈希是方法调用的最后一个参数，则不需要大括号，因此创建了一个真正干净的接口：\\n \n  Person.create(name: \"John Doe\", age: 27)\n\n  def self.create(params)\n    @name = params[:name]\n    @age  = params[:age]\n  end\n\\n==hash keys\\n\\n当两个对象的<code>hash</code>值相同且这两个对象彼此为<code>eql?</code>时，两个对象引用同一个哈希键。\\n \\n如果<code>hash</code>和<code>eql?</code>方法被重写以提供有意义的行为，则用户定义的类可以用作哈希键。默认情况下，单独的实例引用单独的哈希键。\\n \\n <code>hash</code>的典型实现基于对象的数据，而<code>eql?</code>通常是覆盖的方法的别名\\n <code>==</code>方法：\\n \n  class Book\n    attr_reader :author, :title\n\n    def initialize(author, title)\n      @author = author\n      @title = title\n    end\n\n    def ==(other)\n      self.class === other and\n        other.author == @author and\n        other.title == @title\n    end\n\n    alias eql? ==\n\n    def hash\n      @author.hash ^ @title.hash # XOR\n    end\n  end\n\n  book1 = Book.new 'matz', 'Ruby in a Nutshell'\n  book2 = Book.new 'matz', 'Ruby in a Nutshell'\n\n  reviews = {}\n\n  reviews[book1] = 'Great reference!'\n  reviews[book2] = 'Nice and compact!'\n\n  reviews.length #=> 1\n \\n另请参见对象哈希和对象eql？", "name": "default_proc", "namespace": "Hash", "path": "Hash#default_proc", "type": "instance_method", "visibility": "public"}, "Hash#default_proc=": {"description": "如果<i>hash<i>是\\n<i>other的子集，则返回<code>true</code>。n \n   h1 = {a:1, b:2}\n   h2 = {a:1, b:2, c:3}\n   h1 < h2    #=> true\n   h2 < h1    #=> false\n   h1 < h1    #=> false", "name": "default_proc=", "namespace": "Hash", "path": "Hash#default_proc=", "type": "instance_method", "visibility": "public"}, "Hash#delete": {"description": "如果<i>hash<i>is subset of \\n<i>other<i>or equals to<i>other<i>，则返回<code>true</code>。n \n   h1 = {a:1, b:2}\n   h2 = {a:1, b:2, c:3}\n   h1 <= h2   #=> true\n   h2 <= h1   #=> false\n   h1 <= h1   #=> true", "name": "delete", "namespace": "Hash", "path": "Hash#delete", "type": "instance_method", "visibility": "public"}, "Hash#delete_if": {"description": "相等-如果两个散列包含相同数量的键，并且每个键值对等于（根据<code>Object#==</code>）另一个散列中的相应元素，则两个散列相等。\\n \n   h1 = { \"a\" => 1, \"c\" => 2 }\n   h2 = { 7 => 35, \"c\" => 2, \"a\" => 1 }\n   h3 = { \"a\" => 1, \"c\" => 2, 7 => 35 }\n   h4 = { \"a\" => 1, \"d\" => 2, \"f\" => 35 }\n   h1 == h2   #=> false\n   h2 == h3   #=> true\n   h3 == h4   #=> false\n \\n不比较每个哈希的顺序。n \n   h1 = { \"a\" => 1, \"c\" => 2 }\n   h2 = { \"c\" => 2, \"a\" => 1 }\n   h1 == h2   #=> true", "name": "delete_if", "namespace": "Hash", "path": "Hash#delete_if", "type": "instance_method", "visibility": "public"}, "Hash#dig": {"description": "如果是哈希的子集，则返回<code>true</code>。n \n   h1 = {a:1, b:2}\n   h2 = {a:1, b:2, c:3}\n   h1 > h2    #=> false\n   h2 > h1    #=> true\n   h1 > h1    #=> false", "name": "dig", "namespace": "Hash", "path": "Hash#dig", "type": "instance_method", "visibility": "public"}, "Hash#each": {"description": "另请参见Enumerable有吗？", "name": "each", "namespace": "Hash", "path": "Hash#each", "type": "instance_method", "visibility": "public"}, "Hash#each_key": {"description": "元素引用-检索对应于<i>键的<i>值</i>对象。如果找不到，则返回默认值（有关详细信息，请参阅<code>Hash::new</code>）。n \n   h = { \"a\" => 100, \"b\" => 200 }\n   h[\"a\"]   #=> 100\n   h[\"c\"]   #=> nil", "name": "each_key", "namespace": "Hash", "path": "Hash#each_key", "type": "instance_method", "visibility": "public"}, "Hash#each_pair": {"description": "另请参见Enumerable有吗？", "name": "each_pair", "namespace": "Hash", "path": "Hash#each_pair", "type": "instance_method", "visibility": "public"}, "Hash#each_value": {"description": "使用<code>==</code>搜索比较obj和密钥的哈希。\\n如果找不到匹配项，则返回键值对（两个元素数组）或+nil+。见<code>Array#assoc</code>。n \n   h = {\"colors\"  => [\"red\", \"blue\", \"green\"],\n        \"letters\" => [\"a\", \"b\", \"c\" ]}\n   h.assoc(\"letters\")  #=> [\"letters\", [\"a\", \"b\", \"c\"]]\n   h.assoc(\"foo\")      #=> nil", "name": "each_value", "namespace": "Hash", "path": "Hash#each_value", "type": "instance_method", "visibility": "public"}, "Hash#empty?": {"description": "从<i>hsh中删除所有键值对。n \n   h = { \"a\" => 100, \"b\" => 200 }   #=> {\"a\"=>100, \"b\"=>200}\n   h.clear                          #=> {}", "name": "empty?", "namespace": "Hash", "path": "Hash#empty?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Hash#eql?": {"description": "返回一个新哈希，其中nil个值/键对已删除\n   h = { a: 1, b: false, c: nil }\n   h.compact     #=> { a: 1, b: false }\n   h             #=> { a: 1, b: false, c: nil }", "name": "eql?", "namespace": "Hash", "path": "Hash#eql?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Hash#fetch": {"description": "从哈希中删除所有nil值。\\n如果未做任何更改，则返回nil，否则返回哈希。n \n   h = { a: 1, b: false, c: nil }\n   h.compact!     #=> { a: 1, b: false }", "name": "fetch", "namespace": "Hash", "path": "Hash#fetch", "type": "instance_method", "visibility": "public"}, "Hash#fetch_values": {"description": "使<i>hsh<i>Compare its keys by their identity，即，它会将完全相同的对象视为相同的键。n \n   h1 = { \"a\" => 100, \"b\" => 200, :c => \"c\" }\n   h1[\"a\"]        #=> 100\n   h1.compare_by_identity\n   h1.compare_by_identity? #=> true\n   h1[\"a\".dup]    #=> nil  # different objects.\n   h1[:c]         #=> \"c\"  # same symbols are all same.", "name": "fetch_values", "namespace": "Hash", "path": "Hash#fetch_values", "type": "instance_method", "visibility": "public"}, "Hash#flatten": {"description": "如果将按其标识比较其键，则返回<code>true</code>。另见<code>Hash#compare_by_identity</code>。", "name": "flatten", "namespace": "Hash", "path": "Hash#flatten", "type": "instance_method", "visibility": "public"}, "Hash#has_key?": {"description": "返回给定键的哈希值。如果找不到键，有几个选项：如果没有其他参数，它将引发<code>KeyError</code> exception;如果指定了可选代码块，那么它将是returned;，然后它将运行并返回结果。\\n \n   h = { \"a\" => 100, \"b\" => 200 }\n   h.fetch(\"a\")                            #=> 100\n   h.fetch(\"z\", \"go fish\")                 #=> \"go fish\"\n   h.fetch(\"z\") { |el| \"go fish, #{el}\"}   #=> \"go fish, z\"\n \\n下面的示例显示，如果找不到键并且未提供默认值，则会引发异常。\\n \n   h = { \"a\" => 100, \"b\" => 200 }\n   h.fetch(\"z\")\n \\n<em>products:-\\n \n   prog.rb:2:in `fetch': key not found (KeyError)\n from prog.rb:2", "name": "has_key?", "namespace": "Hash", "path": "Hash#has_key?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Hash#has_value?": {"description": "返回一个新哈希，该哈希由块返回false的条目组成。\\n \\n如果没有给定块，则返回枚举器。\\n \n   h = { \"a\" => 100, \"b\" => 200, \"c\" => 300 }\n   h.reject {|k,v| k < \"b\"}  #=> {\"b\" => 200, \"c\" => 300}\n   h.reject {|k,v| v > 100}  #=> {\"a\" => 100}", "name": "has_value?", "namespace": "Hash", "path": "Hash#has_value?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Hash#hash": {"description": "如果使用块调用<code>Hash::new</code>，则返回该块，否则返回<code>nil</code>。n \n   h = Hash.new {|h,k| h[k] = k*k }   #=> {}\n   p = h.default_proc                 #=> #<Proc:0x401b3d08@-:1>\n   a = []                             #=> []\n   p.call(a, 2)\n   a                                  #=> [nil, nil, 4]", "name": "hash", "namespace": "Hash", "path": "Hash#hash", "type": "instance_method", "visibility": "public"}, "Hash#include?": {"description": "返回给定键的哈希值。如果找不到键，有几个选项：如果没有其他参数，它将引发<code>KeyError</code> exception;如果指定了可选代码块，那么它将是returned;，然后它将运行并返回结果。\\n \n   h = { \"a\" => 100, \"b\" => 200 }\n   h.fetch(\"a\")                            #=> 100\n   h.fetch(\"z\", \"go fish\")                 #=> \"go fish\"\n   h.fetch(\"z\") { |el| \"go fish, #{el}\"}   #=> \"go fish, z\"\n \\n下面的示例显示，如果找不到键并且未提供默认值，则会引发异常。\\n \n   h = { \"a\" => 100, \"b\" => 200 }\n   h.fetch(\"z\")\n \\n<em>products:-\\n \n   prog.rb:2:in `fetch': key not found (KeyError)\n from prog.rb:2", "name": "include?", "namespace": "Hash", "path": "Hash#include?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Hash#index": {"description": ":nodoc:", "name": "index", "namespace": "Hash", "path": "Hash#index", "type": "instance_method", "visibility": "public"}, "Hash#initialize": {"description": "删除key-value对并从其key等于<i>key的<i>hsh返回值。如果找不到键，则返回\\n<em>nil。如果给出了可选代码块，但找不到该键，则传递该键并返回\\n<i>block的结果。n \n   h = { \"a\" => 100, \"b\" => 200 }\n   h.delete(\"a\")                              #=> 100\n   h.delete(\"z\")                              #=> nil\n   h.delete(\"z\") { |el| \"#{el} not found\" }   #=> \"z not found\"", "name": "initialize", "namespace": "Hash", "path": "Hash#initialize", "type": "instance_method", "visibility": "public"}, "Hash#initialize_copy": {"description": ":nodoc:", "name": "initialize_copy", "namespace": "Hash", "path": "Hash#initialize_copy", "type": "instance_method", "visibility": "public"}, "Hash#inspect": {"description": "通过在每个步骤调用+dig+来提取由<i>key-\\n objects序列指定的嵌套值，如果任何中间步骤为+nil+，则返回+nil+。n \n  h = { foo: {bar: {baz: 1}}}\n\n  h.dig(:foo, :bar, :baz)     #=> 1\n  h.dig(:foo, :zot, :xyz)     #=> nil\n\n  g = { foo: [10, 11, 12] }\n  g.dig(:foo, 1)              #=> 11\n  g.dig(:foo, 1, 0)           #=> TypeError: Integer does not have #dig method\n  g.dig(:foo, :bar)           #=> TypeError: no implicit conversion of Symbol into Integer", "name": "to_s", "namespace": "Hash", "path": "Hash#to_s", "type": "instance_method", "visibility": "public"}, "Hash#to_s": {"description": "通过在每个步骤调用+dig+来提取由<i>key-\\n objects序列指定的嵌套值，如果任何中间步骤为+nil+，则返回+nil+。n \n  h = { foo: {bar: {baz: 1}}}\n\n  h.dig(:foo, :bar, :baz)     #=> 1\n  h.dig(:foo, :zot, :xyz)     #=> nil\n\n  g = { foo: [10, 11, 12] }\n  g.dig(:foo, 1)              #=> 11\n  g.dig(:foo, 1, 0)           #=> TypeError: Integer does not have #dig method\n  g.dig(:foo, :bar)           #=> TypeError: no implicit conversion of Symbol into Integer", "name": "to_s", "namespace": "Hash", "path": "Hash#to_s", "type": "instance_method", "visibility": "public"}, "Hash#invert": {"description": "调用<i>block<i>once for each key in<i>hsh，passing the key value pair as parameters.\\n \\n如果没有给定块，则返回枚举器。\\n \n   h = { \"a\" => 100, \"b\" => 200 }\n   h.each {|key, value| puts \"#{key} is #{value}\" }\n \\n<em>产生：.<em>\\n \n   a is 100\n b is 200", "name": "invert", "namespace": "Hash", "path": "Hash#invert", "type": "instance_method", "visibility": "public"}, "Hash#keep_if": {"description": "调用<i>block<i>once for each key in<i>hsh，passing the key as a parameter.\\n \\n如果没有给定块，则返回枚举器。\\n \n   h = { \"a\" => 100, \"b\" => 200 }\n   h.each_key {|key| puts key }\n \\n<em>products:<em>\\n \n   a\n b", "name": "keep_if", "namespace": "Hash", "path": "Hash#keep_if", "type": "instance_method", "visibility": "public"}, "Hash#key": {"description": "调用<i>block<i>once for each key in<i>hsh，passing the key value pair as parameters.\\n \\n如果没有给定块，则返回枚举器。\\n \n   h = { \"a\" => 100, \"b\" => 200 }\n   h.each {|key, value| puts \"#{key} is #{value}\" }\n \\n<em>产生：.<em>\\n \n   a is 100\n b is 200", "name": "key", "namespace": "Hash", "path": "Hash#key", "type": "instance_method", "visibility": "public"}, "Hash#key?": {"description": "返回给定键的哈希值。如果找不到键，有几个选项：如果没有其他参数，它将引发<code>KeyError</code> exception;如果指定了可选代码块，那么它将是returned;，然后它将运行并返回结果。\\n \n   h = { \"a\" => 100, \"b\" => 200 }\n   h.fetch(\"a\")                            #=> 100\n   h.fetch(\"z\", \"go fish\")                 #=> \"go fish\"\n   h.fetch(\"z\") { |el| \"go fish, #{el}\"}   #=> \"go fish, z\"\n \\n下面的示例显示，如果找不到键并且未提供默认值，则会引发异常。\\n \n   h = { \"a\" => 100, \"b\" => 200 }\n   h.fetch(\"z\")\n \\n<em>products:-\\n \n   prog.rb:2:in `fetch': key not found (KeyError)\n from prog.rb:2", "name": "key?", "namespace": "Hash", "path": "Hash#key?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Hash#keys": {"description": "如果不包含键值对，则返回<code>true</code>。\\n n    {}.empty?   #=> true", "name": "keys", "namespace": "Hash", "path": "Hash#keys", "type": "instance_method", "visibility": "public"}, "Hash#length": {"description": "从<i>hsh<i>for which<i>block<i>\\n evaluation to false删除每个键值对。\\n \\n如果没有给定块，则返回枚举器。", "name": "length", "namespace": "Hash", "path": "Hash#length", "type": "instance_method", "visibility": "public"}, "Hash#member?": {"description": "返回给定键的哈希值。如果找不到键，有几个选项：如果没有其他参数，它将引发<code>KeyError</code> exception;如果指定了可选代码块，那么它将是returned;，然后它将运行并返回结果。\\n \n   h = { \"a\" => 100, \"b\" => 200 }\n   h.fetch(\"a\")                            #=> 100\n   h.fetch(\"z\", \"go fish\")                 #=> \"go fish\"\n   h.fetch(\"z\") { |el| \"go fish, #{el}\"}   #=> \"go fish, z\"\n \\n下面的示例显示，如果找不到键并且未提供默认值，则会引发异常。\\n \n   h = { \"a\" => 100, \"b\" => 200 }\n   h.fetch(\"z\")\n \\n<em>products:-\\n \n   prog.rb:2:in `fetch': key not found (KeyError)\n from prog.rb:2", "name": "member?", "namespace": "Hash", "path": "Hash#member?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Hash#merge": {"description": "返回一个数组，该数组包含与给定键关联的值，但在找不到某个键时也会引发<code>KeyError</code>。\\n另请参阅<code>Hash#values_at</code>和<code>Hash#fetch</code>。n \n  h = { \"cat\" => \"feline\", \"dog\" => \"canine\", \"cow\" => \"bovine\" }\n\n  h.fetch_values(\"cow\", \"cat\")                   #=> [\"bovine\", \"feline\"]\n  h.fetch_values(\"cow\", \"bird\")                  # raises KeyError\n  h.fetch_values(\"cow\", \"bird\") { |k| k.upcase } #=> [\"bovine\", \"BIRD\"]", "name": "merge", "namespace": "Hash", "path": "Hash#merge", "type": "instance_method", "visibility": "public"}, "Hash#merge!": {"description": "基于每个键的当前哈希值重新生成哈希。如果关键对象的值在插入后发生了更改，则此方法将重新索引<i>hsh。如果在迭代器遍历哈希时调用<code>Hash#rehash</code>，迭代器中将引发<code>RuntimeError</code>。\\n \n   a = [ \"a\", \"b\" ]\n   c = [ \"c\", \"d\" ]\n   h = { a => 100, c => 300 }\n   h[a]       #=> 100\n   a[0] = \"z\"\n   h[a]       #=> nil\n   h.rehash   #=> {[\"z\", \"b\"]=>100, [\"c\", \"d\"]=>300}\n   h[a]       #=> 100", "name": "merge!", "namespace": "Hash", "path": "Hash#merge!", "type": "instance_method", "visibility": "public"}, "Hash#rassoc": {"description": "如果给定的键存在于<i>hsh中，则返回<code>true</code>。\\n \n   h = { \"a\" => 100, \"b\" => 200 }\n   h.has_key?(\"a\")   #=> true\n   h.has_key?(\"z\")   #=> false\n \\n请注意，<code>include?</code>和<code>member?</code>不会像其他可枚举项一样使用<code>==</code>测试成员相等性。\\n \\n另请参见可枚举包含？", "name": "rassoc", "namespace": "Hash", "path": "Hash#rassoc", "type": "instance_method", "visibility": "public"}, "Hash#rehash": {"description": "如果给定值存在于<i>hsh中的某个键，则返回<code>true</code>。n \n   h = { \"a\" => 100, \"b\" => 200 }\n   h.value?(100)   #=> true\n   h.value?(999)   #=> false", "name": "rehash", "namespace": "Hash", "path": "Hash#rehash", "type": "instance_method", "visibility": "public"}, "Hash#reject": {"description": "计算此哈希的哈希代码。具有相同内容的两个哈希将具有相同的哈希代码（并将使用<code>eql?</code>进行比较）。\\n \\n另请参阅对象哈希。", "name": "reject", "namespace": "Hash", "path": "Hash#reject", "type": "instance_method", "visibility": "public"}, "Hash#reject!": {"description": "如果给定的键存在于<i>hsh中，则返回<code>true</code>。\\n \n   h = { \"a\" => 100, \"b\" => 200 }\n   h.has_key?(\"a\")   #=> true\n   h.has_key?(\"z\")   #=> false\n \\n请注意，<code>include?</code>和<code>member?</code>不像其他可枚举项那样使用<code>==</code>测试成员相等性。\\n \\n另请参见可枚举包含？", "name": "reject!", "namespace": "Hash", "path": "Hash#reject!", "type": "instance_method", "visibility": "public"}, "Hash#replace": {"description": "返回新的空哈希。如果此哈希随后被一个与哈希项不对应的键访问，则返回的值取决于用于创建哈希的<code>new</code>样式。在第一个表单中，访问返回<code>nil</code>。如果指定了\\n<i>obj，则此单个对象将用于所有的<em>默认值。如果指定了块，则将使用哈希对象和键调用它，并应返回默认值。如果需要，块负责将值存储在哈希中。n \n   h = Hash.new(\"Go Fish\")\n   h[\"a\"] = 100\n   h[\"b\"] = 200\n   h[\"a\"]           #=> 100\n   h[\"c\"]           #=> \"Go Fish\"\n   # The following alters the single default object\n   h[\"c\"].upcase!   #=> \"GO FISH\"\n   h[\"d\"]           #=> \"GO FISH\"\n   h.keys           #=> [\"a\", \"b\"]\n\n   # While this creates a new default object each time\n   h = Hash.new { |hash, key| hash[key] = \"Go Fish: #{key}\" }\n   h[\"c\"]           #=> \"Go Fish: c\"\n   h[\"c\"].upcase!   #=> \"GO FISH: C\"\n   h[\"d\"]           #=> \"Go Fish: d\"\n   h.keys           #=> [\"c\", \"d\"]", "name": "replace", "namespace": "Hash", "path": "Hash#replace", "type": "instance_method", "visibility": "public"}, "Hash#select": {"description": "以字符串形式返回此哈希的内容。n \n    h = { \"c\" => 300, \"a\" => 100, \"d\" => 400, \"c\" => 300  }\n    h.to_s   #=> \"{\\\"c\\\"=>300, \\\"a\\\"=>100, \\\"d\\\"=>400}\"", "name": "select", "namespace": "Hash", "path": "Hash#select", "type": "instance_method", "visibility": "public"}, "Hash#select!": {"description": "以字符串形式返回此哈希的内容。n \n    h = { \"c\" => 300, \"a\" => 100, \"d\" => 400, \"c\" => 300  }\n    h.to_s   #=> \"{\\\"c\\\"=>300, \\\"a\\\"=>100, \\\"d\\\"=>400}\"", "name": "select!", "namespace": "Hash", "path": "Hash#select!", "type": "instance_method", "visibility": "public"}, "Hash#shift": {"description": "返回通过使用<i>hsh的值作为键和键作为值创建的新哈希。\\n如果在<i>hsh中已经存在具有相同值的键，则\\n将使用定义的最后一个键，将丢弃先前的值。\\n \n   h = { \"n\" => 100, \"m\" => 100, \"y\" => 300, \"d\" => 200, \"a\" => 0 }\n   h.invert   #=> {0=>\"a\", 100=>\"m\", 200=>\"d\", 300=>\"y\"}\n \\n如果没有具有相同值的键，则hash invert是对合的。\\n \n  h = { a: 1, b: 3, c: 4 }\n  h.invert.invert == h #=> true\n \\n通过比较反向哈希的大小，可以测试没有具有相同值的键的条件。n \n  # no key with the same value\n  h = { a: 1, b: 3, c: 4 }\n  h.size == h.invert.size #=> true\n\n  # two (or more) keys has the same value\n  h = { a: 1, b: 3, c: 1 }\n  h.size == h.invert.size #=> false", "name": "shift", "namespace": "Hash", "path": "Hash#shift", "type": "instance_method", "visibility": "public"}, "Hash#size": {"description": "从<i>hsh<i>for which<i>block<i>\\n evaluation to false删除每个键值对。\\n \\n如果没有给定块，则返回枚举器。", "name": "size", "namespace": "Hash", "path": "Hash#size", "type": "instance_method", "visibility": "public"}, "Hash#slice": {"description": "返回给定值出现的键。如果找不到该值，则返回<code>nil</code>。n \n   h = { \"a\" => 100, \"b\" => 200, \"c\" => 300, \"d\" => 300 }\n   h.key(200)   #=> \"b\"\n   h.key(300)   #=> \"c\"\n   h.key(999)   #=> nil", "name": "slice", "namespace": "Hash", "path": "Hash#slice", "type": "instance_method", "visibility": "public"}, "Hash#store": {"description": "", "name": "store", "namespace": "Hash", "path": "Hash#store", "type": "instance_method", "visibility": "public"}, "Hash#to_a": {"description": "如果给定的键存在于<i>hsh中，则返回<code>true</code>。\\n \n   h = { \"a\" => 100, \"b\" => 200 }\n   h.has_key?(\"a\")   #=> true\n   h.has_key?(\"z\")   #=> false\n \\n请注意，<code>include?</code>和<code>member?</code>不像其他可枚举项那样使用<code>==</code>测试成员相等性。\\n \\n另请参见可枚举包含？", "name": "to_a", "namespace": "Hash", "path": "Hash#to_a", "type": "instance_method", "visibility": "public"}, "Hash#to_h": {"description": "返回用此哈希中的键填充的新数组。另见<code>Hash#values</code>。n \n   h = { \"a\" => 100, \"b\" => 200, \"c\" => 300, \"d\" => 400 }\n   h.keys   #=> [\"a\", \"b\", \"c\", \"d\"]", "name": "to_h", "namespace": "Hash", "path": "Hash#to_h", "type": "instance_method", "visibility": "public"}, "Hash#to_hash": {"description": "返回哈希中的键值对数。n \n   h = { \"d\" => 100, \"a\" => 200, \"v\" => 300, \"e\" => 400 }\n   h.length        #=> 4\n   h.delete(\"a\")   #=> 200\n   h.length        #=> 3", "name": "to_hash", "namespace": "Hash", "path": "Hash#to_hash", "type": "instance_method", "visibility": "public"}, "Hash#to_proc": {"description": "", "name": "to_proc", "namespace": "Hash", "path": "Hash#to_proc", "type": "instance_method", "visibility": "public"}, "Hash#transform_keys": {"description": "如果给定的键存在于<i>hsh中，则返回<code>true</code>。\\n \n   h = { \"a\" => 100, \"b\" => 200 }\n   h.has_key?(\"a\")   #=> true\n   h.has_key?(\"z\")   #=> false\n \\n请注意，<code>include?</code>和<code>member?</code>不会像其他可枚举项一样使用<code>==</code>测试成员相等性。\\n \\n另请参见可枚举包含？", "name": "transform_keys", "namespace": "Hash", "path": "Hash#transform_keys", "type": "instance_method", "visibility": "public"}, "Hash#transform_keys!": {"description": "返回一个新哈希，其中包含<i>其他哈希的内容和<i>hsh的内容。如果未指定块，则具有重复键的条目的值将为<i>Other_hash的值。否则，通过用键调用块来确定每个重复键的值，其值在<i>hsh中，其值在<i>other_hash中。\\n \n   h1 = { \"a\" => 100, \"b\" => 200 }\n   h2 = { \"b\" => 254, \"c\" => 300 }\n   h1.merge(h2)   #=> {\"a\"=>100, \"b\"=>254, \"c\"=>300}\n   h1.merge(h2){|key, oldval, newval| newval - oldval}\n                  #=> {\"a\"=>100, \"b\"=>54,  \"c\"=>300}\n   h1             #=> {\"a\"=>100, \"b\"=>200}", "name": "transform_keys!", "namespace": "Hash", "path": "Hash#transform_keys!", "type": "instance_method", "visibility": "public"}, "Hash#transform_values": {"description": "将其他哈希的内容添加到。如果没有指定块，则具有重复键的项将被_other_hash_uu中的值覆盖，否则每个重复键的值将通过使用键调用块、其hsh_u中的值以及其在\\n_other_hash中的值来确定。\\n \n   h1 = { \"a\" => 100, \"b\" => 200 }\n   h2 = { \"b\" => 254, \"c\" => 300 }\n   h1.merge!(h2)   #=> {\"a\"=>100, \"b\"=>254, \"c\"=>300}\n   h1              #=> {\"a\"=>100, \"b\"=>254, \"c\"=>300}\n\n   h1 = { \"a\" => 100, \"b\" => 200 }\n   h2 = { \"b\" => 254, \"c\" => 300 }\n   h1.merge!(h2) { |key, v1, v2| v1 }\n                   #=> {\"a\"=>100, \"b\"=>200, \"c\"=>300}\n   h1              #=> {\"a\"=>100, \"b\"=>200, \"c\"=>300}", "name": "transform_values", "namespace": "Hash", "path": "Hash#transform_values", "type": "instance_method", "visibility": "public"}, "Hash#transform_values!": {"description": "使用<code>==</code>搜索比较obj和值的哈希。\\n返回匹配的第一个键值对（两个元素数组）。另见<code>Array#rassoc</code>。\\n \n   a = {1=> \"one\", 2 => \"two\", 3 => \"three\", \"ii\" => \"two\"}\n   a.rassoc(\"two\")    #=> [2, \"two\"]\n   a.rassoc(\"four\")   #=> nil", "name": "transform_values!", "namespace": "Hash", "path": "Hash#transform_values!", "type": "instance_method", "visibility": "public"}, "Hash#update": {"description": "基于每个键的当前哈希值重新生成哈希。如果关键对象的值在插入后发生了更改，则此方法将重新索引<i>hsh。如果在迭代器遍历哈希时调用<code>Hash#rehash</code>，迭代器中将引发<code>RuntimeError</code>。\\n \n   a = [ \"a\", \"b\" ]\n   c = [ \"c\", \"d\" ]\n   h = { a => 100, c => 300 }\n   h[a]       #=> 100\n   a[0] = \"z\"\n   h[a]       #=> nil\n   h.rehash   #=> {[\"z\", \"b\"]=>100, [\"c\", \"d\"]=>300}\n   h[a]       #=> 100", "name": "update", "namespace": "Hash", "path": "Hash#update", "type": "instance_method", "visibility": "public"}, "Hash#value?": {"description": "返回一个新哈希，该哈希由块返回false的条目组成。\\n \\n如果没有给定块，则返回枚举器。\\n \n   h = { \"a\" => 100, \"b\" => 200, \"c\" => 300 }\n   h.reject {|k,v| k < \"b\"}  #=> {\"b\" => 200, \"c\" => 300}\n   h.reject {|k,v| v > 100}  #=> {\"a\" => 100}", "name": "value?", "namespace": "Hash", "path": "Hash#value?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Hash#values": {"description": "相当于<code>Hash#delete_if</code>，但如果未做任何更改，则返回<code>nil</code>。", "name": "values", "namespace": "Hash", "path": "Hash#values", "type": "instance_method", "visibility": "public"}, "Hash#values_at": {"description": "将<i>hsh的内容替换为\\n<i>Other_hash的内容。\\n \n   h = { \"a\" => 100, \"b\" => 200 }\n   h.replace({ \"c\" => 300, \"d\" => 400 })   #=> {\"c\"=>300, \"d\"=>400}号", "name": "values_at", "namespace": "Hash", "path": "Hash#values_at", "type": "instance_method", "visibility": "public"}, "Hash.[]": {"description": "返回一个新哈希，该哈希由块返回为真的项组成。\\n \\n如果没有给定块，则返回枚举器。\\n \n   h = { \"a\" => 100, \"b\" => 200, \"c\" => 300 }\n   h.select {|k,v| k > \"a\"}  #=> {\"b\" => 200, \"c\" => 300}\n   h.select {|k,v| v < 200}  #=> {\"a\" => 100}", "name": "[]", "namespace": "Hash", "path": "Hash.[]", "type": "class_method", "visibility": "public"}, "Hash.try_convert": {"description": "相当于<code>Hash#keep_if</code>，但如果未做任何更改，则返回<code>nil</code>。", "name": "try_convert", "namespace": "Hash", "path": "Hash.try_convert", "type": "class_method", "visibility": "public"}, "IOError": {"description": "从<i>hsh<i>中删除一个键值对，并将其作为两项数组<code>[</code><i>key，value<i><code>]</code>返回，或者如果哈希为空则返回哈希的默认值。\\n \n   h = { 1 => \"a\", 2 => \"b\", 3 => \"c\" }\n   h.shift   #=> [1, \"a\"]\n   h         #=> {2=>\"b\", 3=>\"c\"}", "name": "IOError", "namespace": "", "path": "IOError", "type": "class", "visibility": "public"}, "EOFError": {"description": "返回哈希中的键值对数。\\n \n   h = { \"d\" => 100, \"a\" => 200, \"v\" => 300, \"e\" => 400 }\n   h.length        #=> 4\n   h.delete(\"a\")   #=> 200\n   h.length        #=> 3", "name": "EOFError", "namespace": "", "path": "EOFError", "type": "class", "visibility": "public"}, "ARGF": {"description": "返回仅包含给定键及其值的哈希。\\n \n   h = { a: 100, b: 200, c: 300 }\n   h.slice(:a)           #=> {:a=>100}\n   h.slice(:b, :c, :d)   #=> {:b=>200, :c=>300}", "name": "ARGF", "namespace": "", "path": "ARGF", "type": "class", "visibility": "public"}, "ARGF#argv": {"description": "将<i>hsh->i>转换为嵌套数组<code>[</code><i>key、\\n value-><code>]</code> array。\\n \n   h = { \"c\" => 300, \"a\" => 100, \"d\" => 400, \"c\" => 300  }\n   h.to_a   #=> [[\"c\", 300], [\"a\", 100], [\"d\", 400]]", "name": "argv", "namespace": "ARGF", "path": "ARGF#argv", "type": "instance_method", "visibility": "public"}, "ARGF#binmode": {"description": "返回+self+。如果在哈希子类上调用，则将接收器转换为哈希对象。", "name": "binmode", "namespace": "ARGF", "path": "ARGF#binmode", "type": "instance_method", "visibility": "public"}, "ARGF#binmode?": {"description": "返回+self+。", "name": "binmode?", "namespace": "ARGF", "path": "ARGF#binmode?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "ARGF#bytes": {"description": "返回一个新哈希，并为每个键运行一次块的结果。\\n此方法不会更改值。\\n \n   h = { a: 1, b: 2, c: 3 }\n   h.transform_keys {|k| k.to_s }  #=> { \"a\" => 1, \"b\" => 2, \"c\" => 3 }\n   h.transform_keys(&:to_s)        #=> { \"a\" => 1, \"b\" => 2, \"c\" => 3 }\n   h.transform_keys.with_index {|k, i| \"#{k}.#{i}\" }\n                                   #=> { \"a.0\" => 1, \"b.1\" => 2, \"c.2\" => 3 }\n \\n如果没有给定块，则返回枚举器。", "name": "bytes", "namespace": "ARGF", "path": "ARGF#bytes", "type": "instance_method", "visibility": "public"}, "ARGF#chars": {"description": "为<i>hsh中的每个键调用一次给定的块，将其替换为块返回的新键，然后返回<i>hsh。\\n此方法不会更改值。\\n \n   h = { a: 1, b: 2, c: 3 }\n   h.transform_keys! {|k| k.to_s }  #=> { \"a\" => 1, \"b\" => 2, \"c\" => 3 }\n   h.transform_keys!(&:to_sym)      #=> { a: 1, b: 2, c: 3 }\n   h.transform_keys!.with_index {|k, i| \"#{k}.#{i}\" }\n                                    #=> { \"a.0\" => 1, \"b.1\" => 2, \"c.2\" => 3 }\n \\n如果没有给定块，则返回枚举器。", "name": "chars", "namespace": "ARGF", "path": "ARGF#chars", "type": "instance_method", "visibility": "public"}, "ARGF#close": {"description": "返回一个新的哈希，并为每个值运行一次块的结果。\\n此方法不会更改密钥。\\n \n   h = { a: 1, b: 2, c: 3 }\n   h.transform_values {|v| v * v + 1 }  #=> { a: 2, b: 5, c: 10 }\n   h.transform_values(&:to_s)           #=> { a: \"1\", b: \"2\", c: \"3\" }\n   h.transform_values.with_index {|v, i| \"#{v}.#{i}\" }\n                                        #=> { a: \"1.0\", b: \"2.1\", c: \"3.2\" }\n \\n如果没有给定块，则返回枚举器。", "name": "close", "namespace": "ARGF", "path": "ARGF#close", "type": "instance_method", "visibility": "public"}, "ARGF#closed?": {"description": "为<i>hsh<i>中的每个值调用一次给定的块，将其替换为块返回的新值，然后返回<i>hsh<i>。\\n此方法不会更改密钥。\\n \n   h = { a: 1, b: 2, c: 3 }\n   h.transform_values! {|v| v * v + 1 }  #=> { a: 2, b: 5, c: 10 }\n   h.transform_values!(&:to_s)           #=> { a: \"2\", b: \"5\", c: \"10\" }\n   h.transform_values!.with_index {|v, i| \"#{v}.#{i}\" }\n                                         #=> { a: \"2.0\", b: \"5.1\", c: \"10.2\" }\n \\n如果没有给定块，则返回枚举器。", "name": "closed?", "namespace": "ARGF", "path": "ARGF#closed?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "ARGF#codepoints": {"description": "将其他哈希的内容添加到。如果没有指定块，则具有重复键的项将被_other_hash_uu中的值覆盖，否则每个重复键的值将通过使用键调用块、其hsh_u中的值以及其在\\n_other_hash中的值来确定。\\n \n   h1 = { \"a\" => 100, \"b\" => 200 }\n   h2 = { \"b\" => 254, \"c\" => 300 }\n   h1.merge!(h2)   #=> {\"a\"=>100, \"b\"=>254, \"c\"=>300}\n   h1              #=> {\"a\"=>100, \"b\"=>254, \"c\"=>300}\n\n   h1 = { \"a\" => 100, \"b\" => 200 }\n   h2 = { \"b\" => 254, \"c\" => 300 }\n   h1.merge!(h2) { |key, v1, v2| v1 }\n                   #=> {\"a\"=>100, \"b\"=>200, \"c\"=>300}\n   h1              #=> {\"a\"=>100, \"b\"=>200, \"c\"=>300}", "name": "codepoints", "namespace": "ARGF", "path": "ARGF#codepoints", "type": "instance_method", "visibility": "public"}, "ARGF#each": {"description": "尝试使用to_hash方法将<i>obj<i>转换为哈希。\\n如果由于任何原因而无法转换，则返回已转换的哈希或nil。\\n \n   Hash.try_convert({1=>2})   # => {1=>2}\n   Hash.try_convert(\"1=>2\")   # => nil", "name": "each", "namespace": "ARGF", "path": "ARGF#each", "type": "instance_method", "visibility": "public"}, "ARGF#each_byte": {"description": "返回一个新数组，该数组填充了来自<i>hsh的值。另见<code>Hash#keys</code>。\\n \n   h = { \"a\" => 100, \"b\" => 200, \"c\" => 300 }\n   h.values   #=> [100, 200, 300]", "name": "each_byte", "namespace": "ARGF", "path": "ARGF#each_byte", "type": "instance_method", "visibility": "public"}, "ARGF#each_char": {"description": "返回包含与给定键关联的值的数组。\\n另请参阅<code>Hash.select</code>。\\n \n  h = { \"cat\" => \"feline\", \"dog\" => \"canine\", \"cow\" => \"bovine\" }\n  h.values_at(\"cow\", \"cat\")  #=> [\"bovine\", \"feline\"]", "name": "each_char", "namespace": "ARGF", "path": "ARGF#each_char", "type": "instance_method", "visibility": "public"}, "ARGF#each_codepoint": {"description": "创建用给定对象填充的新哈希。\\n \\n类似于文字<code>{ _key_ => _value_, ... }</code>。在第一种形式中，键和值成对出现，因此必须有偶数个参数。\\n \\n第二个和第三个窗体采用单个参数，该参数可以是键值对数组，也可以是可转换为哈希的对象。\\n \n   Hash[\"a\", 100, \"b\", 200]             #=> {\"a\"=>100, \"b\"=>200}\n   Hash[ [ [\"a\", 100], [\"b\", 200] ] ]   #=> {\"a\"=>100, \"b\"=>200}\n   Hash[\"a\" => 100, \"b\" => 200]         #=> {\"a\"=>100, \"b\"=>200}", "name": "each_codepoint", "namespace": "ARGF", "path": "ARGF#each_codepoint", "type": "instance_method", "visibility": "public"}, "ARGF#each_line": {"description": "尝试使用to_hash方法将<i>obj<i>转换为哈希。\\n如果由于任何原因而无法转换，则返回已转换的哈希或nil。\\n \n   Hash.try_convert({1=>2})   # => {1=>2}\n   Hash.try_convert(\"1=>2\")   # => nil", "name": "each_line", "namespace": "ARGF", "path": "ARGF#each_line", "type": "instance_method", "visibility": "public"}, "ARGF#eof": {"description": "到达文件结尾时由某些IO操作引发。许多IO方法有两种形式，一种是在到达文件结尾时返回+nil+，另一种是引发+EOFError+。\\n \\n +EOFError+是+IOError+的子类。\\n \n   file = File.open(\"/etc/hosts\")\n   file.read\n   file.gets     #=> nil\n   file.readline #=> EOFError: end of file reached", "name": "eof", "namespace": "ARGF", "path": "ARGF#eof", "type": "instance_method", "visibility": "public"}, "ARGF#eof?": {"description": "到达文件结尾时由某些IO操作引发。许多IO方法有两种形式，一种是在到达文件结尾时返回+nil+，另一种是引发+EOFError+。\\n \\n +EOFError+是+IOError+的子类。\\n \n   file = File.open(\"/etc/hosts\")\n   file.read\n   file.gets     #=> nil\n   file.readline #=> EOFError: end of file reached", "name": "eof?", "namespace": "ARGF", "path": "ARGF#eof?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "ARGF#external_encoding": {"description": "+ARGF+是一个流，设计用于处理作为命令行参数提供的文件或通过STDIN传入的文件的脚本。\\n \\n传递给脚本的参数存储在+ARGV+数组中，每个元素一个参数。+ARGF+假定所有不是文件名的参数都已从+ARGV+中删除。例如：\\n \n    $ ruby argf.rb --verbose file1 file2\n\n    ARGV  #=> [\"--verbose\", \"file1\", \"file2\"]\n    option = ARGV.shift #=> \"--verbose\"\n    ARGV  #=> [\"file1\", \"file2\"]\n \\n现在可以使用+ARGF+来处理这些命名文件的串联。例如，+ARGF.read+将返回文件1的内容，然后返回文件2的内容。\\n \\n读取+ARGV+中的文件后，+ARGF+会将其从数组中移除。\\n因此，在读取所有文件之后，+ARGV+将为空。\\n \\n您可以自己操作+ARGV+来控制+ARGF+的操作。如果从+ARGV+中删除一个文件，它将被+ARGF+忽略；如果将文件添加到+ARGV+，它们将被视为在命令行上命名。例如：\\n \n    ARGV.replace [\"file1\"]\n    ARGF.readlines # Returns the contents of file1 as an Array\n    ARGV           #=> []\n    ARGV.replace [\"file2\", \"file3\"]\n    ARGF.read      # Returns the contents of file2 and file3\n \\n如果+ARGV+为空，则+ARGF+的作用类似于它包含STDIN，即数据通过管道传输到脚本。例如：\\n \n    $ echo \"glark\" | ruby -e 'p ARGF.read'\n“glark \\n”", "name": "external_encoding", "namespace": "ARGF", "path": "ARGF#external_encoding", "type": "instance_method", "visibility": "public"}, "ARGF#file": {"description": "返回+ARGV+数组，该数组包含传递给脚本的参数，每个元素一个。\\n \\n例如：\\n \n    $ ruby argf.rb -v glark.txt\n \\n     ARGF.argv   #=> [\"-v\", \"glark.txt\"]", "name": "file", "namespace": "ARGF", "path": "ARGF#file", "type": "instance_method", "visibility": "public"}, "ARGF#filename": {"description": "如果+ARGF+中的当前文件位于文件末尾，即没有要读取的数据，则返回true。必须打开流进行读取，否则将引发+IOError+。n \n   $ echo \"eof\" | ruby argf.rb\n\n   ARGF.eof?                 #=> false\n   3.times { ARGF.readchar }\n   ARGF.eof?                 #=> false\n   ARGF.readchar             #=> \"\\n\"\n   ARGF.eof?                 #=> true", "name": "filename", "namespace": "ARGF", "path": "ARGF#filename", "type": "instance_method", "visibility": "public"}, "ARGF#fileno": {"description": "格式化并写入IOS，在格式字符串的控制下转换参数。有关详细信息，请参阅<code>Kernel#sprintf</code>\\n。", "name": "fileno", "namespace": "ARGF", "path": "ARGF#fileno", "type": "instance_method", "visibility": "public"}, "ARGF#getbyte": {"description": "这是<code>each_byte</code>的不推荐使用的别名。", "name": "getbyte", "namespace": "ARGF", "path": "ARGF#getbyte", "type": "instance_method", "visibility": "public"}, "ARGF#getc": {"description": "这是<code>each_char</code>的不推荐使用的别名。", "name": "getc", "namespace": "ARGF", "path": "ARGF#getc", "type": "instance_method", "visibility": "public"}, "ARGF#gets": {"description": "关闭当前文件并跳到ARGV中的下一个文件。如果没有其他文件要打开，只需关闭当前文件。+STDIN+不会关闭。\\n \\n例如：\\n \n   $ ruby argf.rb foo bar\n\n   ARGF.filename  #=> \"foo\"\n   ARGF.close\n   ARGF.filename  #=> \"bar\"\n ARGF.Close", "name": "gets", "namespace": "ARGF", "path": "ARGF#gets", "type": "instance_method", "visibility": "public"}, "ARGF#initialize": {"description": ":nodoc:", "name": "initialize", "namespace": "ARGF", "path": "ARGF#initialize", "type": "instance_method", "visibility": "public"}, "ARGF#initialize_copy": {"description": ":nodoc:", "name": "initialize_copy", "namespace": "ARGF", "path": "ARGF#initialize_copy", "type": "instance_method", "visibility": "public"}, "ARGF#inplace_mode": {"description": "如果当前文件为closed;，则返回true，否则返回false。使用\\n+ARGF.close+实际关闭当前文件。", "name": "inplace_mode", "namespace": "ARGF", "path": "ARGF#inplace_mode", "type": "instance_method", "visibility": "public"}, "ARGF#inplace_mode=": {"description": "这是<code>each_codepoint</code>的不推荐使用的别名。", "name": "inplace_mode=", "namespace": "ARGF", "path": "ARGF#inplace_mode=", "type": "instance_method", "visibility": "public"}, "ARGF#inspect": {"description": "将给定对象写入<em>ios。\\n在任何尚未以换行序列结尾的字符后写入换行符。返回+nil+。\\n \\n必须打开流进行写入。\\n如果使用数组参数调用，则在新行中写入每个元素。\\n将通过调用其+to_s+方法来转换不是字符串或数组的每个给定对象。\\n如果不带参数调用，则输出单个换行符。\\n \n   $stdout.puts(\"this\", \"is\", [\"a\", \"test\"])\n \\n<em>产生：.<em>\\n \n   this\n   is\n   a\n   test\n \\n注意+puts+总是使用换行符，并且不受输出记录分隔符（<code>$\\\\</code>）的影响。", "name": "inspect", "namespace": "ARGF", "path": "ARGF#inspect", "type": "instance_method", "visibility": "public"}, "ARGF#internal_encoding": {"description": "argf.每个字节块->ARGF\n   ARGF.each_byte                  -> an_enumerator\n\\n在+ARGV+中对每个文件的每个字节进行迭代。\\n字节作为+Integer+返回，返回范围为0..255。\\n \\n此方法允许您将命令行上提供的文件视为单个文件，由每个命名文件的串联组成。返回第一个文件的最后一个字节后，返回第二个文件的第一个字节。+ARGF.filename+方法可用于确定当前字节的文件名。\\n \\n如果没有给定块，则返回枚举器。\\n \\n例如：\\n \\n    ARGF.bytes.to_a  #=> [35, 32, ... 95, 10]", "name": "internal_encoding", "namespace": "ARGF", "path": "ARGF#internal_encoding", "type": "instance_method", "visibility": "public"}, "ARGF#lineno": {"description": "循环访问+ARGF+中每个文件的每个字符。\\n \\n此方法允许您将命令行上提供的文件视为单个文件，由每个命名文件的串联组成。返回第一个文件的最后一个字符后，返回第二个文件的第一个字符。+ARGF.file name+方法可用于确定当前字符出现的文件名。\\n \\n如果没有给定块，则返回枚举器。", "name": "lineno", "namespace": "ARGF", "path": "ARGF#lineno", "type": "instance_method", "visibility": "public"}, "ARGF#lineno=": {"description": "循环访问+ARGF+中每个文件的每个代码点。\\n \\n此方法允许您将命令行上提供的文件视为单个文件，由每个命名文件的串联组成。在返回第一个文件的最后一个代码点之后，将返回第二个文件的第一个代码点。+ARGF.file name+方法可用于确定当前代码点出现的文件的名称。\\n \\n如果没有给定块，则返回枚举器。", "name": "lineno=", "namespace": "ARGF", "path": "ARGF#lineno=", "type": "instance_method", "visibility": "public"}, "ARGF#lines": {"description": "argf.each_line（sep=$/）line block->ARGF\n   ARGF.each_line(sep=$/, limit) {|line| block }  -> ARGF\n   ARGF.each_line(...)                            -> an_enumerator\n \\n返回一个枚举器，该枚举器在+ARGV+中的每个文件的每一行上迭代（由默认为平台换行符的_sep_uu分隔）。如果提供了一个块，那么每一行都将依次生成该块，否则将返回一个枚举器。\\n可选的limit参数是+Integer+，指定每个line;长行的最大长度将根据此限制拆分。\\n \\n此方法允许您将命令行上提供的文件视为单个文件，由每个命名文件的串联组成。返回第一个文件的最后一行后，返回第二个文件的第一行。可以使用+ARGF.filename+和+ARGF.lineno+方法分别确定当前行的文件名和行号。\\n \\n例如，下面的代码打印出每个命名文件的每一行，并以其行号作为前缀，每个文件显示一次文件名：\\n \n   ARGF.each_line do |line|\n     puts ARGF.filename if ARGF.lineno == 1\n     puts \"#{ARGF.lineno}: #{line}\"\n end", "name": "lines", "namespace": "ARGF", "path": "ARGF#lines", "type": "instance_method", "visibility": "public"}, "ARGF#path": {"description": "如果+ARGF+中的当前文件位于文件末尾，即没有要读取的数据，则返回true。必须打开流进行读取，否则将引发+IOError+。n \n   $ echo \"eof\" | ruby argf.rb\n\n   ARGF.eof?                 #=> false\n   3.times { ARGF.readchar }\n   ARGF.eof?                 #=> false\n   ARGF.readchar             #=> \"\\n\"\n   ARGF.eof?                 #=> true", "name": "path", "namespace": "ARGF", "path": "ARGF#path", "type": "instance_method", "visibility": "public"}, "ARGF#pos": {"description": "查找+ARGF+中位置（字节）给出的位置。\\n \\n例如：\\n \n    ARGF.pos = 17\n    ARGF.gets   #=> \"This is line two\\n\"", "name": "pos", "namespace": "ARGF", "path": "ARGF#pos", "type": "instance_method", "visibility": "public"}, "ARGF#pos=": {"description": "以+Encoding+对象的形式返回从+ARGF+读取的文件的外部编码。外部编码是存储在文件中的文本编码。与+ARGF.Internal_Encoding+形成对比，后者是用于在Ruby中表示此文本的编码。\\n \\n若要设置外部编码，请使用+ARGF。设置\\u encoding+。\\n \\n例如：\\n \\n    ARGF.external_encoding  #=>  #<Encoding:UTF-8>", "name": "pos=", "namespace": "ARGF", "path": "ARGF#pos=", "type": "instance_method", "visibility": "public"}, "ARGF#print": {"description": "以+IO+或+File+对象的形式返回当前文件。\\n当当前文件为STDIN时，返回<code>$stdin</code>。\\n \\n例如：\\n \n   $ echo \"foo\" > foo\n   $ echo \"bar\" > bar\n\n   $ ruby argf.rb foo bar\n\n   ARGF.file      #=> #<File:foo>\n   ARGF.read(5)   #=> \"foo\\nb\"\n   ARGF.file      #=> #<File:bar>", "name": "print", "namespace": "ARGF", "path": "ARGF#print", "type": "instance_method", "visibility": "public"}, "ARGF#printf": {"description": "返回当前文件名。“当当前文件为STDIN时返回。\\n \\n例如：\\n \n   $ echo \"foo\" > foo\n   $ echo \"bar\" > bar\n   $ echo \"glark\" > glark\n\n   $ ruby argf.rb foo bar glark\n\n   ARGF.filename  #=> \"foo\"\n   ARGF.read(5)   #=> \"foo\\nb\"\n   ARGF.filename  #=> \"bar\"\n   ARGF.skip\n   ARGF.filename  #=> \"glark\"", "name": "printf", "namespace": "ARGF", "path": "ARGF#printf", "type": "instance_method", "visibility": "public"}, "ARGF#putc": {"description": "返回表示当前文件的数字文件描述符的整数。如果没有当前文件，则引发+ArgumentError+。\\n n    ARGF.fileno    #=> 3", "name": "putc", "namespace": "ARGF", "path": "ARGF#putc", "type": "instance_method", "visibility": "public"}, "ARGF#puts": {"description": "从+ARGF+获取下一个8位字节（0..255）。如果在流结尾调用，则返回+nil+。\\n \\n例如：\\n \n   $ echo \"foo\" > file\n   $ ruby argf.rb file\n\n   ARGF.getbyte #=> 102\n   ARGF.getbyte #=> 111\n   ARGF.getbyte #=> 111\n   ARGF.getbyte #=> 10\n   ARGF.getbyte #=> nil", "name": "puts", "namespace": "ARGF", "path": "ARGF#puts", "type": "instance_method", "visibility": "public"}, "ARGF#read": {"description": "从+ARGF+中读取下一个字符，并将其作为+String+返回。返回流结尾处的+nil+。\\n \\n +ARGF+将命令行上命名的文件视为通过连接其内容创建的单个文件。返回第一个文件的最后一个字符后，返回第二个文件的第一个字符，依此类推。\\n \\n例如：\\n \n   $ echo \"foo\" > file\n   $ ruby argf.rb file\n\n   ARGF.getc  #=> \"f\"\n   ARGF.getc  #=> \"o\"\n   ARGF.getc  #=> \"o\"\n   ARGF.getc  #=> \"\\n\"\n   ARGF.getc  #=> nil\n   ARGF.getc  #=> nil", "name": "read", "namespace": "ARGF", "path": "ARGF#read", "type": "instance_method", "visibility": "public"}, "ARGF#read_nonblock": {"description": "返回+ARGF+中当前文件的下一行。\\n \\n默认情况下，假定行之间以<code>$/</code>分隔；\\n若要使用其他字符作为分隔符，请将其作为+String+提供给sep参数。\\n \\n可选的limit参数指定每行返回多少个字符。默认情况下，返回所有字符。\\n \\n有关getline_args的详细信息，请参阅IO.readlines。", "name": "read_nonblock", "namespace": "ARGF", "path": "ARGF#read_nonblock", "type": "instance_method", "visibility": "public"}, "ARGF#readbyte": {"description": "返回在就地编辑模式下附加到已修改文件名的文件扩展名。可以使用+ARGF设置该值。inplace_mode=+或将+-i+开关传递给ruby二进制文件。", "name": "readbyte", "namespace": "ARGF", "path": "ARGF#readbyte", "type": "instance_method", "visibility": "public"}, "ARGF#readchar": {"description": "将就地编辑模式的文件扩展名设置为给定的字符串。\\n正在编辑的每个文件的文件名都附加了此值。修改后的文件以这个新名称保存。\\n \\n例如：\\n \n    $ ruby argf.rb file.txt\n\n    ARGF.inplace_mode = '.bak'\n    ARGF.each_line do |line|\n      print line.sub(\"foo\",\"bar\")\n    end\n \\n _file.txt_的每一行都将第一个出现的“foo”替换为\\n“bar”，然后将新行写入_file.txt.bak_u。", "name": "readchar", "namespace": "ARGF", "path": "ARGF#readchar", "type": "instance_method", "visibility": "public"}, "ARGF#readline": {"description": "返回“ARGF”。", "name": "readline", "namespace": "ARGF", "path": "ARGF#readline", "type": "instance_method", "visibility": "public"}, "ARGF#readlines": {"description": "将给定对象写入<em>ios。返回+nil+。\\n \\n必须打开流进行写入。\\n每个非字符串的给定对象都将通过调用其<code>to_s</code>方法进行转换。\\n在没有参数的情况下调用时，打印<code>$_</code>的内容。\\n \\n如果输出字段分隔符（<code>$,</code>）不是+nil+，则在对象之间插入该分隔符。\\n如果输出记录分隔符（<code>$\\\\</code>）不是+nil+，则会将其追加到输出中。\\n \n   $stdout.print(\"This is \", 100, \" percent.\\n\")\n \\n<em>products:-<em>\\n \\n this is 100 percent.", "name": "readlines", "namespace": "ARGF", "path": "ARGF#readlines", "type": "instance_method", "visibility": "public"}, "ARGF#readpartial": {"description": "整体返回当前行号ARGF。此值可以用+ARGF手动设置。lineno=+。\\n \\n例如：\\n \n    ARGF.lineno   #=> 0\n    ARGF.readline #=> \"This is line 1\\n\"\n    ARGF.lineno   #=> 1", "name": "readpartial", "namespace": "ARGF", "path": "ARGF#readpartial", "type": "instance_method", "visibility": "public"}, "ARGF#rewind": {"description": "将行号+ARGF+作为一个整体设置为给定的+Integer+。\\n \\n +ARGF+在读取数据时自动设置行号，因此通常不需要显式设置。要访问当前行号，请使用+ARGF。lineno+。\\n \\n例如：\\n \n    ARGF.lineno      #=> 0\n    ARGF.readline    #=> \"This is line 1\\n\"\n    ARGF.lineno      #=> 1\n    ARGF.lineno = 0  #=> 0\n    ARGF.lineno      #=> 0", "name": "rewind", "namespace": "ARGF", "path": "ARGF#rewind", "type": "instance_method", "visibility": "public"}, "ARGF#seek": {"description": "这是<code>each_line</code>的不推荐使用的别名。", "name": "seek", "namespace": "ARGF", "path": "ARGF#seek", "type": "instance_method", "visibility": "public"}, "ARGF#set_encoding": {"description": "返回当前文件名。“当当前文件为STDIN时返回。\\n \\n例如：\\n \n   $ echo \"foo\" > foo\n   $ echo \"bar\" > bar\n   $ echo \"glark\" > glark\n\n   $ ruby argf.rb foo bar glark\n\n   ARGF.filename  #=> \"foo\"\n   ARGF.read(5)   #=> \"foo\\nb\"\n   ARGF.filename  #=> \"bar\"\n   ARGF.skip\n   ARGF.filename  #=> \"glark\"", "name": "set_encoding", "namespace": "ARGF", "path": "ARGF#set_encoding", "type": "instance_method", "visibility": "public"}, "ARGF#skip": {"description": "返回+ARGF+中当前文件的当前偏移量（字节）。n \n   ARGF.pos    #=> 0\n   ARGF.gets   #=> \"This is line one\\n\"\n   ARGF.pos    #=> 17", "name": "skip", "namespace": "ARGF", "path": "ARGF#skip", "type": "instance_method", "visibility": "public"}, "ARGF#tell": {"description": "查找+ARGF+中位置（字节）给出的位置。\\n \\n例如：\\n \n    ARGF.pos = 17\n    ARGF.gets   #=> \"This is line two\\n\"", "name": "tell", "namespace": "ARGF", "path": "ARGF#tell", "type": "instance_method", "visibility": "public"}, "ARGF#to_a": {"description": "将给定对象写入<em>ios。返回+nil+。\\n \\n必须打开流进行写入。\\n每个非字符串的给定对象都将通过调用其<code>to_s</code>方法进行转换。\\n在没有参数的情况下调用时，打印<code>$_</code>的内容。\\n \\n如果输出字段分隔符（<code>$,</code>）不是+nil+，则在对象之间插入该分隔符。\\n如果输出记录分隔符（<code>$\\\\</code>）不是+nil+，则会将其追加到输出中。\\n \n   $stdout.print(\"This is \", 100, \" percent.\\n\")\n \\n<em>products:-<em>\\n \\n this is 100 percent.", "name": "to_a", "namespace": "ARGF", "path": "ARGF#to_a", "type": "instance_method", "visibility": "public"}, "ARGF#to_i": {"description": "格式化并写入IOS，在格式字符串的控制下转换参数。有关详细信息，请参阅<code>Kernel#sprintf</code>\\n。", "name": "to_i", "namespace": "ARGF", "path": "ARGF#to_i", "type": "instance_method", "visibility": "public"}, "ARGF#to_io": {"description": "如果<i>obj<i>是<code>Numeric</code>，则写入代码是<i>obj的最低有效字节的字符。\\n如果obj<i>is <code>String</code>，则写入<i>obj<i>to<em>ios<em>的第一个字符。\\n否则，提升<code>TypeError</code>。\\n \n   $stdout.putc \"A\"\n   $stdout.putc 65\n \\n<em>产生：.<em>\\n\\n aa", "name": "to_io", "namespace": "ARGF", "path": "ARGF#to_io", "type": "instance_method", "visibility": "public"}, "ARGF#to_s": {"description": "将给定对象写入<em>ios。\\n在任何尚未以换行序列结尾的字符后写入换行符。返回+nil+。\\n \\n必须打开流进行写入。\\n如果使用数组参数调用，则在新行中写入每个元素。\\n将通过调用其+to_s+方法来转换不是字符串或数组的每个给定对象。\\n如果不带参数调用，则输出单个换行符。\\n \n   $stdout.puts(\"this\", \"is\", [\"a\", \"test\"])\n \\n<em>产生：.<em>\\n \n   this\n   is\n   a\n   test\n \\n注意+puts+总是使用换行符，并且不受输出记录分隔符（<code>$\\\\</code>）的影响。", "name": "inspect", "namespace": "ARGF", "path": "ARGF#inspect", "type": "instance_method", "visibility": "public"}, "ARGF#to_write_io": {"description": "从ARGF读取长度字节。此方法将命令行上名为的文件连接起来，并将其视为单个文件，因此当不带参数\\n调用时，此伪文件的内容将全部返回。\\n \\n长度必须是非负整数或+nil+。\\n \\n如果长度为正整数，+read+将尝试在不进行任何转换的情况下读取长度字节（二进制模式）。\\n如果在读取任何内容之前遇到EOF，则返回+nil+。\\n如果在读取过程中遇到EOF，则返回的长度小于字节数。\\n对于整数\\长度\\的情况，生成的字符串始终采用ASCII-8bit编码。\\n \\n如果省略长度或长度为+nil+，则会一直读到eof \\n，并应用编码转换（如果适用）。\\n即使在读取任何数据之前遇到EOF，也会返回字符串。\\n \\n如果长度为零，则返回空字符串（<code>\"\"</code>）。\\n \\n如果存在可选的outbuf参数，它必须引用将接收数据的字符串。\\n outbuf将只包含方法调用后接收的数据，即使它在开始时不是空的。\\n \\n例如：\\n \n   $ echo \"small\" > small.txt\n   $ echo \"large\" > large.txt\n   $ ./glark.rb small.txt large.txt\n\n   ARGF.read      #=> \"small\\nlarge\"\n   ARGF.read(200) #=> \"small\\nlarge\"\n   ARGF.read(2)   #=> \"sm\"\n   ARGF.read(0)   #=> \"\"\n \\n请注意，此方法的行为类似于C中的fread（）函数。\\n这意味着它会重试调用read（2）系统调用以读取指定长度的数据。\\n如果您需要类似于单次读取（2）系统调用的行为，请考虑ARGF readparal或ARGF read_nonblock。", "name": "to_write_io", "namespace": "ARGF", "path": "ARGF#to_write_io", "type": "instance_method", "visibility": "public"}, "ARGF#write": {"description": "在非阻塞模式下，从ARGF流中最多读取maxlen字节。", "name": "write", "namespace": "ARGF", "path": "ARGF#write", "type": "instance_method", "visibility": "public"}, "Marshal": {"description": "", "name": "Marshal", "namespace": "", "path": "Marshal", "type": "module", "visibility": "public"}, "Marshal#dump": {"description": "argf.to_a（sep=$/）->array\n   ARGF.to_a(limit)      -> array\n   ARGF.to_a(sep, limit) -> array\n\\n读取+ARGF+当前文件的全部内容，返回其行的+Array+，每个元素一行。假定行在9月前分隔。\\n \n   lines = ARGF.readlines\n   lines[0]                #=> \"This is line one\\n\"", "name": "dump", "namespace": "Marshal", "path": "Marshal#dump", "type": "module_function", "visibility": "private"}, "Marshal#load": {"description": "将当前文件定位到输入的开头，将\\n+ARGF.lineno+重置为零。n \n   ARGF.readline   #=> \"This is line one\\n\"\n   ARGF.rewind     #=> 0\n   ARGF.lineno     #=> 0\n   ARGF.readline   #=> \"This is line one\\n\"", "name": "load", "namespace": "Marshal", "path": "Marshal#load", "type": "module_function", "visibility": "private"}, "Marshal#restore": {"description": "将当前文件定位到输入的开头，将\\n+ARGF.lineno+重置为零。n \n   ARGF.readline   #=> \"This is line one\\n\"\n   ARGF.rewind     #=> 0\n   ARGF.lineno     #=> 0\n   ARGF.readline   #=> \"This is line one\\n\"", "name": "restore", "namespace": "Marshal", "path": "Marshal#restore", "type": "module_function", "visibility": "private"}, "Marshal.dump": {"description": "argf.to_a（sep=$/）->array\n   ARGF.to_a(limit)      -> array\n   ARGF.to_a(sep, limit) -> array\n\\n读取+ARGF+当前文件的全部内容，返回其行的+Array+，每个元素一行。假定行在9月前分隔。\\n \n   lines = ARGF.readlines\n   lines[0]                #=> \"This is line one\\n\"", "name": "dump", "namespace": "Marshal", "path": "Marshal.dump", "type": "module_function", "visibility": "public"}, "Marshal.load": {"description": "将当前文件定位到输入的开头，将\\n+ARGF.lineno+重置为零。n \n   ARGF.readline   #=> \"This is line one\\n\"\n   ARGF.rewind     #=> 0\n   ARGF.lineno     #=> 0\n   ARGF.readline   #=> \"This is line one\\n\"", "name": "load", "namespace": "Marshal", "path": "Marshal.load", "type": "module_function", "visibility": "public"}, "Marshal.restore": {"description": "将当前文件定位到输入的开头，将\\n+ARGF.lineno+重置为零。n \n   ARGF.readline   #=> \"This is line one\\n\"\n   ARGF.rewind     #=> 0\n   ARGF.lineno     #=> 0\n   ARGF.readline   #=> \"This is line one\\n\"", "name": "restore", "namespace": "Marshal", "path": "Marshal.restore", "type": "module_function", "visibility": "public"}, "Marshal::MAJOR_VERSION": {"description": "根据Whence的值，寻求抵消+ARGF+流中的金额（+Integer+）。请参阅IO了解更多详细信息。", "name": "MAJOR_VERSION", "namespace": "Marshal", "path": "Marshal::MAJOR_VERSION", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "Marshal::MINOR_VERSION": {"description": "如果指定了单个参数，则从ARGF读取的字符串将使用指定的编码进行标记。\\n \\n如果给定两个用冒号分隔的编码名称，例如“ascii:utf-8”，\\n则读取字符串将从第一个编码（外部编码）转换为第二个编码（内部编码），然后用第二个编码标记。\\n \\n如果指定了两个参数，则它们必须是编码对象或编码名称。同样，第一个指定外部encoding;，第二个指定内部编码。\\n \\n如果指定了外部编码和内部编码，则可以使用可选的+Hash+参数来调整转换过程。这个哈希的结构在字符串编码文档中进行了解释。\\n \\n例如：\\n \n    ARGF.set_encoding('ascii')         # Tag the input as US-ASCII text\n    ARGF.set_encoding(Encoding::UTF_8) # Tag the input as UTF-8 text\n    ARGF.set_encoding('utf-8','ascii') # Transcode the input from US-ASCII\n到UTF-8。", "name": "MINOR_VERSION", "namespace": "Marshal", "path": "Marshal::MINOR_VERSION", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "Integer": {"description": "将当前文件设置为ARGV中的下一个文件。如果没有更多的文件，它就没有效果。\\n \\n例如：\\n \n   $ ruby argf.rb foo bar\n   ARGF.filename  #=> \"foo\"\n   ARGF.skip\n   ARGF.filename  #=> \"bar\"", "name": "Integer", "namespace": "", "path": "Integer", "type": "class", "visibility": "public"}, "Integer#%": {"description": "根据+encoding+返回一个字符串，该字符串包含由+int+值表示的字符。n \n   65.chr    #=> \"A\"\n   230.chr   #=> \"\\xE6\"\n   255.chr(Encoding::UTF_8)   #=> \"\\u00FF\"", "name": "%", "namespace": "Integer", "path": "Integer#%", "type": "instance_method", "visibility": "public"}, "Integer#&": {"description": "argf.to_a（sep=$/）->array\n   ARGF.to_a(limit)      -> array\n   ARGF.to_a(sep, limit) -> array\n\\n读取+ARGF+当前文件的全部内容，返回其行的+Array+，每个元素一行。假定行在9月前分隔。\\n \n   lines = ARGF.readlines\n   lines[0]                #=> \"This is line one\\n\"", "name": "&", "namespace": "Integer", "path": "Integer#&", "type": "instance_method", "visibility": "public"}, "Integer#*": {"description": "返回表示当前文件的数字文件描述符的整数。如果没有当前文件，则引发+ArgumentError+。\\n n    ARGF.fileno    #=> 3", "name": "*", "namespace": "Integer", "path": "Integer#*", "type": "instance_method", "visibility": "public"}, "Integer#**": {"description": "返回表示当前文件的+IO+对象。除非当前文件是流（如STDIN），否则这将是+File+对象。\\n \\n例如：\\n \n   ARGF.to_io    #=> #<File:glark.txt>\n   ARGF.to_io    #=> #<IO:<STDIN>>", "name": "**", "namespace": "Integer", "path": "Integer#**", "type": "instance_method", "visibility": "public"}, "Integer#+": {"description": "返回“ARGF”。", "name": "+", "namespace": "Integer", "path": "Integer#+", "type": "instance_method", "visibility": "public"}, "Integer#-": {"description": "如果启用了inplace模式，则返回绑定到_ARGF_的IO实例进行写入。", "name": "-", "namespace": "Integer", "path": "Integer#-", "type": "instance_method", "visibility": "public"}, "Integer#-@": {"description": "如果是就地模式，则写入字符串。", "name": "-@", "namespace": "Integer", "path": "Integer#-@", "type": "instance_method", "visibility": "public"}, "Integer#/": {"description": "序列化obj和所有子代对象。如果指定了anio，则序列化数据将写入其中，否则数据将作为字符串返回。如果指定了限制，子对象的遍历将限制在该深度。如果极限为负，则不进行深度检查。\\n \n    class Klass\n      def initialize(str)\n        @str = str\n      end\n      def say_hello\n        @str\n      end\n    end\n \\n（不生成输出）\n    o = Klass.new(\"hello\\n\")\n    data = Marshal.dump(o)\n    obj = Marshal.load(data)\n    obj.say_hello  #=> \"hello\\n\"\n \\n Marshal无法转储以下对象：\\n*匿名类/模块。\\n*与系统相关的对象（例如：dir、file:：stat、io、file、socket\n  and so on)\n*MatchData、data、method、UnboundMethod、proc、thread、\n  ThreadGroup, Continuation\n的实例*定义singleton方法的对象", "name": "/", "namespace": "Integer", "path": "Integer#/", "type": "instance_method", "visibility": "public"}, "Integer#<": {"description": "返回将源中的序列化数据转换为Ruby对象（可能具有关联的从属对象）的结果。源可以是IO实例，也可以是响应to_str的对象。如果指定proc，则当对象正在反序列化时，每个对象都将传递给proc。\\n \\n永远不要将不受信任的数据（包括用户提供的输入）传递给此方法。\\n有关详细信息，请参阅概述。", "name": "<", "namespace": "Integer", "path": "Integer#<", "type": "instance_method", "visibility": "public"}, "Integer#<<": {"description": "返回将源中的序列化数据转换为Ruby对象（可能具有关联的从属对象）的结果。源可以是IO实例，也可以是响应to_str的对象。如果指定proc，则当对象正在反序列化时，每个对象都将传递给proc。\\n \\n永远不要将不受信任的数据（包括用户提供的输入）传递给此方法。\\n有关详细信息，请参阅概述。", "name": "<<", "namespace": "Integer", "path": "Integer#<<", "type": "instance_method", "visibility": "public"}, "Integer#<=": {"description": "序列化obj和所有子代对象。如果指定了anio，则序列化数据将写入其中，否则数据将作为字符串返回。如果指定了限制，子对象的遍历将限制在该深度。如果极限为负，则不进行深度检查。\\n \n    class Klass\n      def initialize(str)\n        @str = str\n      end\n      def say_hello\n        @str\n      end\n    end\n \\n（不生成输出）\n    o = Klass.new(\"hello\\n\")\n    data = Marshal.dump(o)\n    obj = Marshal.load(data)\n    obj.say_hello  #=> \"hello\\n\"\n \\n Marshal无法转储以下对象：\\n*匿名类/模块。\\n*与系统相关的对象（例如：dir、file:：stat、io、file、socket\n  and so on)\n*MatchData、data、method、UnboundMethod、proc、thread、\n  ThreadGroup, Continuation\n的实例*定义singleton方法的对象", "name": "<=", "namespace": "Integer", "path": "Integer#<=", "type": "instance_method", "visibility": "public"}, "Integer#<=>": {"description": "返回将源中的序列化数据转换为Ruby对象（可能具有关联的从属对象）的结果。源可以是IO实例，也可以是响应to_str的对象。如果指定proc，则当对象正在反序列化时，每个对象都将传递给proc。\\n \\n永远不要将不受信任的数据（包括用户提供的输入）传递给此方法。\\n有关详细信息，请参阅概述。", "name": "<=>", "namespace": "Integer", "path": "Integer#<=>", "type": "instance_method", "visibility": "public"}, "Integer#==": {"description": "主要版本", "name": "==", "namespace": "Integer", "path": "Integer#==", "type": "instance_method", "visibility": "public"}, "Integer#===": {"description": "主要版本", "name": "===", "namespace": "Integer", "path": "Integer#===", "type": "instance_method", "visibility": "public"}, "Integer#>": {"description": "次要版本", "name": ">", "namespace": "Integer", "path": "Integer#>", "type": "instance_method", "visibility": "public"}, "Integer#>=": {"description": "************************************************************\\n\\n \n  Holds Integer values.  You cannot add a singleton method to an\n整数对象，任何尝试都将引发TypeError。", "name": ">=", "namespace": "Integer", "path": "Integer#>=", "type": "instance_method", "visibility": "public"}, "Integer#>>": {"description": "返回+int+模块+other+。\\n \\n有关详细信息，请参阅numeric divmod。", "name": ">>", "namespace": "Integer", "path": "Integer#>>", "type": "instance_method", "visibility": "public"}, "Integer#[]": {"description": "Bitwise和", "name": "[]", "namespace": "Integer", "path": "Integer#[]", "type": "instance_method", "visibility": "public"}, "Integer#^": {"description": "执行乘法：结果对象的类取决于\\n +numeric+的类。", "name": "^", "namespace": "Integer", "path": "Integer#^", "type": "instance_method", "visibility": "public"}, "Integer#abs": {"description": "", "name": "abs", "namespace": "Integer", "path": "Integer#abs", "type": "instance_method", "visibility": "public"}, "Integer#allbits?": {"description": "将+int+提升到+numeric+的幂，该幂可以是负数或小数。\\n结果可以是整数、浮点数、有理数或复数。n \n   2 ** 3        #=> 8\n   2 ** -1       #=> (1/2)\n   2 ** 0.5      #=> 1.4142135623730951\n   (-1) ** 0.5   #=> (0.0+1.0i)\n\n   123456789 ** 2     #=> 15241578750190521\n   123456789 ** 1.2   #=> 5126464716.0993185\n   123456789 ** -2    #=> (1/15241578750190521)", "name": "allbits?", "namespace": "Integer", "path": "Integer#allbits?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Integer#anybits?": {"description": "执行加法：结果对象的类依赖于\\n +numeric+的类。", "name": "anybits?", "namespace": "Integer", "path": "Integer#anybits?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Integer#bit_length": {"description": "执行减法：结果对象的类依赖于\\n +numeric+的类。", "name": "bit_length", "namespace": "Integer", "path": "Integer#bit_length", "type": "instance_method", "visibility": "public"}, "Integer#ceil": {"description": "返回+int+，否定。", "name": "ceil", "namespace": "Integer", "path": "Integer#ceil", "type": "instance_method", "visibility": "public"}, "Integer#chr": {"description": "执行除法：结果对象的类依赖于\\n +numeric+的类。", "name": "chr", "namespace": "Integer", "path": "Integer#chr", "type": "instance_method", "visibility": "public"}, "Integer#coerce": {"description": "如果+int+的值小于+real+的值，则返回+true+。", "name": "coerce", "namespace": "Integer", "path": "Integer#coerce", "type": "instance_method", "visibility": "public"}, "Integer#denominator": {"description": "返回+int+左移+count+个位置，如果+count+为负，则返回右移。", "name": "denominator", "namespace": "Integer", "path": "Integer#denominator", "type": "instance_method", "visibility": "public"}, "Integer#digits": {"description": "如果+int+的值小于或等于+real+，则返回+true+。", "name": "digits", "namespace": "Integer", "path": "Integer#digits", "type": "instance_method", "visibility": "public"}, "Integer#div": {"description": "比较-返回-1、0或+1，具体取决于+int+是小于、等于还是大于+numeric+。\\n \\n这是可比较模块中测试的基础。\\n \\n如果这两个值不可比较，则返回+nil+。", "name": "div", "namespace": "Integer", "path": "Integer#div", "type": "instance_method", "visibility": "public"}, "Integer#divmod": {"description": "如果+int+的数值等于+other+，则返回+true+。\\n是否将此与integer eql进行比较？，要求+other+为整数。n \n   1 == 2     #=> false\n   1 == 1.0   #=> true", "name": "divmod", "namespace": "Integer", "path": "Integer#divmod", "type": "instance_method", "visibility": "public"}, "Integer#downto": {"description": "如果+int+的数值等于+other+，则返回+true+。\\n是否将此与integer eql进行比较？，要求+other+为整数。n \n   1 == 2     #=> false\n   1 == 1.0   #=> true", "name": "downto", "namespace": "Integer", "path": "Integer#downto", "type": "instance_method", "visibility": "public"}, "Integer#even?": {"description": "如果+int+的值大于+real+的值，则返回+true+。", "name": "even?", "namespace": "Integer", "path": "Integer#even?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Integer#fdiv": {"description": "如果+int+的值大于或等于+real+，则返回+true+。", "name": "fdiv", "namespace": "Integer", "path": "Integer#fdiv", "type": "instance_method", "visibility": "public"}, "Integer#floor": {"description": "返回+int+右移+count+位置，如果+count+为负，则返回左移。", "name": "floor", "namespace": "Integer", "path": "Integer#floor", "type": "instance_method", "visibility": "public"}, "Integer#gcd": {"description": "位引用-返回+int+的二进制表示形式中的第<code>n</code>位，其中<code>int[0]</code> \\n是最低有效位。n \n   a = 0b11001100101010\n   30.downto(0) {|n| print a[n] }\n   #=> 0000000000000000011001100101010\n\n   a = 9**15\n   50.downto(0) {|n| print a[n] }\n   #=> 000101110110\n   ary = Array.new    #=> []\n   Array.new(3)       #=> [nil, nil, nil]\n   Array.new(3, true) #=> [true, true, true]\n1\n  browsers.empty? #=> false\n1+true+0111\n  i, and\n11001", "name": "gcd", "namespace": "Integer", "path": "Integer#gcd", "type": "instance_method", "visibility": "public"}, "Integer#gcdlcm": {"description": "按位EXCLUSIVE或。", "name": "gcdlcm", "namespace": "Integer", "path": "Integer#gcdlcm", "type": "instance_method", "visibility": "public"}, "Integer#inspect": {"description": "返回+int+的后续项，即等于<code>int+1</code>的整数。n \n   1.next      #=> 2\n   (-1).next   #=> 0\n   1.succ      #=> 2\n   (-1).succ   #=> 0", "name": "inspect", "namespace": "Integer", "path": "Integer#inspect", "type": "instance_method", "visibility": "public"}, "Integer#integer?": {"description": "如果<code>+int+ & +mask+</code>的任何位为1，则返回+true+。", "name": "integer?", "namespace": "Integer", "path": "Integer#integer?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Integer#lcm": {"description": "返回值+int+的位数。\\n \\n“位数”是指与符号位不同的最高位的位位置（其中最低有效位具有位位置1）。\\n如果没有这样的位（零或负一），则返回零。\\n \\n例如，此方法返回<i>ceil（log2（int<0？）-int:int+1））.<i>。\\n \n   (-2**1000-1).bit_length   #=> 1001\n   (-2**1000).bit_length     #=> 1000\n   (-2**1000+1).bit_length   #=> 1000\n   (-2**12-1).bit_length     #=> 13\n   (-2**12).bit_length       #=> 12\n   (-2**12+1).bit_length     #=> 12\n   -0x101.bit_length         #=> 9\n   -0x100.bit_length         #=> 8\n   -0xff.bit_length          #=> 8\n   -2.bit_length             #=> 1\n   -1.bit_length             #=> 0\n   0.bit_length              #=> 0\n   1.bit_length              #=> 1\n   0xff.bit_length           #=> 8\n   0x100.bit_length          #=> 9\n   (2**12-1).bit_length      #=> 12\n   (2**12).bit_length        #=> 13\n   (2**12+1).bit_length      #=> 13\n   (2**1000-1).bit_length    #=> 1000\n   (2**1000).bit_length      #=> 1001\n   (2**1000+1).bit_length    #=> 1001\n \\n此方法可用于检测数组包中的溢出，如下所示：\\n \n   if n.bit_length < 32\n     [n].pack(\"l\") # no overflow\n   else\n     raise \"overflow\"\n end", "name": "lcm", "namespace": "Integer", "path": "Integer#lcm", "type": "instance_method", "visibility": "public"}, "Integer#magnitude": {"description": "返回大于或等于+int+的最小数字，精度为+ndigits+位十进制数字（默认值：0）。\\n \\n当精度为负时，返回的值是一个整数，后面至少有<code>ndigits.abs</code>个零。\\n \\n当+ndigits+为零或正时，返回+self+。n \n   1.ceil           #=> 1\n   1.ceil(2)        #=> 1\n   18.ceil(-1)      #=> 20\n   (-18).ceil(-1)   #=> -10", "name": "magnitude", "namespace": "Integer", "path": "Integer#magnitude", "type": "instance_method", "visibility": "public"}, "Integer#modulo": {"description": "根据+encoding+返回一个字符串，该字符串包含由+int+值表示的字符。n \n   65.chr    #=> \"A\"\n   230.chr   #=> \"\\xE6\"\n   255.chr(Encoding::UTF_8)   #=> \"\\u00FF\"", "name": "modulo", "namespace": "Integer", "path": "Integer#modulo", "type": "instance_method", "visibility": "public"}, "Integer#next": {"description": "返回两个整数中具有最大公因子和最小公倍数的数组，[gcd，lcm]。n \n   36.gcdlcm(60)                  #=> [12, 180]\n   2.gcdlcm(2)                    #=> [2, 2]\n   3.gcdlcm(-7)                   #=> [1, 21]\n   ((1<<31)-1).gcdlcm((1<<61)-1)  #=> [1, 4951760154835678088235319297]", "name": "next", "namespace": "Integer", "path": "Integer#next", "type": "instance_method", "visibility": "public"}, "Integer#nobits?": {"description": "返回1。", "name": "nobits?", "namespace": "Integer", "path": "Integer#nobits?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Integer#numerator": {"description": "返回以+base+为基数的+int+的位值表示形式的数字（默认值：10）。\\n这些数字作为数组返回，其中最低有效数字作为第一个数组元素。\\n \\n +base+必须大于或等于2。\\n \n   12345.digits      #=> [5, 4, 3, 2, 1]\n   12345.digits(7)   #=> [4, 6, 6, 0, 5]\n   12345.digits(100) #=> [45, 23, 1]\n \\n    -12345.digits(7)  #=> Math::DomainError", "name": "numerator", "namespace": "Integer", "path": "Integer#numerator", "type": "instance_method", "visibility": "public"}, "Integer#odd?": {"description": "执行整数除法：返回将+int+除以+numeric+的整数结果。", "name": "odd?", "namespace": "Integer", "path": "Integer#odd?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Integer#ord": {"description": "参见数字divmod。", "name": "ord", "namespace": "Integer", "path": "Integer#ord", "type": "instance_method", "visibility": "public"}, "Integer#pow": {"description": "迭代给定的块，将值从+int+递减到+limit+。\\n \\n如果没有给定块，则返回枚举器。n \n   5.downto(1) { |n| print n, \".. \" }\n   puts \"Liftoff!\"\n   #=> \"5.. 4.. 3.. 2.. 1.. Liftoff!\"", "name": "pow", "namespace": "Integer", "path": "Integer#pow", "type": "instance_method", "visibility": "public"}, "Integer#pred": {"description": "", "name": "pred", "namespace": "Integer", "path": "Integer#pred", "type": "instance_method", "visibility": "public"}, "Integer#rationalize": {"description": "如果+int+是偶数，则返回+true+。", "name": "rationalize", "namespace": "Integer", "path": "Integer#rationalize", "type": "instance_method", "visibility": "public"}, "Integer#remainder": {"description": "返回+int+除以+numeric+的浮点结果。n \n   654321.fdiv(13731)      #=> 47.652829364212366\n   654321.fdiv(13731.24)   #=> 47.65199646936475\n   -654321.fdiv(13731)     #=> -47.652829364212366", "name": "remainder", "namespace": "Integer", "path": "Integer#remainder", "type": "instance_method", "visibility": "public"}, "Integer#round": {"description": "返回小于或等于+int+的最大数字，精度为+ndigits+位十进制数字（默认值：0）。\\n \\n当精度为负时，返回的值是一个整数，后面至少有<code>ndigits.abs</code>个零。\\n \\n当+ndigits+为零或正数时，返回+self+。n \n   1.floor           #=> 1\n   1.floor(2)        #=> 1\n   18.floor(-1)      #=> 10\n   (-18).floor(-1)   #=> -20", "name": "round", "namespace": "Integer", "path": "Integer#round", "type": "instance_method", "visibility": "public"}, "Integer#size": {"description": "返回两个整数的最大公约数。\\n结果始终为正。0.GCD（x）和x。GCD（0）返回x.abs。n \n   36.gcd(60)                  #=> 12\n   2.gcd(2)                    #=> 2\n   3.gcd(-7)                   #=> 1\n   ((1<<31)-1).gcd((1<<61)-1)  #=> 1", "name": "size", "namespace": "Integer", "path": "Integer#size", "type": "instance_method", "visibility": "public"}, "Integer#succ": {"description": "返回两个整数中具有最大公因子和最小公倍数的数组，[gcd，lcm]。n \n   36.gcdlcm(60)                  #=> [12, 180]\n   2.gcdlcm(2)                    #=> [2, 2]\n   3.gcdlcm(-7)                   #=> [1, 21]\n   ((1<<31)-1).gcdlcm((1<<61)-1)  #=> [1, 4951760154835678088235319297]", "name": "succ", "namespace": "Integer", "path": "Integer#succ", "type": "instance_method", "visibility": "public"}, "Integer#times": {"description": "返回一个字符串，该字符串包含以+base+为基数（介于2和36之间）表示的+int+ \\n位值。n \n   12345.to_s       #=> \"12345\"\n   12345.to_s(2)    #=> \"11000000111001\"\n   12345.to_s(8)    #=> \"30071\"\n   12345.to_s(10)   #=> \"12345\"\n   12345.to_s(16)   #=> \"3039\"\n   12345.to_s(36)   #=> \"9ix\"\n   78546939656932.to_s(36)  #=> \"rubyrules\"", "name": "times", "namespace": "Integer", "path": "Integer#times", "type": "instance_method", "visibility": "public"}, "Integer#to_f": {"description": "因为+int+已经是一个整数，所以它总是返回+true+。", "name": "to_f", "namespace": "Integer", "path": "Integer#to_f", "type": "instance_method", "visibility": "public"}, "Integer#to_i": {"description": "返回+int+的绝对值。\\n \n   (-12345).abs   #=> 12345\n   -12345.abs     #=> 12345\n   12345.abs      #=> 12345\n \\n integer marize是integer abs的别名。", "name": "to_i", "namespace": "Integer", "path": "Integer#to_i", "type": "instance_method", "visibility": "public"}, "Integer#to_int": {"description": "返回+int+的绝对值。\\n \n   (-12345).abs   #=> 12345\n   -12345.abs     #=> 12345\n   12345.abs      #=> 12345\n \\n integer marize是integer abs的别名。", "name": "to_int", "namespace": "Integer", "path": "Integer#to_int", "type": "instance_method", "visibility": "public"}, "Integer#to_r": {"description": "返回+int+模块+other+。\\n \\n有关详细信息，请参阅numeric divmod。", "name": "to_r", "namespace": "Integer", "path": "Integer#to_r", "type": "instance_method", "visibility": "public"}, "Integer#to_s": {"description": "返回+int+的后续项，即等于<code>int+1</code>的整数。n \n   1.next      #=> 2\n   (-1).next   #=> 0\n   1.succ      #=> 2\n   (-1).succ   #=> 0", "name": "inspect", "namespace": "Integer", "path": "Integer#inspect", "type": "instance_method", "visibility": "public"}, "Integer#truncate": {"description": "如果<code>+int+ & +mask+</code>的任何位都不是1，则返回+true+。", "name": "truncate", "namespace": "Integer", "path": "Integer#truncate", "type": "instance_method", "visibility": "public"}, "Integer#upto": {"description": "返回自我。", "name": "upto", "namespace": "Integer", "path": "Integer#upto", "type": "instance_method", "visibility": "public"}, "Integer#|": {"description": "如果+int+是奇数，则返回+true+。", "name": "|", "namespace": "Integer", "path": "Integer#|", "type": "instance_method", "visibility": "public"}, "Integer#~": {"description": "returns的+int+本身。的\n   97.ord   #=> 97\n ---这种方法是专为大literals兼容性字符在Ruby 1.9。的。例如，<code>?a.ord</code> 97 returns都在1.8和1.9。", "name": "~", "namespace": "Integer", "path": "Integer#~", "type": "instance_method", "visibility": "public"}, "Integer.sqrt": {"description": "returns（modular exponentiation的\n  a.pow(b)     #=> same as a**b\n  a.pow(b, m)  #=> same as (a**b) % m, but avoids huge temporary values）为：", "name": "sqrt", "namespace": "Integer", "path": "Integer.sqrt", "type": "class_method", "visibility": "public"}, "Integer::GMP_VERSION": {"description": "作为一个rational returns的价值。是的optional argument +eps+总是忽略。", "name": "GMP_VERSION", "namespace": "Integer", "path": "Integer::GMP_VERSION", "type": "constant", "return": null, "visibility": "public"}, "ZeroDivisionError": {"description": "returns的remainder dividing +int+后由+numeric+。<code>x-y*(x/y).truncate</code> <code>x.remainder(y)</code>意味着。。。的\n   5.remainder(3)     #=> 2\n   -5.remainder(3)    #=> -2\n   5.remainder(-3)    #=> 2\n   -5.remainder(-3)   #=> -2\n   5.remainder(1.5)   #=> 0.5\n --- numeric # divmod看到。", "name": "ZeroDivisionError", "namespace": "", "path": "ZeroDivisionError", "type": "class", "visibility": "public"}, "FloatDomainError": {"description": "returns +int+最近的文献价值与一个圆形的+ndigits+ decimal（precision地点安装默认：0）。是的。当precision是负的，返回的是一个价值integer与至少<code>ndigits.abs</code> trailing文件。的returns +self+ ---当+ndigits+是零或正相关。的\n   1.round           #=> 1\n   1.round(2)        #=> 1\n   15.round(-1)      #=> 20\n   (-15).round(-1)   #=> -20\n ---前的optional +half+ argument是可以类似于浮#圆。\n   25.round(-1, half: :up)      #=> 30\n   25.round(-1, half: :down)    #=> 20\n   25.round(-1, half: :even)    #=> 20\n   35.round(-1, half: :up)      #=> 40\n   35.round(-1, half: :down)    #=> 30\n   35.round(-1, half: :even)    #=> 40\n   (-25).round(-1, half: :up)   #=> -30\n   (-25).round(-1, half: :down) #=> -20\n   (-25).round(-1, half: :even) #=> -20。", "name": "FloatDomainError", "namespace": "", "path": "FloatDomainError", "type": "class", "visibility": "public"}, "TrueClass": {"description": "returns的位元组的数量在机器的+int+ representation（机器的依赖）。\n   1.size               #=> 8\n   -1.size              #=> 8\n   2147483647.size      #=> 8\n   (256**10 - 1).size   #=> 10\n   (256**20 - 1).size   #=> 20\n   (256**40 - 1).size   #=> 40。", "name": "TrueClass", "namespace": "", "path": "TrueClass", "type": "class", "visibility": "public"}, "TrueClass#&": {"description": "returns的接班人的+int+ ---即，integer equal <code>int+1</code>的大。\n   1.next      #=> 2\n   (-1).next   #=> 0\n   1.succ      #=> 2\n   (-1).succ   #=> 0。", "name": "&", "namespace": "TrueClass", "path": "TrueClass#&", "type": "instance_method", "visibility": "public"}, "TrueClass#===": {"description": "iterates的给定的块，通过在integer价值从+int+到和包括+limit+。是的。如果没有布拉克是给定的，而enumerator是安全返回。   5.upto(10) {|i| print i, \" \" }   #=> 5 6 7 8 9 10 ---。", "name": "===", "namespace": "TrueClass", "path": "TrueClass#===", "type": "instance_method", "visibility": "public"}, "TrueClass#^": {"description": "一个converts +int+浮。如果不在一个+int+ fit浮的，结果是无限的。", "name": "^", "namespace": "TrueClass", "path": "TrueClass#^", "type": "instance_method", "visibility": "public"}, "TrueClass#inspect": {"description": "自+int+已经integer是安全，returns +self+。的大的# _ int是安全# _ alias为大。", "name": "inspect", "namespace": "TrueClass", "path": "TrueClass#inspect", "type": "instance_method", "visibility": "public"}, "TrueClass#to_s": {"description": "自+int+已经integer是安全，returns +self+。的大的# _ int是安全# _ alias为大。", "name": "inspect", "namespace": "TrueClass", "path": "TrueClass#inspect", "type": "instance_method", "visibility": "public"}, "TrueClass#|": {"description": "作为一个rational returns的价值。\n   1.to_r        #=> (1/1)\n   (1<<64).to_r  #=> (18446744073709551616/1)。", "name": "|", "namespace": "TrueClass", "path": "TrueClass#|", "type": "instance_method", "visibility": "public"}, "FalseClass": {"description": "一个弦乐returns包含价值的地方- representation +int+ ---与radix +base+（2和36之间）。\n   12345.to_s       #=> \"12345\"\n   12345.to_s(2)    #=> \"11000000111001\"\n   12345.to_s(8)    #=> \"30071\"\n   12345.to_s(10)   #=> \"12345\"\n   12345.to_s(16)   #=> \"3039\"\n   12345.to_s(36)   #=> \"9ix\"\n   78546939656932.to_s(36)  #=> \"rubyrules\"。", "name": "FalseClass", "namespace": "", "path": "FalseClass", "type": "class", "visibility": "public"}, "FalseClass#&": {"description": "returns +int+ truncated（对零）到一个precision的+ndigits+（decimal地点安装默认：0）。是的。当precision是负的，返回的是一个价值integer与至少<code>ndigits.abs</code> trailing文件。的returns +self+ ---当+ndigits+是零或正相关。\n   1.truncate           #=> 1\n   1.truncate(2)        #=> 1\n   18.truncate(-1)      #=> 10\n   (-18).truncate(-1)   #=> -10。", "name": "&", "namespace": "FalseClass", "path": "FalseClass#&", "type": "instance_method", "visibility": "public"}, "FalseClass#===": {"description": "iterates的给定的块，通过在integer价值从+int+到和包括+limit+。是的。如果没有布拉克是给定的，而enumerator是安全返回。   5.upto(10) {|i| print i, \" \" }   #=> 5 6 7 8 9 10 ---。", "name": "===", "namespace": "FalseClass", "path": "FalseClass#===", "type": "instance_method", "visibility": "public"}, "FalseClass#^": {"description": "bitwise或。", "name": "^", "namespace": "FalseClass", "path": "FalseClass#^", "type": "instance_method", "visibility": "public"}, "FalseClass#inspect": {"description": "returns广场的integer根的非负integer +n+ ---即，的最大非负不integer煤或根的+n+ equal的广场。的等效的\n  Integer.sqrt(0)        #=> 0\n  Integer.sqrt(1)        #=> 1\n  Integer.sqrt(24)       #=> 4\n  Integer.sqrt(25)       #=> 5\n  Integer.sqrt(10**400)  #=> 10**200\n大<code>Math.sqrt(n).floor</code>，除了后者的代码，结果是不同的从真实价值的precision floating由于有限的点的算法。的\n  Integer.sqrt(10**46)     #=> \n   ary = [1, \"two\", 3.0] #=> [1, \"two\", 3.0]\n00000000000000000\n  Math.sqrt(10**46).floor  #=>  99999999999999991611392 (!)\n +n+是不安全的，如果它是为该integer integer大，安全第一。+n+ ---如果是负的，一个数学：DomainError是提出。", "name": "inspect", "namespace": "FalseClass", "path": "FalseClass#inspect", "type": "instance_method", "visibility": "public"}, "FalseClass#to_s": {"description": "returns广场的integer根的非负integer +n+ ---即，的最大非负不integer煤或根的+n+ equal的广场。的等效的\n  Integer.sqrt(0)        #=> 0\n  Integer.sqrt(1)        #=> 1\n  Integer.sqrt(24)       #=> 4\n  Integer.sqrt(25)       #=> 5\n  Integer.sqrt(10**400)  #=> 10**200\n大<code>Math.sqrt(n).floor</code>，除了后者的代码，结果是不同的从真实价值的precision floating由于有限的点的算法。的\n  Integer.sqrt(10**46)     #=> \n   ary = [1, \"two\", 3.0] #=> [1, \"two\", 3.0]\n00000000000000000\n  Math.sqrt(10**46).floor  #=>  99999999999999991611392 (!)\n +n+是不安全的，如果它是为该integer integer大，安全第一。+n+ ---如果是负的，一个数学：DomainError是提出。", "name": "inspect", "namespace": "FalseClass", "path": "FalseClass#inspect", "type": "instance_method", "visibility": "public"}, "FalseClass#|": {"description": "loaded gmp的版本。", "name": "|", "namespace": "FalseClass", "path": "FalseClass#|", "type": "instance_method", "visibility": "public"}, "Data": {"description": "当试图提出安全integer由0分。\n   42 / 0   #=> ZeroDivisionError: divided by 0\n ---组织---注，只有准确、安全的将由0提高\n   42 /  0.0   #=> Float::INFINITY\n   42 / -0.0   #=> -Float::INFINITY\n   0  /  0.0   #=> NaN的例外：", "name": "Data", "namespace": "", "path": "Data", "type": "class", "visibility": "public"}, "Ripper": {"description": "", "name": "Ripper", "namespace": "", "path": "Ripper", "type": "class", "visibility": "public"}, "Ripper#column": {"description": "当试图将提出的特殊价值（特别是浮在+Infinity+或+NaN+）数值类，不支持他们。   Float::INFINITY.to_r   #=> FloatDomainError: Infinity ---。", "name": "column", "namespace": "Ripper", "path": "Ripper#column", "type": "instance_method", "visibility": "public"}, "Ripper#dedent_string": {"description": "", "name": "dedent_string", "namespace": "Ripper", "path": "Ripper#dedent_string", "type": "instance_method", "visibility": "private"}, "Ripper#encoding": {"description": "* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *的\n  The global value <code>true</code> is the only instance of class\n  <code>TrueClass</code> and represents a logically true value in\n  boolean expressions. The class provides operators allowing\n <code>true</code>大logical expressions用于打印。", "name": "encoding", "namespace": "Ripper", "path": "Ripper#encoding", "type": "instance_method", "visibility": "public"}, "Ripper#end_seen?": {"description": "如果我returns <code>false</code> <和> - <？>是obj <code>nil</code>或<code>true</code> <code>false</code>，否则。", "name": "end_seen?", "namespace": "Ripper", "path": "Ripper#end_seen?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Ripper#error?": {"description": "平等——为类的面向对象的情况下，有效地为<code>#==</code>电话相同，但通常由大overridden后代提供有意义semantics在+case+ statements。", "name": "error?", "namespace": "Ripper", "path": "Ripper#error?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Ripper#filename": {"description": "returns <code>true</code>独家或-如果我obj < > <？>是<code>nil</code>或<code>false</code>，<code>false</code>。否则。", "name": "filename", "namespace": "Ripper", "path": "Ripper#filename", "type": "instance_method", "visibility": "public"}, "Ripper#initialize": {"description": "representation的弦乐<code>true</code>是“真实的”。", "name": "initialize", "namespace": "Ripper", "path": "Ripper#initialize", "type": "instance_method", "visibility": "public"}, "Ripper#lineno": {"description": "representation的弦乐<code>true</code>是“真实的”。", "name": "lineno", "namespace": "Ripper", "path": "Ripper#lineno", "type": "instance_method", "visibility": "public"}, "Ripper#parse": {"description": "或- returns <code>true</code>。我obj >为< <？>是一个argument方法调用，它是不总是有evaluated;短电路评价在这种情况下。我的\n   true |  puts(\"or\")\n   true || puts(\"logical or\")\n。< >：< >生产/或我的。", "name": "parse", "namespace": "Ripper", "path": "Ripper#parse", "type": "instance_method", "visibility": "public"}, "Ripper#state": {"description": "全球价值<code>false</code>是唯一的类代表一个instance <code>FalseClass</code>和logically false的价值在boolean expressions。提供允许大的类的基础上正确participate <code>false</code>算子在logical expressions。", "name": "state", "namespace": "Ripper", "path": "Ripper#state", "type": "instance_method", "visibility": "public"}, "Ripper#yydebug": {"description": "returns <code>false</code>和-。我obj＜＜> >是评估/我总是因为它是一个方法调用的argument -有没有短电路评价在这种情况下。", "name": "yydebug", "namespace": "Ripper", "path": "Ripper#yydebug", "type": "instance_method", "visibility": "public"}, "Ripper#yydebug=": {"description": "平等——为类的面向对象的情况下，有效地为<code>#==</code>电话相同，但通常由大overridden后代提供有意义semantics在+case+ statements。", "name": "yydebug=", "namespace": "Ripper", "path": "Ripper#yydebug=", "type": "instance_method", "visibility": "public"}, "Ripper.dedent_string": {"description": "", "name": "dedent_string", "namespace": "Ripper", "path": "Ripper.dedent_string", "type": "class_method", "visibility": "public"}, "Ripper.lex_state_name": {"description": "", "name": "lex_state_name", "namespace": "Ripper", "path": "Ripper.lex_state_name", "type": "class_method", "visibility": "public"}, "Ripper::Version": {"description": "如果我独家或< > <？>是obj <code>nil</code>或<code>false</code>，returns <code>false</code>；否则，returns <code>true</code>。", "name": "Version", "namespace": "Ripper", "path": "Ripper::Version", "type": "constant", "return": null, "visibility": "public"}, "Method": {"description": "representation的弦乐的<code>false</code>是“false”。", "name": "Method", "namespace": "", "path": "Method", "type": "class", "visibility": "public"}, "Method#==": {"description": "返回基础方法的名称。\\n n   \"cat\".method(:count).inspect   #=> \"#<Method: String#count>\"", "name": "==", "namespace": "Method", "path": "Method#==", "type": "instance_method", "visibility": "public"}, "Method#===": {"description": "返回源的编码。", "name": "===", "namespace": "Method", "path": "Method#===", "type": "instance_method", "visibility": "public"}, "Method#[]": {"description": "返回源的编码。", "name": "[]", "namespace": "Method", "path": "Method#[]", "type": "instance_method", "visibility": "public"}, "Method#arity": {"description": "返回基于方法的curried过程。当使用低于方法arity的多个参数调用proc时，将返回另一个curried proc。\\n只有在提供了足够的参数以满足方法签名时，才会实际调用该方法。\\n \\n当使用变量参数当前方法以确定在调用方法之前需要多少参数时，应提供可选的<i>arity->argument。n \n   def foo(a,b,c)\n     [a, b, c]\n   end\n\n   proc  = self.method(:foo).curry\n   proc2 = proc.call(1, 2)          #=> #<Proc>\n   proc2.call(3)                    #=> [1,2,3]\n\n   def vararg(*args)\n     args\n   end\n\n   proc = self.method(:vararg).curry(4)\n   proc2 = proc.call(:x)      #=> #<Proc>\n   proc3 = proc2.call(:y, :z) #=> #<Proc>\n   proc3.call(:a)             #=> [:x, :y, :z, :a]", "name": "arity", "namespace": "Method", "path": "Method#arity", "type": "instance_method", "visibility": "public"}, "Method#call": {"description": "返回源的编码。", "name": "call", "namespace": "Method", "path": "Method#call", "type": "instance_method", "visibility": "public"}, "Method#clone": {"description": "返回与方法对象对应的哈希值。\\n \\n另请参阅对象哈希。", "name": "clone", "namespace": "Method", "path": "Method#clone", "type": "instance_method", "visibility": "public"}, "Method#curry": {"description": "如果分析的源有错误，则返回true。", "name": "curry", "namespace": "Method", "path": "Method#curry", "type": "instance_method", "visibility": "public"}, "Method#eql?": {"description": "返回基础方法的名称。\\n n   \"cat\".method(:count).inspect   #=> \"#<Method: String#count>\"", "name": "eql?", "namespace": "Method", "path": "Method#eql?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Method#hash": {"description": "返回方法的名称。", "name": "hash", "namespace": "Method", "path": "Method#hash", "type": "instance_method", "visibility": "public"}, "Method#inspect": {"description": "返回基础方法的名称。\\n n   \"cat\".method(:count).inspect   #=> \"#<Method: String#count>\"", "name": "inspect", "namespace": "Method", "path": "Method#inspect", "type": "instance_method", "visibility": "public"}, "Method#name": {"description": "返回定义方法的类或模块。", "name": "name", "namespace": "Method", "path": "Method#name", "type": "instance_method", "visibility": "public"}, "Method#original_name": {"description": "返回此方法的参数信息。n \n   def foo(bar); end\n   method(:foo).parameters #=> [[:req, :bar]]\n\n   def foo(bar, baz, bat, &blk); end\n   method(:foo).parameters #=> [[:req, :bar], [:req, :baz], [:req, :bat], [:block, :blk]]\n\n   def foo(bar, *args); end\n   method(:foo).parameters #=> [[:req, :bar], [:rest, :args]]\n\n   def foo(bar, baz, *args, &blk); end\n   method(:foo).parameters #=> [[:req, :bar], [:req, :baz], [:rest, :args], [:block, :blk]]", "name": "original_name", "namespace": "Method", "path": "Method#original_name", "type": "instance_method", "visibility": "public"}, "Method#owner": {"description": "返回方法对象的绑定接收器。", "name": "owner", "namespace": "Method", "path": "Method#owner", "type": "instance_method", "visibility": "public"}, "Method#parameters": {"description": "返回包含此方法的Ruby源文件名和行号，如果此方法未在Ruby（即Native）中定义，则返回nil。", "name": "parameters", "namespace": "Method", "path": "Method#parameters", "type": "instance_method", "visibility": "public"}, "Method#receiver": {"description": "裂土器版本", "name": "receiver", "namespace": "Method", "path": "Method#receiver", "type": "instance_method", "visibility": "public"}, "Method#source_location": {"description": "返回超类的方法，使用super时将调用该方法；如果超类上没有方法，则返回nil。", "name": "source_location", "namespace": "Method", "path": "Method#source_location", "type": "instance_method", "visibility": "public"}, "Method#super_method": {"description": "返回与此方法对应的<code>Proc</code>对象。", "name": "super_method", "namespace": "Method", "path": "Method#super_method", "type": "instance_method", "visibility": "public"}, "Method#to_proc": {"description": "使用指定的参数调用<i>meth，返回方法的返回值。n \n   m = 12.method(\"+\")\n   m.call(3)    #=> 15\n   m.call(20)   #=> 32", "name": "to_proc", "namespace": "Method", "path": "Method#to_proc", "type": "instance_method", "visibility": "public"}, "Method#to_s": {"description": "返回基础方法的名称。\\n n   \"cat\".method(:count).inspect   #=> \"#<Method: String#count>\"", "name": "to_s", "namespace": "Method", "path": "Method#to_s", "type": "instance_method", "visibility": "public"}, "Method#unbind": {"description": "返回一个方法接受的参数数目的指示。为采用固定参数个数的方法返回非负整数。对于接受可变数量参数的Ruby方法，返回-n-1，其中n是所需参数的数量。\\n关键字参数将被视为单个附加参数，如果任何关键字参数是必需的，则该参数是必需的。\\n对于用C编写的方法，如果调用采用的参数数目可变，则返回-1。n \n   class C\n     def one;    end\n     def two(a); end\n     def three(*a);  end\n     def four(a, b); end\n     def five(a, b, *c);    end\n     def six(a, b, *c, &d); end\n     def seven(a, b, x:0); end\n     def eight(x:, y:); end\n     def nine(x:, y:, **z); end\n     def ten(*a, x:, y:); end\n   end\n   c = C.new\n   c.method(:one).arity     #=> 0\n   c.method(:two).arity     #=> 1\n   c.method(:three).arity   #=> -1\n   c.method(:four).arity    #=> 2\n   c.method(:five).arity    #=> -3\n   c.method(:six).arity     #=> -3\n   c.method(:seven).arity   #=> -3\n   c.method(:eight).arity   #=> 1\n   c.method(:nine).arity    #=> 1\n   c.method(:ten).arity     #=> -2\n\n   \"cat\".method(:size).arity      #=> 0\n   \"cat\".method(:replace).arity   #=> 1\n   \"cat\".method(:squeeze).arity   #=> -1\n   \"cat\".method(:count).arity     #=> -1", "name": "unbind", "namespace": "Method", "path": "Method#unbind", "type": "instance_method", "visibility": "public"}, "UnboundMethod": {"description": "使用指定的参数调用<i>meth，返回方法的返回值。n \n   m = 12.method(\"+\")\n   m.call(3)    #=> 15\n   m.call(20)   #=> 32", "name": "UnboundMethod", "namespace": "", "path": "UnboundMethod", "type": "class", "visibility": "public"}, "UnboundMethod#==": {"description": "返回基础方法的名称。\\n n   \"cat\".method(:count).inspect   #=> \"#<Method: String#count>\"", "name": "==", "namespace": "UnboundMethod", "path": "UnboundMethod#==", "type": "instance_method", "visibility": "public"}, "UnboundMethod#arity": {"description": "返回基于方法的curried过程。当使用低于方法arity的多个参数调用proc时，将返回另一个curried proc。\\n只有在提供了足够的参数以满足方法签名时，才会实际调用该方法。\\n \\n当使用变量参数当前方法以确定在调用方法之前需要多少参数时，应提供可选的<i>arity->argument。n \n   def foo(a,b,c)\n     [a, b, c]\n   end\n\n   proc  = self.method(:foo).curry\n   proc2 = proc.call(1, 2)          #=> #<Proc>\n   proc2.call(3)                    #=> [1,2,3]\n\n   def vararg(*args)\n     args\n   end\n\n   proc = self.method(:vararg).curry(4)\n   proc2 = proc.call(:x)      #=> #<Proc>\n   proc3 = proc2.call(:y, :z) #=> #<Proc>\n   proc3.call(:a)             #=> [:x, :y, :z, :a]", "name": "arity", "namespace": "UnboundMethod", "path": "UnboundMethod#arity", "type": "instance_method", "visibility": "public"}, "UnboundMethod#bind": {"description": "如果两个方法对象绑定到同一对象并引用同一方法定义，并且它们的所有者是同一类或模块，则两个方法对象是相等的。", "name": "bind", "namespace": "UnboundMethod", "path": "UnboundMethod#bind", "type": "instance_method", "visibility": "public"}, "UnboundMethod#clone": {"description": "返回与方法对象对应的哈希值。\\n \\n另请参阅对象哈希。", "name": "clone", "namespace": "UnboundMethod", "path": "UnboundMethod#clone", "type": "instance_method", "visibility": "public"}, "UnboundMethod#eql?": {"description": "返回基础方法的名称。\\n n   \"cat\".method(:count).inspect   #=> \"#<Method: String#count>\"", "name": "eql?", "namespace": "UnboundMethod", "path": "UnboundMethod#eql?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "UnboundMethod#hash": {"description": "返回方法的名称。", "name": "hash", "namespace": "UnboundMethod", "path": "UnboundMethod#hash", "type": "instance_method", "visibility": "public"}, "UnboundMethod#inspect": {"description": "返回基础方法的名称。\\n n   \"cat\".method(:count).inspect   #=> \"#<Method: String#count>\"", "name": "inspect", "namespace": "UnboundMethod", "path": "UnboundMethod#inspect", "type": "instance_method", "visibility": "public"}, "UnboundMethod#name": {"description": "返回定义方法的类或模块。", "name": "name", "namespace": "UnboundMethod", "path": "UnboundMethod#name", "type": "instance_method", "visibility": "public"}, "UnboundMethod#original_name": {"description": "返回此方法的参数信息。n \n   def foo(bar); end\n   method(:foo).parameters #=> [[:req, :bar]]\n\n   def foo(bar, baz, bat, &blk); end\n   method(:foo).parameters #=> [[:req, :bar], [:req, :baz], [:req, :bat], [:block, :blk]]\n\n   def foo(bar, *args); end\n   method(:foo).parameters #=> [[:req, :bar], [:rest, :args]]\n\n   def foo(bar, baz, *args, &blk); end\n   method(:foo).parameters #=> [[:req, :bar], [:req, :baz], [:rest, :args], [:block, :blk]]", "name": "original_name", "namespace": "UnboundMethod", "path": "UnboundMethod#original_name", "type": "instance_method", "visibility": "public"}, "UnboundMethod#owner": {"description": "返回方法对象的绑定接收器。", "name": "owner", "namespace": "UnboundMethod", "path": "UnboundMethod#owner", "type": "instance_method", "visibility": "public"}, "UnboundMethod#parameters": {"description": "返回包含此方法的Ruby源文件名和行号，如果此方法未在Ruby（即Native）中定义，则返回nil。", "name": "parameters", "namespace": "UnboundMethod", "path": "UnboundMethod#parameters", "type": "instance_method", "visibility": "public"}, "UnboundMethod#source_location": {"description": "返回超类的方法，使用super时将调用该方法；如果超类上没有方法，则返回nil。", "name": "source_location", "namespace": "UnboundMethod", "path": "UnboundMethod#source_location", "type": "instance_method", "visibility": "public"}, "UnboundMethod#super_method": {"description": "返回与此方法对应的<code>Proc</code>对象。", "name": "super_method", "namespace": "UnboundMethod", "path": "UnboundMethod#super_method", "type": "instance_method", "visibility": "public"}, "UnboundMethod#to_s": {"description": "返回基础方法的名称。\\n n   \"cat\".method(:count).inspect   #=> \"#<Method: String#count>\"", "name": "to_s", "namespace": "UnboundMethod", "path": "UnboundMethod#to_s", "type": "instance_method", "visibility": "public"}, "LocalJumpError": {"description": "从其当前接收器中分离出<i>Meth。结果<code>UnboundMethod</code>随后可以绑定到同一类的新对象（请参见<code>UnboundMethod</code>）。", "name": "LocalJumpError", "namespace": "", "path": "LocalJumpError", "type": "class", "visibility": "public"}, "LocalJumpError#exit_value": {"description": "*******************************************************************\\n\\n \n  Ruby supports two forms of objectified methods. Class\n  <code>Method</code> is used to represent methods that are associated\n  with a particular object: these method objects are bound to that\n  object. Bound method objects for an object can be created using\n  <code>Object#method</code>.\n\n  Ruby also supports unbound methods; methods objects that are not\n  associated with a particular object. These can be created either by\n  calling <code>Module#instance_method</code> or by calling\n  <code>unbind</code> on a bound method object. The result of both of\n  these is an <code>UnboundMethod</code> object.\n\n  Unbound methods can only be called after they are bound to an\n  object. That object must be a kind_of? the method's original\n  class.\n\n     class Square\n       def area\n         @side * @side\n       end\n       def initialize(side)\n         @side = side\n       end\n     end\n\n     area_un = Square.instance_method(:area)\n\n     s = Square.new(12)\n     area = area_un.bind(s)\n     area.call   #=> 144\n\n  Unbound methods are a reference to the method at the time it was\n  objectified: subsequent changes to the underlying class will not\n  affect the unbound method.\n\n     class Test\n       def test\n         :original\n       end\n     end\n     um = Test.instance_method(:test)\n     class Test\n       def test\n         :modified\n       end\n     end\n     t = Test.new\n     t.test            #=> :modified\n     um.bind(t).call   #=> :original", "name": "exit_value", "namespace": "LocalJumpError", "path": "LocalJumpError#exit_value", "type": "instance_method", "visibility": "public"}, "LocalJumpError#reason": {"description": "如果两个方法对象绑定到同一对象并引用同一方法定义，并且它们的所有者是同一类或模块，则两个方法对象是相等的。", "name": "reason", "namespace": "LocalJumpError", "path": "LocalJumpError#reason", "type": "instance_method", "visibility": "public"}, "SystemStackError": {"description": "返回一个方法接受的参数数目的指示。为采用固定参数个数的方法返回非负整数。对于接受可变数量参数的Ruby方法，返回-n-1，其中n是所需参数的数量。\\n关键字参数将被视为单个附加参数，如果任何关键字参数是必需的，则该参数是必需的。\\n对于用C编写的方法，如果调用采用的参数数目可变，则返回-1。n \n   class C\n     def one;    end\n     def two(a); end\n     def three(*a);  end\n     def four(a, b); end\n     def five(a, b, *c);    end\n     def six(a, b, *c, &d); end\n     def seven(a, b, x:0); end\n     def eight(x:, y:); end\n     def nine(x:, y:, **z); end\n     def ten(*a, x:, y:); end\n   end\n   c = C.new\n   c.method(:one).arity     #=> 0\n   c.method(:two).arity     #=> 1\n   c.method(:three).arity   #=> -1\n   c.method(:four).arity    #=> 2\n   c.method(:five).arity    #=> -3\n   c.method(:six).arity     #=> -3\n   c.method(:seven).arity   #=> -3\n   c.method(:eight).arity   #=> 1\n   c.method(:nine).arity    #=> 1\n   c.method(:ten).arity     #=> -2\n\n   \"cat\".method(:size).arity      #=> 0\n   \"cat\".method(:replace).arity   #=> 1\n   \"cat\".method(:squeeze).arity   #=> -1\n   \"cat\".method(:count).arity     #=> -1", "name": "SystemStackError", "namespace": "", "path": "SystemStackError", "type": "class", "visibility": "public"}, "Proc": {"description": "绑定到<i>obj。如果<code>Klass</code>是从中获得<i>uMeth<i>的类，则<code>obj.kind_of?(Klass)</code>必须为真。\\n \n   class A\n     def test\n       puts \"In test, class = #{self.class}\"\n     end\n   end\n   class B < A\n   end\n   class C < B\n   end\n \\n \n   um = B.instance_method(:test)\n   bm = um.bind(C.new)\n   bm.call\n   bm = um.bind(B.new)\n   bm.call\n   bm = um.bind(A.new)\n   bm.call\n \\n<em>products:-\\n \n   In test, class = C\n   In test, class = B\n   prog.rb:16:in `bind': bind argument must be an instance of B (TypeError)\n from prog.rb:16", "name": "Proc", "namespace": "", "path": "Proc", "type": "class", "visibility": "public"}, "Proc#===": {"description": "返回此方法的克隆。n \n  class A\n    def foo\n      return \"bar\"\n    end\n  end\n\n  m = A.new.method(:foo)\n  m.call # => \"bar\"\n  n = m.clone.call # => \"bar\"", "name": "===", "namespace": "Proc", "path": "Proc#===", "type": "instance_method", "visibility": "public"}, "Proc#[]": {"description": "此块被终止的原因是：\\n:break、：redo、：retry、：next、：return或：noreason。", "name": "[]", "namespace": "Proc", "path": "Proc#[]", "type": "instance_method", "visibility": "public"}, "Proc#arity": {"description": "返回与方法对象对应的哈希值。\\n \\n另请参阅对象哈希。", "name": "arity", "namespace": "Proc", "path": "Proc#arity", "type": "instance_method", "visibility": "public"}, "Proc#binding": {"description": "返回基础方法的名称。\\n n   \"cat\".method(:count).inspect   #=> \"#<Method: String#count>\"", "name": "binding", "namespace": "Proc", "path": "Proc#binding", "type": "instance_method", "visibility": "public"}, "Proc#call": {"description": "此块被终止的原因是：\\n:break、：redo、：retry、：next、：return或：noreason。", "name": "call", "namespace": "Proc", "path": "Proc#call", "type": "instance_method", "visibility": "public"}, "Proc#clone": {"description": ":nodoc:", "name": "clone", "namespace": "Proc", "path": "Proc#clone", "type": "instance_method", "visibility": "public"}, "Proc#curry": {"description": "返回方法的原始名称。n \n  class C\n    def foo; end\n    alias bar foo\n  end\n  C.instance_method(:bar).original_name # => :foo", "name": "curry", "namespace": "Proc", "path": "Proc#curry", "type": "instance_method", "visibility": "public"}, "Proc#dup": {"description": ":nodoc:", "name": "dup", "namespace": "Proc", "path": "Proc#dup", "type": "instance_method", "visibility": "public"}, "Proc#hash": {"description": "返回定义方法的类或模块。", "name": "hash", "namespace": "Proc", "path": "Proc#hash", "type": "instance_method", "visibility": "public"}, "Proc#inspect": {"description": "返回与此+LocalJumpError+关联的退出值。", "name": "inspect", "namespace": "Proc", "path": "Proc#inspect", "type": "instance_method", "visibility": "public"}, "Proc#lambda?": {"description": "返回包含此方法的Ruby源文件名和行号，如果此方法未在Ruby（即Native）中定义，则返回nil。", "name": "lambda?", "namespace": "Proc", "path": "Proc#lambda?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Proc#parameters": {"description": "返回超类的方法，使用super时将调用该方法；如果超类上没有方法，则返回nil。", "name": "parameters", "namespace": "Proc", "path": "Proc#parameters", "type": "instance_method", "visibility": "public"}, "Proc#source_location": {"description": "返回基础方法的名称。\\n n   \"cat\".method(:count).inspect   #=> \"#<Method: String#count>\"", "name": "source_location", "namespace": "Proc", "path": "Proc#source_location", "type": "instance_method", "visibility": "public"}, "Proc#to_proc": {"description": "当Ruby无法按要求生成时引发。\\n \\n当没有给出任何块时，典型的方案正试图产生以下结果：\\n \n   def call_block\n     yield 42\n   end\n   call_block\n \\n<em>raises the exception:-\\n \n   LocalJumpError: no block given (yield)\n \\n a more minute example:\\n \n   def get_me_a_return\n     Proc.new { return 42 }\n   end\n   get_me_a_return.call\n \\n<em>raises the exception:-\\n \\n LocalJumpError:unexpected return", "name": "to_proc", "namespace": "Proc", "path": "Proc#to_proc", "type": "instance_method", "visibility": "public"}, "Proc#to_s": {"description": "返回与此+LocalJumpError+关联的退出值。", "name": "inspect", "namespace": "Proc", "path": "Proc#inspect", "type": "instance_method", "visibility": "public"}, "Proc#yield": {"description": "此块被终止的原因是：\\n:break、：redo、：retry、：next、：return或：noreason。", "name": "yield", "namespace": "Proc", "path": "Proc#yield", "type": "instance_method", "visibility": "public"}, "Proc.new": {"description": "在堆栈溢出时引发。\\n \n   def me_myself_and_i\n     me_myself_and_i\n   end\n   me_myself_and_i\n \\n<em>引发异常：</em>\\n\\n SystemStackError:堆栈级别太深", "name": "new", "namespace": "Proc", "path": "Proc.new", "type": "class_method", "visibility": "public"}, "Binding": {"description": "<code>Proc</code>对象是绑定到一组局部变量的代码块。一旦绑定，代码就可以在不同的上下文中被调用，并且仍然可以访问这些变量。n \n   def gen_times(factor)\n     return Proc.new {|n| n*factor }\n   end\n\n   times3 = gen_times(3)\n   times5 = gen_times(5)\n\n   times3.call(12)               #=> 36\n   times5.call(5)                #=> 25\n   times3.call(times5.call(4))   #=> 60", "name": "Binding", "namespace": "", "path": "Binding", "type": "class", "visibility": "public"}, "Binding#clone": {"description": ":nodoc:", "name": "clone", "namespace": "Binding", "path": "Binding#clone", "type": "instance_method", "visibility": "public"}, "Binding#dup": {"description": ":nodoc:", "name": "dup", "namespace": "Binding", "path": "Binding#dup", "type": "instance_method", "visibility": "public"}, "Binding#eval": {"description": "call seq:\n   proc === obj   -> result_of_proc\n \\n使用+obj+作为proc的参数（如proc call）调用块。它允许proc对象成为case语句中+when+子句的目标。", "name": "eval", "namespace": "Binding", "path": "Binding#eval", "type": "instance_method", "visibility": "public"}, "Binding#local_variable_defined?": {"description": "call seq:\n   prc.call(params,...)   -> obj\n   prc[params,...]        -> obj\n   prc.(params,...)       -> obj\n   prc.yield(params,...)  -> obj\n \\n调用块，使用something close to method calling semantics将块的参数设置为\\n<i>params<i>中的值。\\n返回块中最后一个计算表达式的值。\\n \n   a_proc = Proc.new {|scalar, *values| values.map {|value| value*scalar } }\n   a_proc.call(9, 1, 2, 3)    #=> [9, 18, 27]\n   a_proc[9, 1, 2, 3]         #=> [9, 18, 27]\n   a_proc.(9, 1, 2, 3)        #=> [9, 18, 27]\n   a_proc.yield(9, 1, 2, 3)   #=> [9, 18, 27]\n \\n请注意，<code>prc.()</code>使用给定的参数调用<code>prc.call()</code>。隐藏“call”是句法上的甜言蜜语。\\n \\n对于使用<code>lambda</code>或<code>->()</code>创建的过程，如果传递给过程的参数数目错误，则会生成错误。\\n对于使用<code>Proc.new</code>或<code>Kernel.proc</code>创建的进程，将自动放弃额外参数，并将缺少的参数设置为+nil+。\\n \n   a_proc = proc {|a,b| [a,b] }\n   a_proc.call(1)   #=> [1, nil]\n\n   a_proc = lambda {|a,b| [a,b] }\n   a_proc.call(1)   # ArgumentError: wrong number of arguments (given 1, expected 2)\n \\n另见proc lambda？.", "name": "local_variable_defined?", "namespace": "Binding", "path": "Binding#local_variable_defined?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Binding#local_variable_get": {"description": "返回强制参数的数目。如果块声明为不带参数，则返回0。如果已知块正好接受n个参数，则返回n。\\n如果块具有可选参数，则返回-n-1，其中n是强制参数的数目，但不属于lambda且只有有限个可选arguments;的块除外。在后一种情况下，返回n。\\n关键字参数将被视为single附加参数\\n如果任何关键字参数是必需的，则该参数是必需的。\\n没有参数声明的<code>proc</code>与将<code>||</code>声明为其参数的块相同。n \n   proc {}.arity                  #=>  0\n   proc { || }.arity              #=>  0\n   proc { |a| }.arity             #=>  1\n   proc { |a, b| }.arity          #=>  2\n   proc { |a, b, c| }.arity       #=>  3\n   proc { |*a| }.arity            #=> -1\n   proc { |a, *b| }.arity         #=> -2\n   proc { |a, *b, c| }.arity      #=> -3\n   proc { |x:, y:, z:0| }.arity   #=>  1\n   proc { |*a, x:, y:0| }.arity   #=> -2\n\n   proc   { |a=0| }.arity         #=>  0\n   lambda { |a=0| }.arity         #=> -1\n   proc   { |a=0, b| }.arity      #=>  1\n   lambda { |a=0, b| }.arity      #=> -2\n   proc   { |a=0, b=0| }.arity    #=>  0\n   lambda { |a=0, b=0| }.arity    #=> -1\n   proc   { |a, b=0| }.arity      #=>  1\n   lambda { |a, b=0| }.arity      #=> -2\n   proc   { |(a, b), c=0| }.arity #=>  1\n   lambda { |(a, b), c=0| }.arity #=> -2\n   proc   { |a, x:0, y:0| }.arity #=>  1\n   lambda { |a, x:0, y:0| }.arity #=> -2", "name": "local_variable_get", "namespace": "Binding", "path": "Binding#local_variable_get", "type": "instance_method", "visibility": "public"}, "Binding#local_variable_set": {"description": "返回与<i>prc<i>关联的绑定。注意<code>Kernel#eval</code>接受<code>Proc</code>或<code>Binding</code>对象作为其第二个参数。n \n   def fred(param)\n     proc {}\n   end\n\n   b = fred(99)\n   eval(\"param\", b.binding)   #=> 99", "name": "local_variable_set", "namespace": "Binding", "path": "Binding#local_variable_set", "type": "instance_method", "visibility": "public"}, "Binding#local_variables": {"description": "call seq:\n   prc.call(params,...)   -> obj\n   prc[params,...]        -> obj\n   prc.(params,...)       -> obj\n   prc.yield(params,...)  -> obj\n \\n调用块，使用something close to method calling semantics将块的参数设置为\\n<i>params<i>中的值。\\n返回块中最后一个计算表达式的值。\\n \n   a_proc = Proc.new {|scalar, *values| values.map {|value| value*scalar } }\n   a_proc.call(9, 1, 2, 3)    #=> [9, 18, 27]\n   a_proc[9, 1, 2, 3]         #=> [9, 18, 27]\n   a_proc.(9, 1, 2, 3)        #=> [9, 18, 27]\n   a_proc.yield(9, 1, 2, 3)   #=> [9, 18, 27]\n \\n请注意，<code>prc.()</code>使用给定的参数调用<code>prc.call()</code>。隐藏“call”是句法上的甜言蜜语。\\n \\n对于使用<code>lambda</code>或<code>->()</code>创建的进程，如果传递给进程的参数数目错误，则会生成错误。\\n对于使用<code>Proc.new</code>或<code>Kernel.proc</code>创建的进程，将自动放弃额外参数，并将缺少的参数设置为+nil+。\\n \n   a_proc = proc {|a,b| [a,b] }\n   a_proc.call(1)   #=> [1, nil]\n\n   a_proc = lambda {|a,b| [a,b] }\n   a_proc.call(1)   # ArgumentError: wrong number of arguments (given 1, expected 2)\n \\n另见proc lambda？.", "name": "local_variables", "namespace": "Binding", "path": "Binding#local_variables", "type": "instance_method", "visibility": "public"}, "Binding#receiver": {"description": "返回一个过程。如果给定了可选的<i>arity->i>参数，它将确定参数的数目。\\n curried proc接收一些参数。如果提供了足够数量的参数，它会将提供的参数传递给原始过程并返回结果。否则，返回另一个接受其余参数的curried过程。n \n   b = proc {|x, y, z| (x||0) + (y||0) + (z||0) }\n   p b.curry[1][2][3]           #=> 6\n   p b.curry[1, 2][3, 4]        #=> 6\n   p b.curry(5)[1][2][3][4][5]  #=> 6\n   p b.curry(5)[1, 2][3, 4][5]  #=> 6\n   p b.curry(1)[1]              #=> 1\n\n   b = proc {|x, y, z, *w| (x||0) + (y||0) + (z||0) + w.inject(0, &:+) }\n   p b.curry[1][2][3]           #=> 6\n   p b.curry[1, 2][3, 4]        #=> 10\n   p b.curry(5)[1][2][3][4][5]  #=> 15\n   p b.curry(5)[1, 2][3, 4][5]  #=> 15\n   p b.curry(1)[1]              #=> 1\n\n   b = lambda {|x, y, z| (x||0) + (y||0) + (z||0) }\n   p b.curry[1][2][3]           #=> 6\n   p b.curry[1, 2][3, 4]        #=> wrong number of arguments (given 4, expected 3)\n   p b.curry(5)                 #=> wrong number of arguments (given 5, expected 3)\n   p b.curry(1)                 #=> wrong number of arguments (given 1, expected 3)\n\n   b = lambda {|x, y, z, *w| (x||0) + (y||0) + (z||0) + w.inject(0, &:+) }\n   p b.curry[1][2][3]           #=> 6\n   p b.curry[1, 2][3, 4]        #=> 10\n   p b.curry(5)[1][2][3][4][5]  #=> 15\n   p b.curry(5)[1, 2][3, 4][5]  #=> 15\n   p b.curry(1)                 #=> wrong number of arguments (given 1, expected 3)\n\n   b = proc { :foo }\n   p b.curry[]                  #=> :foo", "name": "receiver", "namespace": "Binding", "path": "Binding#receiver", "type": "instance_method", "visibility": "public"}, "Random": {"description": "返回与进程主体相对应的哈希值。\\n \\n另请参阅对象哈希。", "name": "Random", "namespace": "", "path": "Random", "type": "class", "visibility": "public"}, "Random#==": {"description": "返回此进程的唯一标识符，并指示该进程的定义位置。", "name": "==", "namespace": "Random", "path": "Random#==", "type": "instance_method", "visibility": "public"}, "Random#bytes": {"description": "为参数处理严格的proc对象返回+true+。\\n此类进程通常由+lambda+生成。\\n \\n +proc+生成的proc对象忽略额外参数。\\n \n  proc {|a,b| [a,b] }.call(1,2,3)    #=> [1,2]\n \\n它为缺少的参数提供+nil+。\\n \n  proc {|a,b| [a,b] }.call(1)        #=> [1,nil]\n \\n它展开单个数组参数。\\n \n  proc {|a,b| [a,b] }.call([1,2])    #=> [1,2]\n \\n +lambda+生成的proc对象没有此类技巧。\\n \n  lambda {|a,b| [a,b] }.call(1,2,3)  #=> ArgumentError\n  lambda {|a,b| [a,b] }.call(1)      #=> ArgumentError\n  lambda {|a,b| [a,b] }.call([1,2])  #=> ArgumentError\n \\n proc lambda？是技巧的谓词。\\n如果不应用任何技巧，则返回+true+。\\n \n  lambda {}.lambda?            #=> true\n  proc {}.lambda?              #=> false\n \\n Proc.new与+proc+相同。\\n \n  Proc.new {}.lambda?          #=> false\n \\n +lambda+、+proc+和Proc.new保留<code>&</code>参数给定的proc对象的技巧。\\n \n  lambda(&lambda {}).lambda?   #=> true\n  proc(&lambda {}).lambda?     #=> true\n  Proc.new(&lambda {}).lambda? #=> true\n\n  lambda(&proc {}).lambda?     #=> false\n  proc(&proc {}).lambda?       #=> false\n  Proc.new(&proc {}).lambda?   #=> false\n \\n <code>&</code>自变量产生的proc物件具有tricks \n  def n(&b) b.lambda? end\n  n {}                         #=> false\n \\n <code>&</code>自变量保留由<code>&</code>自变量产生的proc物件的tricks。\\n \n  n(&lambda {})                #=> true\n  n(&proc {})                  #=> false\n  n(&Proc.new {})              #=> false\n \\n从方法转换的proc对象没有技巧。\\n \n  def m() end\n  method(:m).to_proc.lambda?   #=> true\n\n  n(&method(:m))               #=> true\n  n(&method(:m).to_proc)       #=> true\n \\n +define_method+被视为与方法定义相同。\\n defined方法没有技巧。\\n \n  class C\n    define_method(:d) {}\n  end\n  C.new.d(1,2)       #=> ArgumentError\n  C.new.method(:d).to_proc.lambda?   #=> true\n \\n +define_method+总是定义没有技巧的方法，即使给定了非lambda proc对象。\\n这是唯一不保留技巧的例外。\\n \n  class C\n    define_method(:e, &proc {})\n  end\n  C.new.e(1,2)       #=> ArgumentError\n  C.new.method(:e).to_proc.lambda?   #=> true\n \\n此异常确保方法从不具有技巧，并使包装器很容易定义行为正常的方法。\\n \n  class C\n    def self.def2(name, &body)\n      define_method(name, &body)\n    end\n\n    def2(:f) {}\n  end\n  C.new.f(1,2)       #=> ArgumentError\n \\n wrapper<i>def2</i>定义了一个没有技巧的方法。", "name": "bytes", "namespace": "Random", "path": "Random#bytes", "type": "instance_method", "visibility": "public"}, "Random#initialize": {"description": "返回此过程的参数信息。n \n   prc = lambda{|x, y=42, *other|}\n   prc.parameters  #=> [[:req, :x], [:opt, :y], [:rest, :other]]", "name": "initialize", "namespace": "Random", "path": "Random#initialize", "type": "instance_method", "visibility": "public"}, "Random#initialize_copy": {"description": ":nodoc:", "name": "initialize_copy", "namespace": "Random", "path": "Random#initialize_copy", "type": "instance_method", "visibility": "public"}, "Random#left": {"description": ":nodoc:", "name": "left", "namespace": "Random", "path": "Random#left", "type": "instance_method", "visibility": "private"}, "Random#marshal_dump": {"description": ":nodoc:", "name": "marshal_dump", "namespace": "Random", "path": "Random#marshal_dump", "type": "instance_method", "visibility": "private"}, "Random#marshal_load": {"description": ":nodoc:", "name": "marshal_load", "namespace": "Random", "path": "Random#marshal_load", "type": "instance_method", "visibility": "private"}, "Random#rand": {"description": "返回包含此过程的Ruby源文件名和行号，如果此过程未在Ruby中定义（即本机），则返回+nil+。", "name": "rand", "namespace": "Random", "path": "Random#rand", "type": "instance_method", "visibility": "public"}, "Random#seed": {"description": "协议的一部分，用于将对象转换为<code>Proc</code>对象。类<code>Proc</code>的实例只返回自身。", "name": "seed", "namespace": "Random", "path": "Random#seed", "type": "instance_method", "visibility": "public"}, "Random#state": {"description": ":nodoc:", "name": "state", "namespace": "Random", "path": "Random#state", "type": "instance_method", "visibility": "private"}, "Random.new_seed": {"description": "返回此进程的唯一标识符，并指示该进程的定义位置。", "name": "new_seed", "namespace": "Random", "path": "Random.new_seed", "type": "class_method", "visibility": "public"}, "Random.rand": {"description": "call seq:\n   prc.call(params,...)   -> obj\n   prc[params,...]        -> obj\n   prc.(params,...)       -> obj\n   prc.yield(params,...)  -> obj\n \\n调用块，使用something close to method calling semantics将块的参数设置为\\n<i>params<i>中的值。\\n返回块中最后一个计算表达式的值。\\n \n   a_proc = Proc.new {|scalar, *values| values.map {|value| value*scalar } }\n   a_proc.call(9, 1, 2, 3)    #=> [9, 18, 27]\n   a_proc[9, 1, 2, 3]         #=> [9, 18, 27]\n   a_proc.(9, 1, 2, 3)        #=> [9, 18, 27]\n   a_proc.yield(9, 1, 2, 3)   #=> [9, 18, 27]\n \\n请注意，<code>prc.()</code>使用给定的参数调用<code>prc.call()</code>。隐藏“call”是句法上的甜言蜜语。\\n \\n对于使用<code>lambda</code>或<code>->()</code>创建的进程，如果传递给进程的参数数目错误，则会生成错误。\\n对于使用<code>Proc.new</code>或<code>Kernel.proc</code>创建的进程，将自动放弃额外参数，并将缺少的参数设置为+nil+。\\n \n   a_proc = proc {|a,b| [a,b] }\n   a_proc.call(1)   #=> [1, nil]\n\n   a_proc = lambda {|a,b| [a,b] }\n   a_proc.call(1)   # ArgumentError: wrong number of arguments (given 1, expected 2)\n \\n另见proc lambda？.", "name": "rand", "namespace": "Random", "path": "Random.rand", "type": "class_method", "visibility": "public"}, "Random.srand": {"description": "创建绑定到当前上下文的新<code>Proc</code>对象。<code>Proc::new</code>只能在具有附加块的方法中调用而不调用块，在这种情况下，该块将转换为<code>Proc</code>对象。n \n   def proc_from\n     Proc.new\n   end\n   proc = proc_from { \"hello\" }\n   proc.call   #=> \"hello\"", "name": "srand", "namespace": "Random", "path": "Random.srand", "type": "class_method", "visibility": "public"}, "Random.urandom": {"description": "类<code>Binding</code>的对象在代码中的某个特定位置封装执行上下文，并保留此上下文以供将来使用。变量、方法、值<code>self</code>、\\n以及在此上下文中可以访问的迭代器块都被保留。绑定对象可以使用<code>Kernel#binding</code>创建，并可用于<code>Kernel#set_trace_func</code>的回调。\\n \\n这些绑定对象可以作为<code>Kernel#eval</code>方法的第二个参数传递，从而为计算建立环境。\\n \n   class Demo\n     def initialize(n)\n       @secret = n\n     end\n     def get_binding\n       binding\n     end\n   end\n\n   k1 = Demo.new(99)\n   b1 = k1.get_binding\n   k2 = Demo.new(-3)\n   b2 = k2.get_binding\n\n   eval(\"@secret\", b1)   #=> 99\n   eval(\"@secret\", b2)   #=> -3\n   eval(\"@secret\")       #=> nil\n \\n绑定对象没有类特定的方法。", "name": "urandom", "namespace": "Random", "path": "Random.urandom", "type": "class_method", "visibility": "public"}, "Random::DEFAULT": {"description": "", "name": "DEFAULT", "namespace": "Random", "path": "Random::DEFAULT", "type": "constant", "return": ["Random", ""], "visibility": "public"}, "Random::Formatter": {"description": "", "name": "Formatter", "namespace": "Random", "path": "Random::Formatter", "type": "module", "visibility": "public"}, "Random::Formatter#rand": {"description": "", "name": "rand", "namespace": "Random::Formatter", "path": "Random::Formatter#rand", "type": "module_function", "visibility": "public"}, "Random::Formatter#random_number": {"description": "", "name": "random_number", "namespace": "Random::Formatter", "path": "Random::Formatter#random_number", "type": "module_function", "visibility": "public"}, "Range": {"description": "计算<em>string中的ruby表达式，该表达式位于\\n<em>binding的上下文中。如果存在可选的<em>filename<em>和\\n<em>lineno<em>参数，则在报告语法错误时将使用这些参数。n \n   def get_binding(param)\n     binding\n   end\n   b = get_binding(\"hello\")\n   b.eval(\"param\")   #=> \"hello\"", "name": "Range", "namespace": "", "path": "Range", "type": "class", "visibility": "public"}, "Range#==": {"description": "如果存在局部变量+symbol+，则返回+true+。\\n \\n def foo \\n a=1 \\n \t  binding.local_variable_defined?(:a) #=> true \\n \t  binding.local_variable_defined?(:b) #=> false \\n end \\n \\n此方法是以下代码的简短版本：\\n \\n binding.eval（“defined”？（{symbol}）='局部变量''''）", "name": "==", "namespace": "Range", "path": "Range#==", "type": "instance_method", "visibility": "public"}, "Range#===": {"description": "返回局部变量+symbol+的值。\\n \\n def foo \\n a=1 \\n \t  binding.local_variable_get(:a) #=> 1 \\n \t  binding.local_variable_get(:b) #=> NameError \\n end \\n \\n此方法是以下代码的简短版本：\\n \\n binding.eval（“{symbol}”）", "name": "===", "namespace": "Range", "path": "Range#===", "type": "instance_method", "visibility": "public"}, "Range#begin": {"description": "将名为+symbol+的局部变量设置为+obj+。\\n \\n def foo \\n a=1 \\n bind=binding \\n bind.local_variable_set（：a，2）set existing local variable'a'\\n bind.local_variable_set（：b，3）create new local variable'b'\\n'b'只存在于binding中\\n \\n \t  p bind.local_variable_get(:a)  #=> 2 \\n \t  p bind.local_variable_get(:b)  #=> 3 \\n \t  p a                            #=> 2 \\n \t  p b                            #=> NameError \\n end \\n \\n此方法的行为类似于以下代码：\\n \n  binding.eval(\"#{symbol} = #{obj}\")\n \\n如果+obj+可以转储到Ruby代码中。", "name": "begin", "namespace": "Range", "path": "Range#begin", "type": "instance_method", "visibility": "public"}, "Range#bsearch": {"description": "以符号形式返回绑定的局部变量的名称。\\n \\n def foo \\n a=1 \\n 2.times do n \\n \t    binding.local_variables #=> [:a, :n] \\n end \\n end \\n \\n此方法是以下代码的简短版本：\\n \\n binding.eval（“本地变量”）。", "name": "bsearch", "namespace": "Range", "path": "Range#bsearch", "type": "instance_method", "visibility": "public"}, "Range#cover?": {"description": "返回绑定对象的绑定接收器。", "name": "cover?", "namespace": "Range", "path": "Range#cover?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Range#each": {"description": "Random提供了一个到Ruby的伪随机数生成器（即PRNG）的接口。PRNG产生一个确定的位序列，近似于真正的随机性。序列可以用整数、浮点数或二进制字符串表示。\\n \\n可以使用系统生成的种子值或用户提供的种子值使用random.srand初始化生成器。\\n \\n class方法Random.rand提供Kernel.rand的基本功能，以及更好地处理浮点值。这些都是Random:：DEFAULT和Ruby系统PRNG的接口。\\n \\n Random.new将创建一个新的PRNG，其状态独立于random:：DEFAULT，允许同时存在具有不同种子值或序列位置的多个生成器。可以对随机对象进行编组，从而允许保存和恢复序列。\\n \\n PRNGS目前是以2**19937-1周期的改良型Mersenne捻线机来实现的。", "name": "each", "namespace": "Range", "path": "Range#each", "type": "instance_method", "visibility": "public"}, "Range#end": {"description": "如果两个生成器具有相同的内部状态，则返回true，否则返回false。等效生成器将返回相同的伪随机数序列。只有使用相同的种子\n  Random.new == Random.new             # => false\n  Random.new(1234) == Random.new(1234) # => true\n \\n进行初始化并且具有相同的调用历史记录时，两个生成器通常具有相同的状态。\\n \n  prng1 = Random.new(1234)\n  prng2 = Random.new(1234)\n  prng1 == prng2 # => true\n\n  prng1.rand     # => 0.1915194503788923\n  prng1 == prng2 # => false\n\n  prng2.rand     # => 0.1915194503788923\n  prng1 == prng2 # => true", "name": "end", "namespace": "Range", "path": "Range#end", "type": "instance_method", "visibility": "public"}, "Range#eql?": {"description": "返回包含+size+字节的随机二进制字符串。\\n \n  random_string = Random.new.bytes(10) # => \"\\xD7:R\\xAB?\\x83\\xCE\\xFAkO\"\n  random_string.size                   # => 10", "name": "eql?", "namespace": "Range", "path": "Range#eql?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Range#exclude_end?": {"description": "使用+seed+创建新的PRNG以设置初始状态。如果省略+seed+，则使用random.new_seed初始化生成器。\\n \\n有关使用种子值的详细信息，请参阅Random.srand。", "name": "exclude_end?", "namespace": "Range", "path": "Range#exclude_end?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Range#first": {"description": "当+max+是整数时，+rand+返回大于\\n或等于零且小于+max+的随机整数。与kernel.rand不同，当+max+ \\n为负整数或零时，+rand+将引发ArgumentError。\\n \n  prng = Random.new\n  prng.rand(100)       # => 42\n \\n当+max+是浮点数时，+rand+返回介于0.0和+max+之间的随机浮点数，包括0.0和不包括+max+。\\n \n  prng.rand(1.5)       # => 1.4600282860034115\n \\n当+max+是范围时，+rand+返回随机数range.member？（数字）==真。\\n \n  prng.rand(5..9)      # => one of [5, 6, 7, 8, 9]\n  prng.rand(5...9)     # => one of [5, 6, 7, 8]\n  prng.rand(5.0..9.0)  # => between 5.0 and 9.0, including 9.0\n  prng.rand(5.0...9.0) # => between 5.0 and 9.0, excluding 9.0\n \\n范围的开始值和结束值都必须响应于Subtract \\n（<tt>>-<tt>）和Add（<tt>>+<tt>）方法，或Rand将提升一个\\n ArgumentError。", "name": "first", "namespace": "Range", "path": "Range#first", "type": "instance_method", "visibility": "public"}, "Range#hash": {"description": "返回用于初始化生成器的种子值。这可用于在以后初始化具有相同状态的另一个生成器，使其产生相同的数字序列。\\n \n  prng1 = Random.new(1234)\n  prng1.seed       #=> 1234\n  prng1.rand(100)  #=> 47\n\n  prng2 = Random.new(prng1.seed)\n  prng2.rand(100)  #=> 47", "name": "hash", "namespace": "Range", "path": "Range#hash", "type": "instance_method", "visibility": "public"}, "Range#include?": {"description": "仅当+obj+是一个范围、具有等效的开始和结束项（通过将它们与<code>==</code>进行比较）并且具有相同的排除结束时返回<code>true</code>？设置为范围。n \n  (0..2) == (0..2)            #=> true\n  (0..2) == Range.new(0,2)    #=> true\n  (0..2) == (0...2)           #=> false", "name": "include?", "namespace": "Range", "path": "Range#include?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Range#initialize": {"description": "Random的别名：DEFAULT.rand。", "name": "initialize", "namespace": "Range", "path": "Range#initialize", "type": "instance_method", "visibility": "public"}, "Range#initialize_copy": {"description": ":nodoc:", "name": "initialize_copy", "namespace": "Range", "path": "Range#initialize_copy", "type": "instance_method", "visibility": "public"}, "Range#inspect": {"description": "种子系统伪随机数发生器，随机：：DEFAULT，带+number+。返回上一个种子值。\\n \\n如果省略+number+，则使用操作系统提供的熵源（如果可用）（/dev/urandom（在UNIX系统上）或RSA Cryptographic Provider（在Windows上）为生成器种子，然后将该熵源与时间、进程ID和序列号组合在一起。\\n \\n srand可用于确保程序不同运行之间伪随机数的可重复序列。通过将种子设置为已知值，可以在测试期间使程序具有确定性。\\n \n  srand 1234               # => 268519324636777531569100071560086917274\n  [ rand, rand ]           # => [0.1915194503788923, 0.6221087710398319]\n  [ rand(10), rand(1000) ] # => [4, 664]\n  srand 1234               # => 1234\n  [ rand, rand ]           # => [0.1915194503788923, 0.6221087710398319]", "name": "inspect", "namespace": "Range", "path": "Range#inspect", "type": "instance_method", "visibility": "public"}, "Range#last": {"description": "使用提供功能的平台返回字符串。\\n返回的值应为二进制形式的加密安全伪随机数。\\n如果平台提供的功能未能准备结果，则此方法将引发RuntimeError。\\n \\n在2017年，LinuxManpage Random（7）写道：“目前没有任何加密原语可以保证超过256位的安全性。”因此，将大于32的大小传递给这个方法可能是有问题的。\\n \\n   Random.urandom(8)  #=> \"\\x78\\x41\\xBA\\xAF\\x7D\\xEA\\xD8\\xEA\"", "name": "last", "namespace": "Range", "path": "Range#last", "type": "instance_method", "visibility": "public"}, "Range#max": {"description": "<code>Range</code>表示一个间隔-一组具有开始和结束的值。范围可以使用\\n<em>s<em><code>..</code><em>e<em>和\\n<em>s<em><code>...</code><em>e<em>literals构造，或使用range:：new构造。使用<code>..</code>构造的范围\\n从头到尾（包括在内）运行。使用<code>...</code>创建的值不包括结束值。当用作迭代器时，ranges返回序列中的每个值。\\n \n   (-1..-5).to_a      #=> []\n   (-5..-1).to_a      #=> [-5, -4, -3, -2, -1]\n   ('a'..'e').to_a    #=> [\"a\", \"b\", \"c\", \"d\", \"e\"]\n   ('a'...'e').to_a   #=> [\"a\", \"b\", \"c\", \"d\"]\n \\n==范围中的自定义对象\\n \\n范围可以使用任何可以使用<code><=></code>运算符进行比较的对象构造。\\n将范围视为序列的方法（每个方法和从可枚举继承的方法）期望Begin对象实现<code>succ</code>方法以按顺序返回下一个对象。\\n步骤和包括？方法要求begin对象实现<code>succ</code>或为数字。\\n \\n在<code>Xs</code>类中，实现了<code><=></code>和<code>succ</code>之下的类，因此<code>Xs</code>可用于构造范围。请注意，可比模块包含在内，因此<code>==</code>方法是根据<code><=></code>定义的。\\n \n   class Xs                # represent a string of 'x's\n     include Comparable\n     attr :length\n     def initialize(n)\n       @length = n\n     end\n     def succ\n       Xs.new(@length + 1)\n     end\n     def <=>(other)\n       @length <=> other.length\n     end\n     def to_s\n       sprintf \"%2d #{inspect}\", @length\n     end\n     def inspect\n       'x' * @length\n     end\n   end\n \\n使用<code>Xs</code>构造范围的示例：\\n \n   r = Xs.new(3)..Xs.new(6)   #=> xxx..xxxxxx\n   r.to_a                     #=> [xxx, xxxx, xxxxx, xxxxxx]\n   r.member?(Xs.new(5))       #=> true", "name": "max", "namespace": "Range", "path": "Range#max", "type": "instance_method", "visibility": "public"}, "Range#member?": {"description": "仅当+obj+是一个范围、具有等效的开始和结束项（通过将它们与<code>==</code>进行比较）并且具有相同的排除结束时返回<code>true</code>？设置为范围。n \n  (0..2) == (0..2)            #=> true\n  (0..2) == Range.new(0,2)    #=> true\n  (0..2) == (0...2)           #=> false", "name": "member?", "namespace": "Range", "path": "Range#member?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Range#min": {"description": "如果+obj+是范围的元素，则返回<code>true</code>，否则返回<code>false</code>。<code>===</code>是<code>case</code>语句使用的比较运算符，这很方便。\\n \n   case 79\n   when 1..50   then   print \"low\\n\"\n   when 51..75  then   print \"medium\\n\"\n   when 76..100 then   print \"high\\n\"\n   end\n \\n<em>产生：.<em>\\n\\n high", "name": "min", "namespace": "Range", "path": "Range#min", "type": "instance_method", "visibility": "public"}, "Range#size": {"description": "返回定义范围开始的对象。\\n n     (1..10).begin   #=> 1", "name": "size", "namespace": "Range", "path": "Range#size", "type": "instance_method", "visibility": "public"}, "Range#step": {"description": "通过使用二进制搜索，在满足给定条件的范围内查找一个值（在O（log n）中），其中n是范围的大小。\\n \\n您可以在两个用例中使用此方法：查找最小模式和查找任意模式。在这两种情况下，范围的元素相对于块必须是单调的（或排序的）。\\n \\n在find minimum模式下（这是典型用例的一个好选择），\\n块必须返回true或false，并且必须有一个值x \\n以便：\\n \\n- 对于小于x的任何值，块返回false，并且\\n- 对于大于or\n  equal to x.\n的任何值，块返回true，如果x在范围内，则this方法返回值x。\\n否则，返回nil。\\n \n   ary = [0, 4, 7, 10, 12]\n   (0...ary.size).bsearch {|i| ary[i] >= 4 } #=> 1\n   (0...ary.size).bsearch {|i| ary[i] >= 6 } #=> 2\n   (0...ary.size).bsearch {|i| ary[i] >= 8 } #=> 3\n   (0...ary.size).bsearch {|i| ary[i] >= 100 } #=> nil\n\n   (0.0...Float::INFINITY).bsearch {|x| Math.log(x) >= 0 } #=> 1.0\n \\n在find any模式（其行为类似于libc的bsearch（3））中，块必须返回一个数字，并且必须有两个值x和y（x<=y），以便：\\n \\n- 如果v<x，块将返回v的正数，如果x<=v<y，块将返回v的零，并且\\n- 块将返回n如果y<=v，则为v的负数。\\n\\n此方法返回给定范围与x…y（如果有）的交集内的任何值。如果没有满足条件的值，则返回nil。\\n \n   ary = [0, 100, 100, 100, 200]\n   (0..4).bsearch {|i| 100 - ary[i] } #=> 1, 2 or 3\n   (0..4).bsearch {|i| 300 - ary[i] } #=> nil\n   (0..4).bsearch {|i|  50 - ary[i] } #=> nil\n \\n在time;上不能混合两种模式。块必须始终返回真/假，或始终返回数字。它未定义在每次迭代中实际获取的值。", "name": "step", "namespace": "Range", "path": "Range#step", "type": "instance_method", "visibility": "public"}, "Range#to_s": {"description": "如果+obj+在范围的开始和结束之间，则返回<code>true</code>。\\n \\n当排除结束时，此测试将测试<code>begin <= obj <= end</code>？+false+ \\n和<code>begin <= obj < end</code>在排除结束时？是+true+。n \n   (\"a\"..\"z\").cover?(\"c\")    #=> true\n   (\"a\"..\"z\").cover?(\"5\")    #=> false\n   (\"a\"..\"z\").cover?(\"cc\")   #=> true", "name": "to_s", "namespace": "Range", "path": "Range#to_s", "type": "instance_method", "visibility": "public"}, "Rational": {"description": "循环遍历range元素，依次将每个元素传递给块。\\n \\n只有当范围的Begin对象支持+succ+方法时，才能使用+each+方法。如果对象没有定义+succ+方法（如float），则引发TypeError。\\n \\n如果没有给定块，则返回枚举器。\\n \n   (10..15).each {|n| print n, ' ' }\n   # prints: 10 11 12 13 14 15\n\n   (2.5..5).each {|n| print n, ' ' }\n提升：TypeError:无法从float迭代", "name": "Rational", "namespace": "", "path": "Rational", "type": "class", "visibility": "public"}, "Rational#*": {"description": "返回定义范围结尾的对象。n \n   (1..10).end    #=> 10\n   (1...10).end   #=> 10", "name": "*", "namespace": "Rational", "path": "Rational#*", "type": "instance_method", "visibility": "public"}, "Rational#**": {"description": "仅当+obj+是一个范围、具有等效的开始和结束项（通过与<code>eql?</code>进行比较）时返回<code>true</code>，并且具有相同的“排除”结束？设置为范围。n \n  (0..2).eql?(0..2)            #=> true\n  (0..2).eql?(Range.new(0,2))  #=> true\n  (0..2).eql?(0...2)           #=> false", "name": "**", "namespace": "Rational", "path": "Rational#**", "type": "instance_method", "visibility": "public"}, "Rational#+": {"description": "如果范围不包括其结束值，则返回<code>true</code>。n \n   (1..5).exclude_end?     #=> false\n   (1...5).exclude_end?    #=> true", "name": "+", "namespace": "Rational", "path": "Rational#+", "type": "instance_method", "visibility": "public"}, "Rational#-": {"description": "返回范围中的第一个对象，或第一个+n+元素的数组。n \n  (10..20).first     #=> 10\n  (10..20).first(3)  #=> [10, 11, 12]", "name": "-", "namespace": "Rational", "path": "Rational#-", "type": "instance_method", "visibility": "public"}, "Rational#-@": {"description": "计算此范围的哈希代码。两个起始点和结束点相同的范围（使用<code>eql?</code>），相同的\\n排除诳end？值将生成相同的哈希代码。\\n \\n另请参阅对象哈希。", "name": "-@", "namespace": "Rational", "path": "Rational#-@", "type": "instance_method", "visibility": "public"}, "Rational#/": {"description": "执行加法。\\n \n   Rational(2, 3)  + Rational(2, 3)   #=> (4/3)\n   Rational(900)   + Rational(1)      #=> (901/1)\n   Rational(-2, 9) + Rational(-9, 2)  #=> (-85/18)\n   Rational(9, 8)  + 4                #=> (41/8)\n   Rational(20, 9) + 9.8              #=> 12.022222222222222", "name": "/", "namespace": "Rational", "path": "Rational#/", "type": "instance_method", "visibility": "public"}, "Rational#<=>": {"description": "使用给定的+begin+和+end+构造一个范围。如果省略+exclude_end+ \\n参数或参数为<code>false</code>，则+rng+将包含结尾object;，否则将排除该参数。", "name": "<=>", "namespace": "Rational", "path": "Rational#<=>", "type": "instance_method", "visibility": "public"}, "Rational#==": {"description": "将此范围对象转换为可打印表单（使用<code>inspect</code>转换开始和结束对象）。", "name": "==", "namespace": "Rational", "path": "Rational#==", "type": "instance_method", "visibility": "public"}, "Rational#abs": {"description": "将此范围对象转换为可打印表单（使用to诳s转换开始和结束对象）。", "name": "abs", "namespace": "Rational", "path": "Rational#abs", "type": "instance_method", "visibility": "public"}, "Rational#ceil": {"description": "返回范围内的最大值。如果范围的开始值大于结束值，则返回+nil+。如果独占范围的起始值等于结束值，则返回+nil+。\\n \\n可以指定一个可选块来重写默认比较方法<code>a <=> b</code>。\\n n   (10..20).max    #=> 20", "name": "ceil", "namespace": "Rational", "path": "Rational#ceil", "type": "instance_method", "visibility": "public"}, "Rational#coerce": {"description": ":nodoc:", "name": "coerce", "namespace": "Rational", "path": "Rational#coerce", "type": "instance_method", "visibility": "public"}, "Rational#denominator": {"description": "如果+obj+是范围的元素，则返回<code>true</code>，否则返回<code>false</code>。如果开始和结束是数字，则根据值的大小进行比较。n \n   (\"a\"..\"z\").include?(\"g\")   #=> true\n   (\"a\"..\"z\").include?(\"A\")   #=> false\n   (\"a\"..\"z\").include?(\"cc\")  #=> false", "name": "denominator", "namespace": "Rational", "path": "Rational#denominator", "type": "instance_method", "visibility": "public"}, "Rational#exact?": {"description": ":nodoc:", "name": "exact?", "namespace": "Rational", "path": "Rational#exact?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Rational#fdiv": {"description": "返回范围内的最小值。如果范围的开始值大于结束值，则返回+nil+。如果独占范围的起始值等于结束值，则返回+nil+。\\n \\n可以指定一个可选块来重写默认比较方法<code>a <=> b</code>。\\n n   (10..20).min    #=> 10", "name": "fdiv", "namespace": "Rational", "path": "Rational#fdiv", "type": "instance_method", "visibility": "public"}, "Rational#floor": {"description": "返回范围内的元素数。范围的开始和结束都必须是数字，否则返回nil。n \n  (10..20).size    #=> 11\n  ('a'..'z').size  #=> nil\n  (-Float::INFINITY..Float::INFINITY).size #=> Infinity", "name": "floor", "namespace": "Rational", "path": "Rational#floor", "type": "instance_method", "visibility": "public"}, "Rational#hash": {"description": ":nodoc:", "name": "hash", "namespace": "Rational", "path": "Rational#hash", "type": "instance_method", "visibility": "public"}, "Rational#inspect": {"description": "迭代该范围，将每个<code>n</code>th元素传递给块。\\n如果开始和结束是数字，则为每个迭代添加+n+。\\n否则，<code>step</code>调用<code>succ</code>以迭代范围元素。\\n \\n如果没有给定块，则返回枚举器。\\n \n  range = Xs.new(1)..Xs.new(10)\n  range.step(2) {|x| puts x}\n  puts\n  range.step(3) {|x| puts x}\n \\n<em>products:->em>\\n \n   1 x\n   3 xxx\n   5 xxxxx\n   7 xxxxxxx\n   9 xxxxxxxxx\n\n   1 x\n   4 xxxx\n   7 xxxxxxx\n  10 xxxxxxxxxx\n \\n see range for the definition of class xs.", "name": "inspect", "namespace": "Rational", "path": "Rational#inspect", "type": "instance_method", "visibility": "public"}, "Rational#magnitude": {"description": "将此范围对象转换为可打印表单（使用to诳s转换开始和结束对象）。", "name": "magnitude", "namespace": "Rational", "path": "Rational#magnitude", "type": "instance_method", "visibility": "public"}, "Rational#marshal_dump": {"description": ":nodoc:", "name": "marshal_dump", "namespace": "Rational", "path": "Rational#marshal_dump", "type": "instance_method", "visibility": "private"}, "Rational#negative?": {"description": "有理数可以表示为一对整数：a/b（b>0），其中a是分子，b是分母。\\n整数A在数学上等于有理A/1。\\n \\n在Ruby中，您可以使用内核Rational创建Rational对象，也可以使用内核Rational创建Rational对象，或者使用合理化方法创建Rational对象，也可以将+r+后缀为文本。\\n返回值将是不可约分数。\\n \n   Rational(1)      #=> (1/1)\n   Rational(2, 3)   #=> (2/3)\n   Rational(4, -6)  #=> (-2/3)\n   3.to_r           #=> (3/1)\n   2/3r             #=> (2/3)\n \\n您还可以从浮点数或字符串创建Rational对象。\\n \n   Rational(0.3)    #=> (5404319552844595/18014398509481984)\n   Rational('0.3')  #=> (3/10)\n   Rational('2/3')  #=> (2/3)\n\n   0.3.to_r         #=> (5404319552844595/18014398509481984)\n   '0.3'.to_r       #=> (3/10)\n   '2/3'.to_r       #=> (2/3)\n   0.3.rationalize  #=> (3/10)\n \\n Rational对象是一个精确的数字，它可以帮助您编写程序，而不会出现任何舍入错误。\\n \n   10.times.inject(0) {|t| t + 0.1 }              #=> 0.9999999999999999\n   10.times.inject(0) {|t| t + Rational('0.1') }  #=> (1/1)\n \\n但是，当表达式包含不精确的组件（数值或操作）时，它将产生不精确的结果。\\n \n   Rational(10) / 3   #=> (10/3)\n   Rational(10) / 3.0 #=> 3.3333333333333335\n\n   Rational(-8) ** Rational(1, 3)\n                      #=> (1.0000000000000002+1.7320508075688772i)", "name": "negative?", "namespace": "Rational", "path": "Rational#negative?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Rational#numerator": {"description": "执行乘法。\\n \n   Rational(2, 3)  * Rational(2, 3)   #=> (4/9)\n   Rational(900)   * Rational(1)      #=> (900/1)\n   Rational(-2, 9) * Rational(-9, 2)  #=> (1/1)\n   Rational(9, 8)  * 4                #=> (9/2)\n   Rational(20, 9) * 9.8              #=> 21.77777777777778", "name": "numerator", "namespace": "Rational", "path": "Rational#numerator", "type": "instance_method", "visibility": "public"}, "Rational#positive?": {"description": "执行求幂。\\n \n   Rational(2)    ** Rational(3)     #=> (8/1)\n   Rational(10)   ** -2              #=> (1/100)\n   Rational(10)   ** -2.0            #=> 0.01\n   Rational(-4)   ** Rational(1, 2)  #=> (0.0+2.0i)\n   Rational(1, 2) ** 0               #=> (1/1)\n   Rational(1, 2) ** 0.0             #=> 1.0", "name": "positive?", "namespace": "Rational", "path": "Rational#positive?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Rational#quo": {"description": "执行加法。\\n \n   Rational(2, 3)  + Rational(2, 3)   #=> (4/3)\n   Rational(900)   + Rational(1)      #=> (901/1)\n   Rational(-2, 9) + Rational(-9, 2)  #=> (-85/18)\n   Rational(9, 8)  + 4                #=> (41/8)\n   Rational(20, 9) + 9.8              #=> 12.022222222222222", "name": "quo", "namespace": "Rational", "path": "Rational#quo", "type": "instance_method", "visibility": "public"}, "Rational#quot": {"description": ":nodoc:", "name": "quot", "namespace": "Rational", "path": "Rational#quot", "type": "instance_method", "visibility": "public"}, "Rational#quotrem": {"description": ":nodoc:", "name": "quotrem", "namespace": "Rational", "path": "Rational#quotrem", "type": "instance_method", "visibility": "public"}, "Rational#rational?": {"description": ":nodoc:", "name": "rational?", "namespace": "Rational", "path": "Rational#rational?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Rational#rationalize": {"description": "执行减法。\\n \n   Rational(2, 3)  - Rational(2, 3)   #=> (0/1)\n   Rational(900)   - Rational(1)      #=> (899/1)\n   Rational(-2, 9) - Rational(-9, 2)  #=> (77/18)\n   Rational(9, 8)  - 4                #=> (-23/8)\n   Rational(20, 9) - 9.8              #=> -7.577777777777778", "name": "rationalize", "namespace": "Rational", "path": "Rational#rationalize", "type": "instance_method", "visibility": "public"}, "Rational#round": {"description": "否定+rat+。", "name": "round", "namespace": "Rational", "path": "Rational#round", "type": "instance_method", "visibility": "public"}, "Rational#to_f": {"description": "执行除法。\\n \n   Rational(2, 3)  / Rational(2, 3)   #=> (1/1)\n   Rational(900)   / Rational(1)      #=> (900/1)\n   Rational(-2, 9) / Rational(-9, 2)  #=> (4/81)\n   Rational(9, 8)  / 4                #=> (9/32)\n   Rational(20, 9) / 9.8              #=> 0.22675736961451246", "name": "to_f", "namespace": "Rational", "path": "Rational#to_f", "type": "instance_method", "visibility": "public"}, "Rational#to_i": {"description": "返回-1、0或+1，具体取决于+rational+是小于、等于还是大于+numeric+。\\n \\n如果这两个值不可比较，则返回+nil+。\\n \n   Rational(2, 3) <=> Rational(2, 3)  #=> 0\n   Rational(5)    <=> 5               #=> 0\n   Rational(2, 3) <=> Rational(1, 3)  #=> 1\n   Rational(1, 3) <=> 1               #=> -1\n   Rational(1, 3) <=> 0.3             #=> 1\n \\n    Rational(1, 3) <=> \"0.3\"           #=> nil", "name": "to_i", "namespace": "Rational", "path": "Rational#to_i", "type": "instance_method", "visibility": "public"}, "Rational#to_r": {"description": "如果+rat+的数值等于+object+，则返回+true+。\\n \n   Rational(2, 3)  == Rational(2, 3)   #=> true\n   Rational(5)     == 5                #=> true\n   Rational(0)     == 0.0              #=> true\n   Rational('1/3') == 0.33             #=> false\n   Rational('1/2') == '1/2'            #=> false", "name": "to_r", "namespace": "Rational", "path": "Rational#to_r", "type": "instance_method", "visibility": "public"}, "Rational#to_s": {"description": "返回+rat+的绝对值。\\n \n   (1/2r).abs    #=> (1/2)\n   (-1/2r).abs   #=> (1/2)\n \\n Rational Magnition是Rational Abs的别名。", "name": "to_s", "namespace": "Rational", "path": "Rational#to_s", "type": "instance_method", "visibility": "public"}, "Rational#truncate": {"description": "返回大于或等于+rat+的最小数字，精度为+ndigits+十进制数字（默认值：0）。\\n \\n当精度为负时，传回的值为整数，后面至少有<code>ndigits.abs</code>个零。\\n \\n当+ndigits+为正数时，返回一个有理数，否则返回一个整数。\\n \n   Rational(3).ceil      #=> 3\n   Rational(2, 3).ceil   #=> 1\n   Rational(-3, 2).ceil  #=> -1\n\n     #    decimal      -  1  2  3 . 4  5  6\n     #                   ^  ^  ^  ^   ^  ^\n     #   precision      -3 -2 -1  0  +1 +2\n\n   Rational('-123.456').ceil(+1).to_f  #=> -123.4\n   Rational('-123.456').ceil(-1)       #=> -120", "name": "truncate", "namespace": "Rational", "path": "Rational#truncate", "type": "instance_method", "visibility": "public"}, "Rational::compatible": {"description": "", "name": "compatible", "namespace": "Rational", "path": "Rational::compatible", "type": "class", "visibility": "public"}, "Rational::compatible#marshal_load": {"description": ":nodoc:", "name": "marshal_load", "namespace": "Rational::compatible", "path": "Rational::compatible#marshal_load", "type": "instance_method", "visibility": "private"}, "MatchData": {"description": "返回分母（始终为正）。\\n \n   Rational(7).denominator             #=> 1\n   Rational(7, 1).denominator          #=> 1\n   Rational(9, -4).denominator         #=> 4\n   Rational(-2, -10).denominator       #=> 5", "name": "MatchData", "namespace": "", "path": "MatchData", "type": "class", "visibility": "public"}, "MatchData#==": {"description": "返回分子。\\n \n   Rational(7).numerator        #=> 7\n   Rational(7, 1).numerator     #=> 7\n   Rational(9, -4).numerator    #=> -9\n   Rational(-2, -10).numerator  #=> 1", "name": "==", "namespace": "MatchData", "path": "MatchData#==", "type": "instance_method", "visibility": "public"}, "MatchData#[]": {"description": "返回小于或等于+rat+的最大数字，精度为+ndigits+位十进制数字（默认值：0）。\\n \\n当精度为负时，传回的值为整数，后面至少有<code>ndigits.abs</code>个零。\\n \\n当+ndigits+为正时返回有理数，否则返回整数。\\n \n   Rational(3).floor      #=> 3\n   Rational(2, 3).floor   #=> 0\n   Rational(-3, 2).floor  #=> -2\n\n     #    decimal      -  1  2  3 . 4  5  6\n     #                   ^  ^  ^  ^   ^  ^\n     #   precision      -3 -2 -1  0  +1 +2\n\n   Rational('-123.456').floor(+1).to_f  #=> -123.5\n   Rational('-123.456').floor(-1)       #=> -130个", "name": "[]", "namespace": "MatchData", "path": "MatchData#[]", "type": "instance_method", "visibility": "public"}, "MatchData#begin": {"description": "以字符串形式返回值以供检查。\\n \n   Rational(2).inspect      #=> \"(2/1)\"\n   Rational(-8, 6).inspect  #=> \"(-4/3)\"\n   Rational('1/2').inspect  #=> \"(1/2)\"", "name": "begin", "namespace": "MatchData", "path": "MatchData#begin", "type": "instance_method", "visibility": "public"}, "MatchData#captures": {"description": "返回+rat+的绝对值。\\n \n   (1/2r).abs    #=> (1/2)\n   (-1/2r).abs   #=> (1/2)\n \\n Rational Magnition是Rational Abs的别名。", "name": "captures", "namespace": "MatchData", "path": "MatchData#captures", "type": "instance_method", "visibility": "public"}, "MatchData#end": {"description": "如果+rat+小于0，则返回+true+。", "name": "end", "namespace": "MatchData", "path": "MatchData#end", "type": "instance_method", "visibility": "public"}, "MatchData#eql?": {"description": "返回分子。\\n \n   Rational(7).numerator        #=> 7\n   Rational(7, 1).numerator     #=> 7\n   Rational(9, -4).numerator    #=> -9\n   Rational(-2, -10).numerator  #=> 1", "name": "eql?", "namespace": "MatchData", "path": "MatchData#eql?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "MatchData#hash": {"description": "如果+rat+大于0，则返回+true+。", "name": "hash", "namespace": "MatchData", "path": "MatchData#hash", "type": "instance_method", "visibility": "public"}, "MatchData#initialize_copy": {"description": ":nodoc:", "name": "initialize_copy", "namespace": "MatchData", "path": "MatchData#initialize_copy", "type": "instance_method", "visibility": "public"}, "MatchData#inspect": {"description": "执行除法。\\n \n   Rational(2, 3)  / Rational(2, 3)   #=> (1/1)\n   Rational(900)   / Rational(1)      #=> (900/1)\n   Rational(-2, 9) / Rational(-9, 2)  #=> (4/81)\n   Rational(9, 8)  / 4                #=> (9/32)\n   Rational(20, 9) / 9.8              #=> 0.22675736961451246", "name": "inspect", "namespace": "MatchData", "path": "MatchData#inspect", "type": "instance_method", "visibility": "public"}, "MatchData#length": {"description": "<code>MatchData</code>是特殊变量<code>$~</code>的类型，是<code>Regexp#match</code>和<code>Regexp.last_match</code>返回的对象类型。它封装了模式匹配的所有结果，通常通过特殊变量<code>$&</code>、<code>$'</code>、<code>$`</code>、<code>$1</code>、<code>$2</code>等访问结果。", "name": "length", "namespace": "MatchData", "path": "MatchData#length", "type": "instance_method", "visibility": "public"}, "MatchData#named_captures": {"description": "返回+rat+，四舍五入到最接近的值，精度为+ndigits+位十进制数字（默认值：0）。\\n \\n当精度为负时，传回的值是一个整数，后面至少有<code>ndigits.abs</code>个零。\\n \\n当+ndigits+为正时，返回一个有理数，否则返回一个整数。\\n \n   Rational(3).round      #=> 3\n   Rational(2, 3).round   #=> 1\n   Rational(-3, 2).round  #=> -2\n\n     #    decimal      -  1  2  3 . 4  5  6\n     #                   ^  ^  ^  ^   ^  ^\n     #   precision      -3 -2 -1  0  +1 +2\n\n   Rational('-123.456').round(+1).to_f  #=> -123.5\n   Rational('-123.456').round(-1)       #=> -120\n \\n可选的+half+关键字参数与float round类似。\\n \n   Rational(25, 100).round(1, half: :up)    #=> (3/10)\n   Rational(25, 100).round(1, half: :down)  #=> (1/5)\n   Rational(25, 100).round(1, half: :even)  #=> (1/5)\n   Rational(35, 100).round(1, half: :up)    #=> (2/5)\n   Rational(35, 100).round(1, half: :down)  #=> (3/10)\n   Rational(35, 100).round(1, half: :even)  #=> (2/5)\n   Rational(-25, 100).round(1, half: :up)   #=> (-3/10)\n   Rational(-25, 100).round(1, half: :down) #=> (-1/5)\n   Rational(-25, 100).round(1, half: :even) #=> (-1/5)", "name": "named_captures", "namespace": "MatchData", "path": "MatchData#named_captures", "type": "instance_method", "visibility": "public"}, "MatchData#names": {"description": "以浮点形式返回值。\\n \n   Rational(2).to_f      #=> 2.0\n   Rational(9, 4).to_f   #=> 2.25\n   Rational(-3, 4).to_f  #=> -0.75\n   Rational(20, 3).to_f  #=> 6.666666666666667", "name": "names", "namespace": "MatchData", "path": "MatchData#names", "type": "instance_method", "visibility": "public"}, "MatchData#offset": {"description": "以整数形式返回截断值。\\n \\n相当于有理截断。\\n \n   Rational(2, 3).to_i    #=> 0\n   Rational(3).to_i       #=> 3\n   Rational(300.6).to_i   #=> 300\n   Rational(98, 71).to_i  #=> 1\n   Rational(-31, 2).to_i  #=> -15", "name": "offset", "namespace": "MatchData", "path": "MatchData#offset", "type": "instance_method", "visibility": "public"}, "MatchData#post_match": {"description": "返回self。\\n \n   Rational(2).to_r      #=> (2/1)\n   Rational(-8, 6).to_r  #=> (-4/3)", "name": "post_match", "namespace": "MatchData", "path": "MatchData#post_match", "type": "instance_method", "visibility": "public"}, "MatchData#pre_match": {"description": "以字符串形式返回值。\\n \n   Rational(2).to_s      #=> \"2/1\"\n   Rational(-8, 6).to_s  #=> \"-4/3\"\n   Rational('1/2').to_s  #=> \"1/2\"", "name": "pre_match", "namespace": "MatchData", "path": "MatchData#pre_match", "type": "instance_method", "visibility": "public"}, "MatchData#regexp": {"description": "返回+rat+截断（朝零）到+ndigits+十进制数字的精度（默认值：0）。\\n \\n当精度为负时，传回的值为整数，后面至少有<code>ndigits.abs</code>个零。\\n \\n当+ndigits+为正数时，返回一个有理数，否则返回一个整数。\\n \n   Rational(3).truncate      #=> 3\n   Rational(2, 3).truncate   #=> 0\n   Rational(-3, 2).truncate  #=> -1\n\n     #    decimal      -  1  2  3 . 4  5  6\n     #                   ^  ^  ^  ^   ^  ^\n     #   precision      -3 -2 -1  0  +1 +2\n\n   Rational('-123.456').truncate(+1).to_f  #=> -123.4\n   Rational('-123.456').truncate(-1)       #=> -120", "name": "regexp", "namespace": "MatchData", "path": "MatchData#regexp", "type": "instance_method", "visibility": "public"}, "MatchData#size": {"description": "<code>MatchData</code>是特殊变量<code>$~</code>的类型，是<code>Regexp#match</code>和<code>Regexp.last_match</code>返回的对象类型。它封装了模式匹配的所有结果，通常通过特殊变量<code>$&</code>、<code>$'</code>、<code>$`</code>、<code>$1</code>、<code>$2</code>等访问结果。", "name": "size", "namespace": "MatchData", "path": "MatchData#size", "type": "instance_method", "visibility": "public"}, "MatchData#string": {"description": "相等-如果目标字符串、模式和匹配位置相同，则两个匹配数据相等。", "name": "string", "namespace": "MatchData", "path": "MatchData#string", "type": "instance_method", "visibility": "public"}, "MatchData#to_a": {"description": "匹配引用——<code>MatchData</code>作为一个数组，可以使用普通的数组索引技术访问它。<code>mtch[0]</code> \\n等价于特殊变量<code>$&</code>，并返回整个匹配字符串。<code>mtch[1]</code>、<code>mtch[2]</code>等返回匹配的backreference的值（模式中括号之间的部分）。\\n \n   m = /(.)(.)(\\d+)(\\d)/.match(\"THX1138.\")\n   m          #=> #<MatchData \"HX1138\" 1:\"H\" 2:\"X\" 3:\"113\" 4:\"8\">\n   m[0]       #=> \"HX1138\"\n   m[1, 2]    #=> [\"H\", \"X\"]\n   m[1..3]    #=> [\"H\", \"X\", \"113\"]\n   m[-3, 2]   #=> [\"X\", \"113\"]\n\n   m = /(?<foo>a+)b/.match(\"ccaaab\")\n   m          #=> #<MatchData \"aaab\" foo:\"aaa\">\n   m[\"foo\"]   #=> \"aaa\"\n   m[:foo]    #=> \"aaa\"", "name": "to_a", "namespace": "MatchData", "path": "MatchData#to_a", "type": "instance_method", "visibility": "public"}, "MatchData#to_s": {"description": "返回字符串中匹配数组的<em>n<em>th元素开始的偏移量。\\n<em>n<em>可以是引用命名捕获的字符串或符号。\\n \n   m = /(.)(.)(\\d+)(\\d)/.match(\"THX1138.\")\n   m.begin(0)       #=> 1\n   m.begin(2)       #=> 2\n\n   m = /(?<foo>.)(.)(?<bar>.)/.match(\"hoge\")\n   p m.begin(:foo)  #=> 0\n   p m.begin(:bar)  #=> 2", "name": "to_s", "namespace": "MatchData", "path": "MatchData#to_s", "type": "instance_method", "visibility": "public"}, "MatchData#values_at": {"description": "返回等于<code>mtch.to_a[1..-1]</code>的captures;数组。\\n \n   f1,f2,f3,f4 = /(.)(.)(\\d+)(\\d)/.match(\"THX1138.\").captures\n   f1    #=> \"H\"\n   f2    #=> \"X\"\n   f3    #=> \"113\"\n   f4    #=> \"8\"", "name": "values_at", "namespace": "MatchData", "path": "MatchData#values_at", "type": "instance_method", "visibility": "public"}, "RegexpError": {"description": "返回字符串中匹配数组的\\n<em>n<em>th元素结束后字符的偏移量。\\n<em>n<em>可以是引用命名捕获的字符串或符号。n \n   m = /(.)(.)(\\d+)(\\d)/.match(\"THX1138.\")\n   m.end(0)         #=> 7\n   m.end(2)         #=> 3\n\n   m = /(?<foo>.)(.)(?<bar>.)/.match(\"hoge\")\n   p m.end(:foo)    #=> 1\n   p m.end(:bar)    #=> 3", "name": "RegexpError", "namespace": "", "path": "RegexpError", "type": "class", "visibility": "public"}, "Regexp": {"description": "相等-如果目标字符串、模式和匹配位置相同，则两个匹配数据相等。", "name": "Regexp", "namespace": "", "path": "Regexp", "type": "class", "visibility": "public"}, "Regexp#==": {"description": "返回一个包含<em>n<em>th匹配的开始和结束偏移量的两元素数组。\\n<em>n<em>可以是引用命名捕获的字符串或符号。n \n   m = /(.)(.)(\\d+)(\\d)/.match(\"THX1138.\")\n   m.offset(0)      #=> [1, 7]\n   m.offset(4)      #=> [6, 7]\n\n   m = /(?<foo>.)(.)(?<bar>.)/.match(\"hoge\")\n   p m.offset(:foo) #=> [0, 1]\n   p m.offset(:bar) #=> [2, 3]", "name": "==", "namespace": "Regexp", "path": "Regexp#==", "type": "instance_method", "visibility": "public"}, "Regexp#===": {"description": "返回<i>mtch的可打印版本。n \n    puts /.$/.match(\"foo\").inspect\n    #=> #<MatchData \"o\">\n\n    puts /(.)(.)(.)/.match(\"foo\").inspect\n    #=> #<MatchData \"foo\" 1:\"f\" 2:\"o\" 3:\"o\">\n\n    puts /(.)(.)?(.)/.match(\"fo\").inspect\n    #=> #<MatchData \"fo\" 1:\"f\" 2:nil 3:\"o\">\n\n    puts /(?<foo>.)(?<bar>.)(?<baz>.)/.match(\"hoge\").inspect\n    #=> #<MatchData \"hog\" foo:\"h\" bar:\"o\" baz:\"g\">", "name": "===", "namespace": "Regexp", "path": "Regexp#===", "type": "instance_method", "visibility": "public"}, "Regexp#=~": {"description": "返回匹配数组中的元素数。n \n   m = /(.)(.)(\\d+)(\\d)/.match(\"THX1138.\")\n   m.length   #=> 5\n   m.size     #=> 5", "name": "=~", "namespace": "Regexp", "path": "Regexp#=~", "type": "instance_method", "visibility": "public"}, "Regexp#casefold?": {"description": "返回使用命名捕获的哈希。\\n \\n哈希的键是命名捕获的名称。\\n哈希值是最后成功捕获相应组的字符串。n \n   m = /(?<a>.)(?<b>.)/.match(\"01\")\n   m.named_captures #=> {\"a\" => \"0\", \"b\" => \"1\"}\n\n   m = /(?<a>.)(?<b>.)?/.match(\"0\")\n   m.named_captures #=> {\"a\" => \"0\", \"b\" => nil}\n\n   m = /(?<a>.)(?<a>.)/.match(\"01\")\n   m.named_captures #=> {\"a\" => \"1\"}\n\n   m = /(?<a>x)|(?<a>y)/.match(\"x\")\n   m.named_captures #=> {\"a\" => \"x\"}", "name": "casefold?", "namespace": "Regexp", "path": "Regexp#casefold?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Regexp#encoding": {"description": "以字符串数组形式返回捕获的名称列表。\\n它与mtch.regexp.names相同。n \n    /(?<foo>.)(?<bar>.)(?<baz>.)/.match(\"hoge\").names\n    #=> [\"foo\", \"bar\", \"baz\"]\n\n    m = /(?<x>.)(?<y>.)?/.match(\"a\") #=> #<MatchData \"a\" x:\"a\" y:nil>\n    m.names                          #=> [\"x\", \"y\"]", "name": "encoding", "namespace": "Regexp", "path": "Regexp#encoding", "type": "instance_method", "visibility": "public"}, "Regexp#eql?": {"description": "返回一个包含<em>n<em>th匹配的开始和结束偏移量的两元素数组。\\n<em>n<em>可以是引用命名捕获的字符串或符号。n \n   m = /(.)(.)(\\d+)(\\d)/.match(\"THX1138.\")\n   m.offset(0)      #=> [1, 7]\n   m.offset(4)      #=> [6, 7]\n\n   m = /(?<foo>.)(.)(?<bar>.)/.match(\"hoge\")\n   p m.offset(:foo) #=> [0, 1]\n   p m.offset(:bar) #=> [2, 3]", "name": "eql?", "namespace": "Regexp", "path": "Regexp#eql?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Regexp#fixed_encoding?": {"description": "返回当前匹配后原始字符串的部分。\\n相当于特殊变量<code>$'</code>。n \n   m = /(.)(.)(\\d+)(\\d)/.match(\"THX1138: The Movie\")\n   m.post_match   #=> \": The Movie\"", "name": "fixed_encoding?", "namespace": "Regexp", "path": "Regexp#fixed_encoding?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Regexp#hash": {"description": "返回当前匹配之前原始字符串的部分。\\n相当于特殊变量<code>$`</code>。n \n   m = /(.)(.)(\\d+)(\\d)/.match(\"THX1138.\")\n   m.pre_match   #=> \"T\"", "name": "hash", "namespace": "Regexp", "path": "Regexp#hash", "type": "instance_method", "visibility": "public"}, "Regexp#initialize": {"description": "返回regexp。n \n    m = /a.*b/.match(\"abc\")\n    m.regexp #=> /a.*b/", "name": "initialize", "namespace": "Regexp", "path": "Regexp#initialize", "type": "instance_method", "visibility": "public"}, "Regexp#initialize_copy": {"description": ":nodoc:", "name": "initialize_copy", "namespace": "Regexp", "path": "Regexp#initialize_copy", "type": "instance_method", "visibility": "public"}, "Regexp#inspect": {"description": "返回匹配数组中的元素数。n \n   m = /(.)(.)(\\d+)(\\d)/.match(\"THX1138.\")\n   m.length   #=> 5\n   m.size     #=> 5", "name": "inspect", "namespace": "Regexp", "path": "Regexp#inspect", "type": "instance_method", "visibility": "public"}, "Regexp#match": {"description": "返回传入<code>match</code>的字符串的冻结副本。n \n   m = /(.)(.)(\\d+)(\\d)/.match(\"THX1138.\")\n   m.string   #=> \"THX1138.\"", "name": "match", "namespace": "Regexp", "path": "Regexp#match", "type": "instance_method", "visibility": "public"}, "Regexp#match?": {"description": "返回匹配的数组。\\n \n   m = /(.)(.)(\\d+)(\\d)/.match(\"THX1138.\")\n   m.to_a   #=> [\"HX1138\", \"H\", \"X\", \"113\", \"8\"]\n \\n因为在展开<code>*</code><em>variable时调用了<code>to_a</code>，所以有一个提取匹配字段的有用分配快捷方式。这比直接访问字段（生成中间数组）稍慢。n \n   all,f1,f2,f3 = * /(.)(.)(\\d+)(\\d)/.match(\"THX1138.\")\n   all   #=> \"HX1138\"\n   f1    #=> \"H\"\n   f2    #=> \"X\"\n   f3    #=> \"113\"", "name": "match?", "namespace": "Regexp", "path": "Regexp#match?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Regexp#named_captures": {"description": "返回整个匹配的字符串。n \n   m = /(.)(.)(\\d+)(\\d)/.match(\"THX1138.\")\n   m.to_s   #=> \"HX1138\"", "name": "named_captures", "namespace": "Regexp", "path": "Regexp#named_captures", "type": "instance_method", "visibility": "public"}, "Regexp#names": {"description": "使用每个索引访问匹配值，返回相应匹配的数组。n \n   m = /(.)(.)(\\d+)(\\d)/.match(\"THX1138: The Movie\")\n   m.to_a               #=> [\"HX1138\", \"H\", \"X\", \"113\", \"8\"]\n   m.values_at(0, 2, -2)   #=> [\"HX1138\", \"X\", \"113\"]\n\n   m = /(?<a>\\d+) *(?<op>[+\\-*\\/]) *(?<b>\\d+)/.match(\"1 + 2\")\n   m.to_a               #=> [\"1 + 2\", \"1\", \"+\", \"2\"]\n   m.values_at(:a, :b, :op) #=> [\"1\", \"2\", \"+\"]", "name": "names", "namespace": "Regexp", "path": "Regexp#names", "type": "instance_method", "visibility": "public"}, "Regexp#options": {"description": "在给定无效的regexp表达式时引发。\\n \n   Regexp.new(\"?\")\n \\n<em>引发异常：</em>\\n\\n RegexpError:Target of Repeat Operator is not specified:/？/", "name": "options", "namespace": "Regexp", "path": "Regexp#options", "type": "instance_method", "visibility": "public"}, "Regexp#source": {"description": "<code>Regexp</code>包含一个正则表达式，用于根据字符串匹配模式。regexp由<code>/.../</code>和<code>%r{...}</code>字面值以及<code>Regexp::new</code> \\n构造函数创建。\\n\\n:包括：doc/regexp.rdoc", "name": "source", "namespace": "Regexp", "path": "Regexp#source", "type": "instance_method", "visibility": "public"}, "Regexp#to_s": {"description": "相等-如果两个regexp的模式相同，它们具有相同的字符集代码，并且它们的<code>casefold?</code>值相同，则它们是相等的。n \n   /abc/  == /abc/x   #=> false\n   /abc/  == /abc/i   #=> false\n   /abc/  == /abc/u   #=> false\n   /abc/u == /abc/n   #=> false", "name": "to_s", "namespace": "Regexp", "path": "Regexp#to_s", "type": "instance_method", "visibility": "public"}, "Regexp#~": {"description": "大小写相等-在case语句中使用。\\n \n   a = \"HELLO\"\n   case a\n   when /\\A[a-z]*\\z/; print \"Lower case\\n\"\n   when /\\A[A-Z]*\\z/; print \"Upper case\\n\"\n   else;              print \"Mixed case\\n\"\n   end\n   #=> \"Upper case\"\n \\n在正则表达式文字后面加上==运算符，可以与字符串进行比较。\\n \\n /^[a-z]*$/ === \"HELLO\" #=> false \\n /^[A-Z]*$/ === \"HELLO\" #=> true", "name": "~", "namespace": "Regexp", "path": "Regexp#~", "type": "instance_method", "visibility": "public"}, "Regexp.compile": {"description": "match-matches<i>rxp.<i>against<i>str.<i>。\\n \n   /at/ =~ \"input data\"   #=> 7\n   /ax/ =~ \"input data\"   #=> nil\n \\n如果<code>=~</code>与带有命名捕获的regexp文字一起使用，则捕获的字符串（或nil）将分配给由捕获名称命名的局部变量。\\n \n   /(?<lhs>\\w+)\\s*=\\s*(?<rhs>\\w+)/ =~ \"  x = y  \"\n   p lhs    #=> \"x\"\n   p rhs    #=> \"y\"\n \\n如果不匹配，则为变量分配nil。\\n \n   /(?<lhs>\\w+)\\s*=\\s*(?<rhs>\\w+)/ =~ \"  x = \"\n   p lhs    #=> nil\n   p rhs    #=> nil\n \\n这个指派是在Ruby解析器中执行的。\\n分析器检测到分配的“regexp literal=~expression”。\\n regexp必须是不带插值的文本，并放在左侧。\\n \\n如果regexp不是文本，则不会发生赋值。\\n \n   re = /(?<lhs>\\w+)\\s*=\\s*(?<rhs>\\w+)/\n   re =~ \"  x = y  \"\n   p lhs    # undefined local variable\n   p rhs    # undefined local variable\n \\n regexp插值<code>#{}</code>也会禁用分配。\\n \n   rhs_pat = /(?<rhs>\\w+)/\n   /(?<lhs>\\w+)\\s*=\\s*#{rhs_pat}/ =~ \"x = y\"\n   p lhs    # undefined local variable\n \\n如果regexp放在右手边，则不会发生分配。\\n \n  \"  x = y  \" =~ /(?<lhs>\\w+)\\s*=\\s*(?<rhs>\\w+)/\n p lhs，rhs未定义的局部变量", "name": "compile", "namespace": "Regexp", "path": "Regexp.compile", "type": "class_method", "visibility": "public"}, "Regexp.escape": {"description": "相等-如果两个regexp的模式相同，它们具有相同的字符集代码，并且它们的<code>casefold?</code>值相同，则它们是相等的。n \n   /abc/  == /abc/x   #=> false\n   /abc/  == /abc/i   #=> false\n   /abc/  == /abc/u   #=> false\n   /abc/u == /abc/n   #=> false", "name": "escape", "namespace": "Regexp", "path": "Regexp.escape", "type": "class_method", "visibility": "public"}, "Regexp.last_match": {"description": "返回表示对象编码的编码对象。", "name": "last_match", "namespace": "Regexp", "path": "Regexp.last_match", "type": "class_method", "visibility": "public"}, "Regexp.quote": {"description": "相等-如果两个regexp的模式相同，它们具有相同的字符集代码，并且它们的<code>casefold?</code>值相同，则它们是相等的。n \n   /abc/  == /abc/x   #=> false\n   /abc/  == /abc/i   #=> false\n   /abc/  == /abc/u   #=> false\n   /abc/u == /abc/n   #=> false", "name": "quote", "namespace": "Regexp", "path": "Regexp.quote", "type": "class_method", "visibility": "public"}, "Regexp.try_convert": {"description": "如果Rxp适用于任何ASCII兼容编码的字符串，则返回false。\\n否则返回true。n \n    r = /a/\n    r.fixed_encoding?                               #=> false\n    r =~ \"\\u{6666} a\"                               #=> 2\n    r =~ \"\\xa1\\xa2 a\".force_encoding(\"euc-jp\")      #=> 2\n    r =~ \"abc\".force_encoding(\"euc-jp\")             #=> 0\n\n    r = /a/u\n    r.fixed_encoding?                               #=> true\n    r.encoding                                      #=> #<Encoding:UTF-8>\n    r =~ \"\\u{6666} a\"                               #=> 2\n    r =~ \"\\xa1\\xa2\".force_encoding(\"euc-jp\")        #=> Encoding::CompatibilityError\n    r =~ \"abc\".force_encoding(\"euc-jp\")             #=> 0\n\n    r = /\\u{6666}/\n    r.fixed_encoding?                               #=> true\n    r.encoding                                      #=> #<Encoding:UTF-8>\n    r =~ \"\\u{6666} a\"                               #=> 0\n    r =~ \"\\xa1\\xa2\".force_encoding(\"euc-jp\")        #=> Encoding::CompatibilityError\n    r =~ \"abc\".force_encoding(\"euc-jp\")             #=> nil", "name": "try_convert", "namespace": "Regexp", "path": "Regexp.try_convert", "type": "class_method", "visibility": "public"}, "Regexp.union": {"description": "基于此正则表达式的文本和选项生成哈希。\\n \\n另请参阅对象哈希。", "name": "union", "namespace": "Regexp", "path": "Regexp.union", "type": "class_method", "visibility": "public"}, "Regexp::EXTENDED": {"description": "返回一个哈希，该哈希表示有关<i>rxp的命名捕获的信息。\\n \\n哈希的键是命名捕获的名称。\\n哈希值是一个数组，该数组是相应命名捕获的索引列表。\\n \n   /(?<foo>.)(?<bar>.)/.named_captures\n   #=> {\"foo\"=>[1], \"bar\"=>[2]}\n\n   /(?<foo>.)(?<foo>.)/.named_captures\n   #=> {\"foo\"=>[1, 2]}\n \\n如果没有命名捕获，则返回空哈希。n \n   /(.)(.)/.named_captures\n   #=> {}", "name": "EXTENDED", "namespace": "Regexp", "path": "Regexp::EXTENDED", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "Regexp::FIXEDENCODING": {"description": "返回一个哈希，该哈希表示有关<i>rxp的命名捕获的信息。\\n \\n哈希的键是命名捕获的名称。\\n哈希值是一个数组，该数组是相应命名捕获的索引列表。\\n \n   /(?<foo>.)(?<bar>.)/.named_captures\n   #=> {\"foo\"=>[1], \"bar\"=>[2]}\n\n   /(?<foo>.)(?<foo>.)/.named_captures\n   #=> {\"foo\"=>[1, 2]}\n \\n如果没有命名捕获，则返回空哈希。n \n   /(.)(.)/.named_captures\n   #=> {}", "name": "FIXEDENCODING", "namespace": "Regexp", "path": "Regexp::FIXEDENCODING", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "Regexp::IGNORECASE": {"description": "返回一个哈希，该哈希表示有关<i>rxp的命名捕获的信息。\\n \\n哈希的键是命名捕获的名称。\\n哈希值是一个数组，该数组是相应命名捕获的索引列表。\\n \n   /(?<foo>.)(?<bar>.)/.named_captures\n   #=> {\"foo\"=>[1], \"bar\"=>[2]}\n\n   /(?<foo>.)(?<foo>.)/.named_captures\n   #=> {\"foo\"=>[1, 2]}\n \\n如果没有命名捕获，则返回空哈希。n \n   /(.)(.)/.named_captures\n   #=> {}", "name": "IGNORECASE", "namespace": "Regexp", "path": "Regexp::IGNORECASE", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "Regexp::MULTILINE": {"description": "返回一个哈希，该哈希表示有关<i>rxp的命名捕获的信息。\\n \\n哈希的键是命名捕获的名称。\\n哈希值是一个数组，该数组是相应命名捕获的索引列表。\\n \n   /(?<foo>.)(?<bar>.)/.named_captures\n   #=> {\"foo\"=>[1], \"bar\"=>[2]}\n\n   /(?<foo>.)(?<foo>.)/.named_captures\n   #=> {\"foo\"=>[1, 2]}\n \\n如果没有命名捕获，则返回空哈希。n \n   /(.)(.)/.named_captures\n   #=> {}", "name": "MULTILINE", "namespace": "Regexp", "path": "Regexp::MULTILINE", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "Regexp::NOENCODING": {"description": "返回一个哈希，该哈希表示有关<i>rxp的命名捕获的信息。\\n \\n哈希的键是命名捕获的名称。\\n哈希值是一个数组，该数组是相应命名捕获的索引列表。\\n \n   /(?<foo>.)(?<bar>.)/.named_captures\n   #=> {\"foo\"=>[1], \"bar\"=>[2]}\n\n   /(?<foo>.)(?<foo>.)/.named_captures\n   #=> {\"foo\"=>[1, 2]}\n \\n如果没有命名捕获，则返回空哈希。n \n   /(.)(.)/.named_captures\n   #=> {}", "name": "NOENCODING", "namespace": "Regexp", "path": "Regexp::NOENCODING", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "Process": {"description": "", "name": "Process", "namespace": "", "path": "Process", "type": "module", "visibility": "public"}, "Process#argv0": {"description": "返回此进程的父进程的进程ID。在win32/64上返回不可信的值。并非所有平台都可用。\\n \n   puts \"I am #{Process.pid}\"\n   Process.fork { puts \"Dad is #{Process.ppid}\" }\n \\n<em>产生：.<em>\\n \n   I am 27417\n dad is 27417", "name": "argv0", "namespace": "Process", "path": "Process#argv0", "type": "module_function", "visibility": "private"}, "Process#clock_getres": {"description": "将PID的进程组ID（0表示此进程）设置为<em>integer。并非所有平台都可用。", "name": "clock_getres", "namespace": "Process", "path": "Process#clock_getres", "type": "module_function", "visibility": "private"}, "Process#clock_gettime": {"description": "相当于<code>setpgid(0,0)</code>。并非所有平台都可用。", "name": "clock_gettime", "namespace": "Process", "path": "Process#clock_gettime", "type": "module_function", "visibility": "private"}, "Process#daemon": {"description": "见<code>Process#getpriority</code>。n \n   Process.setpriority(Process::PRIO_USER, 0, 19)      #=> 0\n   Process.setpriority(Process::PRIO_PROCESS, 0, 19)   #=> 0\n   Process.getpriority(Process::PRIO_USER, 0)          #=> 19\n   Process.getpriority(Process::PRIO_PROCESS, 0)       #=> 19", "name": "daemon", "namespace": "Process", "path": "Process#daemon", "type": "module_function", "visibility": "private"}, "Process#detach": {"description": "设置显示在ps（1）命令上的进程标题。不一定对所有平台都有效。无论结果如何，都不会引发异常，即使平台不支持该功能，也不会引发NotImplementedError。\\n \\n调用此方法不会影响$0的值。\\n \n   Process.setproctitle('myapp: worker #%d' % worker_id)\n \\n此方法首先出现在Ruby2.1中，用作更改进程标题的全局无变量方法。", "name": "detach", "namespace": "Process", "path": "Process#detach", "type": "module_function", "visibility": "private"}, "Process#egid": {"description": "设置进程的资源限制。\\n cur-limit表示当前（软）限制，max-limit表示最大（硬）限制。\\n \\n如果未给定max_限制，则使用cur_限制。\\n \\n resource表示要限制的资源类型。\\n它应该是<code>:CORE</code>之类的符号，或者是<code>\"CORE\"</code>之类的字符串，或者是<code>Process::RLIMIT_CORE</code>之类的常量。\\n可用资源依赖于操作系统。\\n Ruby可能支持以下资源。\\n \\n[as]总可用内存（字节）（susv3，netbsd，freebsd，openbsd but 4.4bsd-lite）：n[CORE]核心大小（字节）（susv3）：n[cpu]CPU时间（秒）（susv3）：n[DATA]数据段（字节）（susv3）：n[FSIZE]文件大小（字节）（susv3）：n[MEMLOCK]MLock的总大小（2）（字节）（4.4bsd，gnu/linux）：n[MSGQUEUE]POSIX的分配消息队列（字节）（gnu/linux）进程nice（2）值（number）（gnu/linux）上限\\n[NOFILE]文件描述符（number）（susv3）n[NPROC]用户进程数（number）（4.4bsd，gnu/linux）上限\\n[rss]常驻内存大小（字节）（4.2bsd，gnu/linux）上限\\n[RTPRIO]进程实时优先级上限（number）（gnu/linux）实时进程的CPU时间（us）（gnu/linux）的CPU时间\\n[SBSIZE]所有套接字缓冲区（字节）（netbsd，freebsd）的CPU时间\\n[SIGPENDING]允许的排队信号数（信号）（gnu/linux）的CPU时间\\n[STACK]堆栈大小（字节）（susv3）的CPU时间\\n \\n cur limit_u和\\u max_限制可以是<code>:INFINITY</code>、<code>\"INFINITY\"</code>或<code>Process::RLIM_INFINITY</code>，这意味着资源不是有限的。\\n它们可能是<code>Process::RLIM_SAVED_MAX</code>、\\n <code>Process::RLIM_SAVED_CUR</code>以及相应的符号和字符串。\\n有关详细信息，请参阅系统setrlimit（2）手册。\\n \\n下面的示例将核心大小的软限制提高到硬限制，以尝试使核心转储成为可能。\\n \\n process.setrlimit（：CORE，process.getrlimit（：CORE）[1]）", "name": "egid", "namespace": "Process", "path": "Process#egid", "type": "module_function", "visibility": "private"}, "Process#egid=": {"description": "", "name": "egid=", "namespace": "Process", "path": "Process#egid=", "type": "module_function", "visibility": "private"}, "Process#euid": {"description": "将此流程建立为新的会话和流程小组负责人，不控制TTY。返回会话ID。并非所有平台都可用。\\n n    Process.setsid   #=> 27422", "name": "euid", "namespace": "Process", "path": "Process#euid", "type": "module_function", "visibility": "private"}, "Process#euid=": {"description": "返回<code>Tms</code>结构（请参阅<code>Process::Tms</code>），其中包含此进程以及子进程的用户和系统CPU时间。n \n   t = Process.times\n   [ t.utime, t.stime, t.cutime, t.cstime ]   #=> [0.0, 0.02, 0.00, 0.00]", "name": "euid=", "namespace": "Process", "path": "Process#euid=", "type": "module_function", "visibility": "private"}, "Process#getpgid": {"description": "等待所有子对象，返回一个“pid”（状态）对数组（其中状态为<code>Process::Status</code>对象）。\\n \n   fork { sleep 0.2; exit 2 }   #=> 27432\n   fork { sleep 0.1; exit 1 }   #=> 27433\n   fork {            exit 0 }   #=> 27434\n   p Process.waitall\n \\n<em>生成</em>：\\n \n   [[30982, #<Process::Status: pid 30982 exit 0>],\n    [30979, #<Process::Status: pid 30979 exit 1>],\n[30976，<process:：status:pid 30976 exit 2>]", "name": "getpgid", "namespace": "Process", "path": "Process#getpgid", "type": "module_function", "visibility": "private"}, "Process#getpgrp": {"description": "等待子进程退出，返回其进程ID，并将<code>$?</code>设置为包含该进程信息的<code>Process::Status</code>对象。它等待的子级\\n取决于\\n PID\\n \\n>0的值：：等待进程ID等于PID的子级。\\n\\n 0：：等待进程组ID等于the\n        calling process.\n的任何子进程\\n- 1：：等待任何子进程（如果没有PID is\n        given).\n，则为默认值\\n<-1：：等待进程组ID等于absolute\n        value of _pid_.\n的任何子进程\\n flags参数可以是逻辑或标志值<code>Process::WNOHANG</code>（如果没有可用的子进程，则不阻止）的逻辑或标志值的逻辑或\\n或<code>Process::WUNTRACED</code>（retuRN阻止了尚未报告的儿童）。并非所有的标志都可以在所有平台上使用，但是标志值为零可以在所有平台上使用。\\n \\n如果没有子进程，则调用此方法将引发SystemCallError。并非所有平台都可用。n \n   include Process\n   fork { exit 99 }                 #=> 27429\n   wait                             #=> 27429\n   $?.exitstatus                    #=> 99\n\n   pid = fork { sleep 3 }           #=> 27440\n   Time.now                         #=> 2008-03-08 19:56:16 +0900\n   waitpid(pid, Process::WNOHANG)   #=> nil\n   Time.now                         #=> 2008-03-08 19:56:16 +0900\n   waitpid(pid, 0)                  #=> 27440\n   Time.now                         #=> 2008-03-08 19:56:19 +0900", "name": "getpgrp", "namespace": "Process", "path": "Process#getpgrp", "type": "module_function", "visibility": "private"}, "Process#getpriority": {"description": "等待子进程退出（请参阅process:：waitpid了解确切的语义），并返回包含进程ID和该子进程的退出状态（<code>Process::Status</code>对象）的数组。如果没有子进程，则引发SystemCallError。n \n   Process.fork { exit 99 }   #=> 27437\n   pid, status = Process.wait2\n   pid                        #=> 27437\n   status.exitstatus          #=> 99", "name": "getpriority", "namespace": "Process", "path": "Process#getpriority", "type": "module_function", "visibility": "private"}, "Process#getrlimit": {"description": "通过拨打<code>Kernel.exit(false)</code>立即终止执行。如果给出msg，则在终止之前将其写入\\n STDERR。", "name": "getrlimit", "namespace": "Process", "path": "Process#getrlimit", "type": "module_function", "visibility": "private"}, "Process#getsid": {"description": "返回正在执行的脚本的名称。该值不受为$0分配新值的影响。\\n \\n此方法首先出现在Ruby2.1中，用作获取脚本名称的全局变量释放方法。", "name": "getsid", "namespace": "Process", "path": "Process#getsid", "type": "module_function", "visibility": "private"}, "Process#gid": {"description": "返回POSIX clock_getres（）函数返回的时间分辨率。\\n \\n +clock_id+指定一种时钟。\\n有关详细信息，请参阅+process.clock \\gettime+的文档。\\n \\n +clock_id+可以是符号as+process.clock\\u gettime+。\\n但是，结果可能不准确。\\n例如，+process.clock\\getres（：GETTIMEOFDAY_BASED_CLOCK_REALTIME）+\\n返回1.0e-06，这意味着1微秒，但实际分辨率可能更粗糙。\\n \\n如果不支持给定的+clock_id+，将引发errno:：EINVAL。\\n \\n +unit+指定返回值的类型。\\n+process.clock_getres+接受+unit+作为+process.clock_gettime+。\\n默认值“+：float_second+”与\\n+process.clock_gettime+相同。\\n \\n+进程。时钟\\u getres+也接受+：赫兹+作为+unit+。\\n+：赫兹+表示+：float_second+的倒数。\\n \\n+：赫兹+可用于获取times（）函数和clock（）函数的每秒时钟滴答数的准确值CLOCKS_PER_SEC。\\n \\n+process.clock_getres（：TIMES_BASED_CLOCK_PROCESS_CPUTIME_ID，：赫兹）+\\n返回每秒的时钟计时。\\n \\n+process.clock_getres（：CLOCK_BASED_CLOCK_PROCESS_CPUTIME_ID，：赫兹）+\\n返回CLOCKS_PER_SEC。n \n  p Process.clock_getres(Process::CLOCK_MONOTONIC)\n  #=> 1.0e-09", "name": "gid", "namespace": "Process", "path": "Process#gid", "type": "module_function", "visibility": "private"}, "Process#gid=": {"description": "返回POSIX clockgettime（）函数返回的时间。\\n \n  p Process.clock_gettime(Process::CLOCK_MONOTONIC)\n  #=> 896053.968060096\n \\n +clock_id+指定一种时钟。\\n它被指定为以<code>Process::CLOCK_</code>开头的常量，例如process:：CLOCK_REALTIME和process:：CLOCK_MONOTONIC。\\n \\n受支持的常量取决于操作系统和版本。\\n ruby提供以下+clock_id+类型（如果可用）。\\n \\n[CLOCK_REALTIME_FAST2]SUSv2至4、Linux2.5.63、FreeBSD 3.0、NetBSD 2.0、OpenBSD 2.1、MacOS 10.12 \\n[CLOCK_REALTIME_FAST3]SUSv3至4、Linux2.5.63、FreeBSD 3.0、NetBSD 2.0、OpenBSD 3.4、MacOS 10.12 \\n[CLOCK_REALTIME_FAST4]SUSv3至4、Linux2.5.63、OpenBSD 5.4、MacOS 10.12 \\n[CLOCK_REALTIME_FAST5]SUSv3至4、Linux2.5.63、FreeBSD 7.12.1、FreeBSD 2.1、OpenBSD 2.1、MacOS 10.1、OpenBSD 2.1、MacOS 10.12\\n[CLOCK_REALTIME_FAST3]100606.1，OpenBSD 5.4，MacOS 10.12\\n[CLOCK_VIRTUAL]免费3.0，OpenBSD 2.1 \\n[CLOCK_REALTIME_FAST7]FreeBSD 3.0，OpenBSD 2.1 \\n[CLOCK_REALTIME_FAST]FreeBSD 8.1 \\n[CLOCK_REALTIME_FAST]FreeBSD 8.1 \\n[CLOCK_REALTIME_FAST9]FreeBSD 8.1 \\n[CLOCK_REALTIME_COARSE]Linux2.6.32 \\n[CLOCK_REALTIME_ALARM]Linux3.0\\n[CLOCK_REALTIME_ALARM]Linux3.0 \\n[CLOCK_MONOTONIC_FAST]FreeBSD 2.1 \\n[CLOCK_MONOTONIC_PRECISE]FreeBSD 8.1 \\n[CLOCK_REALTIME_FAST7]FreeBSD 3.3.0]FreeBSD 3.0 3.0 3.0，OpenBSD 3.1]FreeBSD 3.1 \\n[CLOCK_PROF]FreeBSD 3.0 3.3.0 12 \\n[CLOCK_BOOTTIME]Linux 2.6.39 \\n[CLOCK_BOOTTIME_ALARM]Linux 3.0 \\n[CLOCK_UPTIME]freebsd 7.0，openbsd 5.5 \\n[CLOCK_UPTIME_FAST]freebsd 8.1 \\n[CLOCK_UPTIME_RAW]macos 10.12 \\n[CLOCK_UPTIME_RAW_APPROX]macos 10.12 \\n[CLOCK_UPTIME_PRECISE]freebsd 8.1 \\n[CLOCK_SECOND]freebsd 8.1 \\n \\n请注意sus代表单个unix规范。\\n SUS包含POSIX，clock_gettime在POSIX部分中定义。\\n sus定义CLOCK_REALTIME是必需的，但CLOCK_MONOTONIC、CLOCK_PROCESS_CPUTIME_ID和CLOCK_THREAD_CPUTIME_ID是可选的。\\n \\n此外，多个符号被接受为+clock_id+。\\n有clock \\gettime（）的模拟。\\n \\n例如，当时钟\\u gettime（）不可用时，进程：：CLOCK_REALTIME定义为\\n+：GETTIMEOFDAY_BASED_CLOCK_REALTIME+。\\n \\n对+CLOCK_REALTIME+的模拟：\\n[：GETTIMEOFDAY_BASED_CLOCK_REALTIME]\n  Use gettimeofday() defined by SUS.\n  (SUSv4 obsoleted it, though.)\n  The resolution is 1 microsecond.\n[：TIME_BASED_CLOCK_REALTIME]\n  Use time() defined by ISO C.\n  The resolution is 1 second.\n \\n对+CLOCK_MONOTONIC+的模拟：\\n[：MACH_ABSOLUTE_TIME_BASED_CLOCK_MONOTONIC]\n  Use mach_absolute_time(), available on Darwin.\n  The resolution is CPU dependent.\n[：TIMES_BASED_CLOCK_MONOTONIC]\n  Use the result value of times() defined by POSIX.\n  POSIX defines it as \"times() shall return the elapsed real time, in clock ticks, since an arbitrary point in the past (for example, system start-up time)\".\n  For example, GNU/Linux returns a value based on jiffies and it is monotonic.\n  However, 4.4BSD uses gettimeofday() and it is not monotonic.\n  (FreeBSD uses clock_gettime(CLOCK_MONOTONIC) instead, though.)\n  The resolution is the clock tick.\n  \"getconf CLK_TCK\" command shows the clock ticks per second.\n  (The clock ticks per second is defined by HZ macro in older systems.)\n  If it is 100 and clock_t is 32 bits integer type, the resolution is 10 millisecond and\n  cannot represent over 497 days.\n \\n对+CLOCK_PROCESS_CPUTIME_ID+的模拟：\\n[：GETRUSAGE_BASED_CLOCK_PROCESS_CPUTIME_ID]\n  Use getrusage() defined by SUS.\n  getrusage() is used with RUSAGE_SELF to obtain the time only for\n  the calling process (excluding the time for child processes).\n  The result is addition of user time (ru_utime) and system time (ru_stime).\n  The resolution is 1 microsecond.\n[：TIMES_BASED_CLOCK_PROCESS_CPUTIME_ID]\n  Use times() defined by POSIX.\n  The result is addition of user time (tms_utime) and system time (tms_stime).\n  tms_cutime and tms_cstime are ignored to exclude the time for child processes.\n  The resolution is the clock tick.\n  \"getconf CLK_TCK\" command shows the clock ticks per second.\n  (The clock ticks per second is defined by HZ macro in older systems.)\n  If it is 100, the resolution is 10 millisecond.\n[：CLOCK_BASED_CLOCK_PROCESS_CPUTIME_ID]\n  Use clock() defined by ISO C.\n  The resolution is 1/CLOCKS_PER_SEC.\n  CLOCKS_PER_SEC is the C-level macro defined by time.h.\n  SUS defines CLOCKS_PER_SEC is \n   ary = [1, \"two\", 3.0] #=> [1, \"two\", 3.0]\n.\n  Non-Unix systems may define it a different value, though.\n  If CLOCKS_PER_SEC is \n   ary = [1, \"two\", 3.0] #=> [1, \"two\", 3.0]\n as SUS, the resolution is 1 microsecond.\n  If CLOCKS_PER_SEC is \n   ary = [1, \"two\", 3.0] #=> [1, \"two\", 3.0]\n and clock_t is 32 bits integer type, it cannot represent over 72 minutes.\n \\n如果不支持给定的+clock_id+，则引发错误号：：EINVAL。\\n \\n +unit+指定返回值的类型。\\n \\n[：float_second]作为浮点的秒数（默认值）\\n[：float_millisecond]作为浮点的毫秒数\\n[：float_microsecond]作为浮点的微秒数\\n[：second]作为整数的秒数\\n[：millisecond]作为整数的毫秒数\\n[：microsecond]作为整数的微秒数\\n[：纳秒]以整数表示的纳秒数\\n \\n基础函数clock \\u gettime（）返回纳秒数。\\n float对象（IEEE 754 double）不足以表示CLOCK_REALTIME的返回值。\\n如果需要精确的纳秒值，请使用+：纳秒+作为+unit+。\\n \\n传回值的来源（零）会有所不同。\\n例如，系统启动时间、进程启动时间、epoch等。\\n \\n CLOCK_REALTIME中的原点定义为epoch（1970-01-01 00:00:00 UTC）。\\n但有些系统计算闰秒，而其他系统不计算闰秒。\\n因此，可以在不同的系统中对结果进行不同的解释。\\n建议Time.now大于CLOCK_REALTIME。", "name": "gid=", "namespace": "Process", "path": "Process#gid=", "type": "module_function", "visibility": "private"}, "Process#groups": {"description": "将进程与控制终端分离，并作为系统守护程序在后台运行。除非参数nochdir为true（即非false），否则它会将当前工作目录更改为根（“/”）。除非参数noclose为true，否则daemon（）会将标准输入、标准输出和标准错误重定向到/dev/null。\\n成功时返回零，或引发一个errno:：*。", "name": "groups", "namespace": "Process", "path": "Process#groups", "type": "module_function", "visibility": "private"}, "Process#groups=": {"description": "一些操作系统保留终止的子进程的状态，直到父进程收集到该状态（通常使用<code>wait()</code>的某个变量）。如果父级从不收集此状态，则子级将作为僵尸保留在周围。\\n <code>Process::detach</code>通过设置一个单独的Ruby线程来防止这种情况，该线程的唯一任务是在进程PID终止时获取其状态。仅当不打算显式等待子级终止时才使用<code>detach</code>。\\n \\n等待线程终止时返回分离进程的退出状态，因此可以使用<code>Thread#join</code>了解结果。如果指定的PID不是有效的子进程ID，则线程将立即返回+nil+。\\n \\n等待线程具有<code>pid</code>方法，该方法返回PID。\\n \\n在第一个示例中，我们不获取第一个子进程，因此它在进程状态显示中显示为僵尸。\\n \n   p1 = fork { sleep 0.1 }\n   p2 = fork { sleep 0.2 }\n   Process.waitpid(p2)\n   sleep 2\n   system(\"ps -ho pid,state -p #{p1}\")\n \\n<em>products:-<em>\\n \n   27389 Z\n \\n在下一个示例中，<code>Process::detach</code>用于自动获取子级。\\n \n   p1 = fork { sleep 0.1 }\n   p2 = fork { sleep 0.2 }\n   Process.detach(p1)\n   Process.waitpid(p2)\n   sleep 2\n   system(\"ps -ho pid,state -p #{p1}\")\n \\n<em>（products no output）</em>", "name": "groups=", "namespace": "Process", "path": "Process#groups=", "type": "module_function", "visibility": "private"}, "Process#initgroups": {"description": "返回此进程的有效组ID。并非所有平台都可用。\\n n    Process.egid   #=> 500", "name": "initgroups", "namespace": "Process", "path": "Process#initgroups", "type": "module_function", "visibility": "private"}, "Process#kill": {"description": "返回此进程的有效用户ID。\\n n    Process.euid   #=> 501", "name": "kill", "namespace": "Process", "path": "Process#kill", "type": "module_function", "visibility": "private"}, "Process#maxgroups": {"description": "通过运行给定的外部命令来替换当前进程，该外部命令可以采用以下形式之一：\\n\\n[<code>exec(commandline)</code>]\\n传递给标准shell的命令行字符串\\n[<code>exec(cmdname, arg1, ...)</code>]\\n命令名和一个或多个参数（无shell）\\n[<code>exec([cmdname, argv0], arg1, ...)</code>]\\n命令名、argv[0]和零个或多个参数（无shell）\\n\\n在FI中rst形式，字符串被作为命令行，在执行之前要进行shell扩展。\\n \\n在类Unix系统上，标准shell始终意味着<code>\"/bin/sh\"</code>，与<code>ENV[\"RUBYSHELL\"]</code> \\n（或Windows NT系列上的<code>ENV[\"COMSPEC\"]</code>）相同，并且类似。\\n \\n如果第一个表单（<code>exec(\"command\")</code>）中的字符串遵循以下简单规则：\\n \\n*没有元字符\\n*没有shell保留字和特殊内置字\\n*ruby在没有shell的情况下直接调用命令\\n \\n可以通过向字符串中添加“；”来强制shell调用（因为“；”是元字符）。\\n \\n请注意，此行为可通过获取的pid观察到\\n（prown（）的返回值和io.popen的io pid）是被调用命令的pid，而不是shell。\\n \\n在第二种形式（<code>exec(\"command1\", \"arg1\", ...)</code>）中，第一种形式作为命令名，其余形式作为参数传递给命令，不进行shell扩展。\\n \\n在第三种形式（<code>exec([\"command\", \"argv0\"], \"arg1\", ...)</code>）中，从命令开头的两元素数组开始，第一个元素是要执行的命令，第二个参数用作<code>argv[0]</code>值，该值可能显示在进程列表中。\\n \\n为了执行该命令，将使用<code>exec(2)</code>系统调用之一，因此正在运行的命令可能会继承原始程序的某些环境（包括打开的文件描述符）。\\n \\n此行为由给定的+env+和+options+参数修改。有关详细信息，请参阅\\n:：Spawn。\\n \\n如果命令无法执行（通常在找不到时为<code>Errno::ENOENT</code>），则会引发SystemCallError异常。\\n \\n此方法在<code>exec(2)</code>系统调用之前根据给定的+options+修改进程属性。有关给定+options+的详细信息，请参见：：spawn。\\n \\n当<code>exec(2)</code>系统调用失败时，可以保留修改的属性。\\n \\n例如，硬资源限制不可恢复。\\n \\n如果不可接受，请考虑使用：：spawn或kernel系统创建子进程。\\n \n   exec \"echo *\"       # echoes list of files in current directory\n   # never get here\n\n   exec \"echo\", \"*\"    # echoes an asterisk\n永远不要到这里", "name": "maxgroups", "namespace": "Process", "path": "Process#maxgroups", "type": "module_function", "visibility": "private"}, "Process#maxgroups=": {"description": "通过引发<code>SystemExit</code>异常来启动Ruby脚本的终止。可能会捕获此异常。可选参数用于将状态代码返回到调用环境。\\n状态的+true+和+FALSE+分别表示成功和失败。其他整数值的解释取决于系统。\\n \n   begin\n     exit\n     puts \"never get here\"\n   rescue SystemExit\n     puts \"rescued a SystemExit exception\"\n   end\n   puts \"after begin block\"\n \\n<em>生成：.<em>\\n \n   rescued a SystemExit exception\n   after begin block\n \\n就在终止之前，Ruby执行任何<code>at_exit</code>函数\\n（请参阅kernel:：at_exit）并运行任何对象终结器（请参阅ObjectSpace:：define_finalizer）。\\n \n   at_exit { puts \"at_exit function\" }\n   ObjectSpace.define_finalizer(\"string\",  proc { puts \"in finalizer\" })\n   exit\n \\n<em>产生：.<em>\\n \n   at_exit function\n in finalizer", "name": "maxgroups=", "namespace": "Process", "path": "Process#maxgroups=", "type": "module_function", "visibility": "private"}, "Process#pid": {"description": "立即退出进程。没有运行退出处理程序。<em>status<em>作为退出状态返回到基础系统。\\n \\n process.exit！（真）", "name": "pid", "namespace": "Process", "path": "Process#pid", "type": "module_function", "visibility": "private"}, "Process#ppid": {"description": "创建子进程。如果指定了块，则该块在子进程中运行，子进程以零状态终止。否则，+fork+调用将返回两次，一次在父级中，返回子级的进程ID，一次在子级中，返回nil。子进程可以使用<code>Kernel.exit!</code>退出，以避免运行任何<code>at_exit</code>函数。父进程应该使用<code>Process.wait</code>来收集其子进程的终止状态，或者使用<code>Process.detach</code>在其status;中注册disinterest，否则，操作系统可能会累积僵尸进程。\\n \\n线程调用分叉是创建的子进程中唯一的线程。\\n fork不复制其他线程。\\n \\n如果fork不可用，process.response\\u？（：fork）返回false。\\n \\n请注意，fork（2）在某些平台（如Windows和NetBSD 4）上不可用。\\n因此，您应该使用spawn（）而不是fork（）。", "name": "ppid", "namespace": "Process", "path": "Process#ppid", "type": "module_function", "visibility": "private"}, "Process#setpgid": {"description": "返回给定进程ID的进程组ID。并非所有平台都可用。\\n n    Process.getpgid(Process.ppid())   #=> 25527", "name": "setpgid", "namespace": "Process", "path": "Process#setpgid", "type": "module_function", "visibility": "private"}, "Process#setpgrp": {"description": "返回此进程的进程组ID。并非所有平台都可用。n \n   Process.getpgid(0)   #=> 25527\n   Process.getpgrp      #=> 25527", "name": "setpgrp", "namespace": "Process", "path": "Process#setpgrp", "type": "module_function", "visibility": "private"}, "Process#setpriority": {"description": "获取指定进程、进程组或用户的计划优先级。<em>kind<em>表示要查找的实体类型：<code>Process::PRIO_PGRP</code>、<code>Process::PRIO_USER</code>或<code>Process::PRIO_PROCESS</code>中的一个。整数是指示特定进程、进程组或用户的ID（ID为0表示当前）。较低的优先级更有利于调度。并非所有平台都可用。n \n   Process.getpriority(Process::PRIO_USER, 0)      #=> 19\n   Process.getpriority(Process::PRIO_PROCESS, 0)   #=> 19", "name": "setpriority", "namespace": "Process", "path": "Process#setpriority", "type": "module_function", "visibility": "private"}, "Process#setproctitle": {"description": "获取进程的资源限制。\\n cur-limit表示当前（软）限制，max-limit表示最大（硬）限制。\\n \\n resource表示要限制的资源类型。\\n它被指定为一个符号（如<code>:CORE</code>）、一个字符串（如<code>\"CORE\"</code>）或一个常量（如<code>Process::RLIMIT_CORE</code>）。\\n有关详细信息，请参阅Process.setrlimit。\\n \\n cur_limit_uu和max_limit可以是<code>Process::RLIM_INFINITY</code>、\\n <code>Process::RLIM_SAVED_MAX</code>或<code>Process::RLIM_SAVED_CUR</code>。\\n有关详细信息，请参阅Process.setrlimit和系统getrlimit（2）手册。", "name": "setproctitle", "namespace": "Process", "path": "Process#setproctitle", "type": "module_function", "visibility": "private"}, "Process#setrlimit": {"description": "返回给定进程ID的会话ID。如果没有给定，则返回当前进程ID。并非所有平台都可用。n \n   Process.getsid()                #=> 27422\n   Process.getsid(0)               #=> 27422\n   Process.getsid(Process.pid())   #=> 27422", "name": "setrlimit", "namespace": "Process", "path": "Process#setrlimit", "type": "module_function", "visibility": "private"}, "Process#setsid": {"description": "返回此进程的（实际）组ID。\\n n    Process.gid   #=> 500", "name": "setsid", "namespace": "Process", "path": "Process#setsid", "type": "module_function", "visibility": "private"}, "Process#times": {"description": "在这个过程的补充组访问列表中获取<code>Array</code>个组的GID。\\n n    Process.groups   #=> [27, 6, 10, 11]", "name": "times", "namespace": "Process", "path": "Process#times", "type": "module_function", "visibility": "private"}, "Process#uid": {"description": "将补充组访问列表设置为给定的\\n <code>Array</code>组ID。n \n   Process.groups   #=> [0, 1, 2, 3, 4, 6, 10, 11, 20, 26, 27]\n   Process.groups = [27, 6, 10, 11]   #=> [27, 6, 10, 11]\n   Process.groups   #=> [27, 6, 10, 11]", "name": "uid", "namespace": "Process", "path": "Process#uid", "type": "module_function", "visibility": "private"}, "Process#uid=": {"description": "通过读取系统组数据库并使用给定用户所属的所有组初始化补充组访问列表。具有指定<em>gid的组也添加到列表中。返回补充组访问列表中所有组的GID结果<code>Array</code>。并非所有平台都可用。n \n   Process.groups   #=> [0, 1, 2, 3, 4, 6, 10, 11, 20, 26, 27]\n   Process.initgroups( \"mgranger\", 30 )   #=> [30, 6, 10, 11]\n   Process.groups   #=> [30, 6, 10, 11]", "name": "uid=", "namespace": "Process", "path": "Process#uid=", "type": "module_function", "visibility": "private"}, "Process#wait": {"description": "设置补充组访问列表中允许的最大gid数。", "name": "wait", "namespace": "Process", "path": "Process#wait", "type": "module_function", "visibility": "private"}, "Process#wait2": {"description": "返回此进程的进程ID。并非所有平台都可用。\\n n    Process.pid   #=> 27415", "name": "wait2", "namespace": "Process", "path": "Process#wait2", "type": "module_function", "visibility": "private"}, "Process#waitall": {"description": "返回补充组访问列表中允许的最大gid数。\\n n    Process.maxgroups   #=> 32", "name": "waitall", "namespace": "Process", "path": "Process#waitall", "type": "module_function", "visibility": "private"}, "Process#waitpid": {"description": "设置补充组访问列表中允许的最大gid数。", "name": "waitpid", "namespace": "Process", "path": "Process#waitpid", "type": "module_function", "visibility": "private"}, "Process#waitpid2": {"description": "返回此进程的进程ID。并非所有平台都可用。\\n n    Process.pid   #=> 27415", "name": "waitpid2", "namespace": "Process", "path": "Process#waitpid2", "type": "module_function", "visibility": "private"}, "Process.abort": {"description": "返回此进程的进程ID。并非所有平台都可用。\\n n    Process.pid   #=> 27415", "name": "abort", "namespace": "Process", "path": "Process.abort", "type": "module_function", "visibility": "public"}, "Process.argv0": {"description": "返回此进程的父进程的进程ID。在win32/64上返回不可信的值。并非所有平台都可用。\\n \n   puts \"I am #{Process.pid}\"\n   Process.fork { puts \"Dad is #{Process.ppid}\" }\n \\n<em>产生：.<em>\\n \n   I am 27417\n dad is 27417", "name": "argv0", "namespace": "Process", "path": "Process.argv0", "type": "module_function", "visibility": "public"}, "Process.clock_getres": {"description": "将PID的进程组ID（0表示此进程）设置为<em>integer。并非所有平台都可用。", "name": "clock_getres", "namespace": "Process", "path": "Process.clock_getres", "type": "module_function", "visibility": "public"}, "Process.clock_gettime": {"description": "相当于<code>setpgid(0,0)</code>。并非所有平台都可用。", "name": "clock_gettime", "namespace": "Process", "path": "Process.clock_gettime", "type": "module_function", "visibility": "public"}, "Process.daemon": {"description": "见<code>Process#getpriority</code>。n \n   Process.setpriority(Process::PRIO_USER, 0, 19)      #=> 0\n   Process.setpriority(Process::PRIO_PROCESS, 0, 19)   #=> 0\n   Process.getpriority(Process::PRIO_USER, 0)          #=> 19\n   Process.getpriority(Process::PRIO_PROCESS, 0)       #=> 19", "name": "daemon", "namespace": "Process", "path": "Process.daemon", "type": "module_function", "visibility": "public"}, "Process.detach": {"description": "设置显示在ps（1）命令上的进程标题。不一定对所有平台都有效。无论结果如何，都不会引发异常，即使平台不支持该功能，也不会引发NotImplementedError。\\n \\n调用此方法不会影响$0的值。\\n \n   Process.setproctitle('myapp: worker #%d' % worker_id)\n \\n此方法首先出现在Ruby2.1中，用作更改进程标题的全局无变量方法。", "name": "detach", "namespace": "Process", "path": "Process.detach", "type": "module_function", "visibility": "public"}, "Process.egid": {"description": "设置进程的资源限制。\\n cur-limit表示当前（软）限制，max-limit表示最大（硬）限制。\\n \\n如果未给定max_限制，则使用cur_限制。\\n \\n resource表示要限制的资源类型。\\n它应该是<code>:CORE</code>之类的符号，或者是<code>\"CORE\"</code>之类的字符串，或者是<code>Process::RLIMIT_CORE</code>之类的常量。\\n可用资源依赖于操作系统。\\n Ruby可能支持以下资源。\\n \\n[as]总可用内存（字节）（susv3，netbsd，freebsd，openbsd but 4.4bsd-lite）：n[CORE]核心大小（字节）（susv3）：n[cpu]CPU时间（秒）（susv3）：n[DATA]数据段（字节）（susv3）：n[FSIZE]文件大小（字节）（susv3）：n[MEMLOCK]MLock的总大小（2）（字节）（4.4bsd，gnu/linux）：n[MSGQUEUE]POSIX的分配消息队列（字节）（gnu/linux）进程nice（2）值（number）（gnu/linux）上限\\n[NOFILE]文件描述符（number）（susv3）n[NPROC]用户进程数（number）（4.4bsd，gnu/linux）上限\\n[rss]常驻内存大小（字节）（4.2bsd，gnu/linux）上限\\n[RTPRIO]进程实时优先级上限（number）（gnu/linux）实时进程的CPU时间（us）（gnu/linux）的CPU时间\\n[SBSIZE]所有套接字缓冲区（字节）（netbsd，freebsd）的CPU时间\\n[SIGPENDING]允许的排队信号数（信号）（gnu/linux）的CPU时间\\n[STACK]堆栈大小（字节）（susv3）的CPU时间\\n \\n cur limit_u和\\u max_限制可以是<code>:INFINITY</code>、<code>\"INFINITY\"</code>或<code>Process::RLIM_INFINITY</code>，这意味着资源不是有限的。\\n它们可能是<code>Process::RLIM_SAVED_MAX</code>、\\n <code>Process::RLIM_SAVED_CUR</code>以及相应的符号和字符串。\\n有关详细信息，请参阅系统setrlimit（2）手册。\\n \\n下面的示例将核心大小的软限制提高到硬限制，以尝试使核心转储成为可能。\\n \\n process.setrlimit（：CORE，process.getrlimit（：CORE）[1]）", "name": "egid", "namespace": "Process", "path": "Process.egid", "type": "module_function", "visibility": "public"}, "Process.egid=": {"description": "", "name": "egid=", "namespace": "Process", "path": "Process.egid=", "type": "module_function", "visibility": "public"}, "Process.euid": {"description": "将此流程建立为新的会话和流程小组负责人，不控制TTY。返回会话ID。并非所有平台都可用。\\n n    Process.setsid   #=> 27422", "name": "euid", "namespace": "Process", "path": "Process.euid", "type": "module_function", "visibility": "public"}, "Process.euid=": {"description": "返回<code>Tms</code>结构（请参阅<code>Process::Tms</code>），其中包含此进程以及子进程的用户和系统CPU时间。n \n   t = Process.times\n   [ t.utime, t.stime, t.cutime, t.cstime ]   #=> [0.0, 0.02, 0.00, 0.00]", "name": "euid=", "namespace": "Process", "path": "Process.euid=", "type": "module_function", "visibility": "public"}, "Process.exec": {"description": "返回此进程的（实际）用户ID。\\n n    Process.uid   #=> 501", "name": "exec", "namespace": "Process", "path": "Process.exec", "type": "module_function", "visibility": "public"}, "Process.exit": {"description": "设置此进程的（用户）用户ID。并非所有平台都可用。", "name": "exit", "namespace": "Process", "path": "Process.exit", "type": "module_function", "visibility": "public"}, "Process.exit!": {"description": "等待子进程退出，返回其进程ID，并将<code>$?</code>设置为包含该进程信息的<code>Process::Status</code>对象。它等待的子级\\n取决于\\n PID\\n \\n>0的值：：等待进程ID等于PID的子级。\\n\\n 0：：等待进程组ID等于the\n        calling process.\n的任何子进程\\n- 1：：等待任何子进程（如果没有PID is\n        given).\n，则默认值为\\n<-1：：等待进程组ID等于absolute\n        value of _pid_.\n的任何子进程\\n flags参数可以是逻辑或标志值<code>Process::WNOHANG</code>（如果没有可用的子进程，则不阻止）的逻辑或标志值的逻辑或\\n或<code>Process::WUNTRACED</code>（retuRN阻止了尚未报告的儿童）。并非所有的标志都可以在所有平台上使用，但是标志值为零可以在所有平台上使用。\\n \\n如果没有子进程，则调用此方法将引发SystemCallError。并非所有平台都可用。n \n   include Process\n   fork { exit 99 }                 #=> 27429\n   wait                             #=> 27429\n   $?.exitstatus                    #=> 99\n\n   pid = fork { sleep 3 }           #=> 27440\n   Time.now                         #=> 2008-03-08 19:56:16 +0900\n   waitpid(pid, Process::WNOHANG)   #=> nil\n   Time.now                         #=> 2008-03-08 19:56:16 +0900\n   waitpid(pid, 0)                  #=> 27440\n   Time.now                         #=> 2008-03-08 19:56:19 +0900", "name": "exit!", "namespace": "Process", "path": "Process.exit!", "type": "module_function", "visibility": "public"}, "Process.fork": {"description": "等待子进程退出（请参阅process:：waitpid了解确切的语义），并返回包含进程ID和该子进程的退出状态（<code>Process::Status</code>对象）的数组。如果没有子进程，则引发SystemCallError。n \n   Process.fork { exit 99 }   #=> 27437\n   pid, status = Process.wait2\n   pid                        #=> 27437\n   status.exitstatus          #=> 99", "name": "fork", "namespace": "Process", "path": "Process.fork", "type": "module_function", "visibility": "public"}, "Process.getpgid": {"description": "等待所有子对象，返回一个“pid”（状态）对数组（其中状态为<code>Process::Status</code>对象）。\\n \n   fork { sleep 0.2; exit 2 }   #=> 27432\n   fork { sleep 0.1; exit 1 }   #=> 27433\n   fork {            exit 0 }   #=> 27434\n   p Process.waitall\n \\n<em>生成</em>：\\n \n   [[30982, #<Process::Status: pid 30982 exit 0>],\n    [30979, #<Process::Status: pid 30979 exit 1>],\n[30976，<process:：status:pid 30976 exit 2>]", "name": "getpgid", "namespace": "Process", "path": "Process.getpgid", "type": "module_function", "visibility": "public"}, "Process.getpgrp": {"description": "等待子进程退出，返回其进程ID，并将<code>$?</code>设置为包含该进程信息的<code>Process::Status</code>对象。它等待的子级\\n取决于\\n PID\\n \\n>0的值：：等待进程ID等于PID的子级。\\n\\n 0：：等待进程组ID等于the\n        calling process.\n的任何子进程\\n- 1：：等待任何子进程（如果没有PID is\n        given).\n，则为默认值\\n<-1：：等待进程组ID等于absolute\n        value of _pid_.\n的任何子进程\\n flags参数可以是逻辑或标志值<code>Process::WNOHANG</code>（如果没有可用的子进程，则不阻止）的逻辑或标志值的逻辑或\\n或<code>Process::WUNTRACED</code>（retuRN阻止了尚未报告的儿童）。并非所有的标志都可以在所有平台上使用，但是标志值为零可以在所有平台上使用。\\n \\n如果没有子进程，则调用此方法将引发SystemCallError。并非所有平台都可用。n \n   include Process\n   fork { exit 99 }                 #=> 27429\n   wait                             #=> 27429\n   $?.exitstatus                    #=> 99\n\n   pid = fork { sleep 3 }           #=> 27440\n   Time.now                         #=> 2008-03-08 19:56:16 +0900\n   waitpid(pid, Process::WNOHANG)   #=> nil\n   Time.now                         #=> 2008-03-08 19:56:16 +0900\n   waitpid(pid, 0)                  #=> 27440\n   Time.now                         #=> 2008-03-08 19:56:19 +0900", "name": "getpgrp", "namespace": "Process", "path": "Process.getpgrp", "type": "module_function", "visibility": "public"}, "Process.getpriority": {"description": "等待子进程退出（请参阅process:：waitpid了解确切的语义），并返回包含进程ID和该子进程的退出状态（<code>Process::Status</code>对象）的数组。如果没有子进程，则引发SystemCallError。n \n   Process.fork { exit 99 }   #=> 27437\n   pid, status = Process.wait2\n   pid                        #=> 27437\n   status.exitstatus          #=> 99", "name": "getpriority", "namespace": "Process", "path": "Process.getpriority", "type": "module_function", "visibility": "public"}, "Process.getrlimit": {"description": "通过拨打<code>Kernel.exit(false)</code>立即终止执行。如果给出msg，则在终止之前将其写入\\n STDERR。", "name": "getrlimit", "namespace": "Process", "path": "Process.getrlimit", "type": "module_function", "visibility": "public"}, "Process.getsid": {"description": "返回正在执行的脚本的名称。该值不受为$0分配新值的影响。\\n \\n此方法首先出现在Ruby2.1中，用作获取脚本名称的全局变量释放方法。", "name": "getsid", "namespace": "Process", "path": "Process.getsid", "type": "module_function", "visibility": "public"}, "Process.gid": {"description": "返回POSIX clock_getres（）函数返回的时间分辨率。\\n \\n +clock_id+指定一种时钟。\\n有关详细信息，请参阅+process.clock \\gettime+的文档。\\n \\n +clock_id+可以是符号as+process.clock\\u gettime+。\\n但是，结果可能不准确。\\n例如，+process.clock\\getres（：GETTIMEOFDAY_BASED_CLOCK_REALTIME）+\\n返回1.0e-06，这意味着1微秒，但实际分辨率可能更粗糙。\\n \\n如果不支持给定的+clock_id+，将引发errno:：EINVAL。\\n \\n +unit+指定返回值的类型。\\n+process.clock_getres+接受+unit+作为+process.clock_gettime+。\\n默认值“+：float_second+”与\\n+process.clock_gettime+相同。\\n \\n+进程。时钟\\u getres+也接受+：赫兹+作为+unit+。\\n+：赫兹+表示+：float_second+的倒数。\\n \\n+：赫兹+可用于获取times（）函数和clock（）函数的每秒时钟滴答数的准确值CLOCKS_PER_SEC。\\n \\n+process.clock_getres（：TIMES_BASED_CLOCK_PROCESS_CPUTIME_ID，：赫兹）+\\n返回每秒的时钟计时。\\n \\n+process.clock_getres（：CLOCK_BASED_CLOCK_PROCESS_CPUTIME_ID，：赫兹）+\\n返回CLOCKS_PER_SEC。n \n  p Process.clock_getres(Process::CLOCK_MONOTONIC)\n  #=> 1.0e-09", "name": "gid", "namespace": "Process", "path": "Process.gid", "type": "module_function", "visibility": "public"}, "Process.gid=": {"description": "返回POSIX clockgettime（）函数返回的时间。\\n \n  p Process.clock_gettime(Process::CLOCK_MONOTONIC)\n  #=> 896053.968060096\n \\n +clock_id+指定一种时钟。\\n它被指定为以<code>Process::CLOCK_</code>开头的常量，例如process:：CLOCK_REALTIME和process:：CLOCK_MONOTONIC。\\n \\n受支持的常量取决于操作系统和版本。\\n ruby提供以下+clock_id+类型（如果可用）。\\n \\n[CLOCK_REALTIME_FAST2]SUSv2至4、Linux2.5.63、FreeBSD 3.0、NetBSD 2.0、OpenBSD 2.1、MacOS 10.12 \\n[CLOCK_REALTIME_FAST3]SUSv3至4、Linux2.5.63、FreeBSD 3.0、NetBSD 2.0、OpenBSD 3.4、MacOS 10.12 \\n[CLOCK_REALTIME_FAST4]SUSv3至4、Linux2.5.63、OpenBSD 5.4、MacOS 10.12 \\n[CLOCK_REALTIME_FAST5]SUSv3至4、Linux2.5.63、FreeBSD 7.12.1、FreeBSD 2.1、OpenBSD 2.1、MacOS 10.1、OpenBSD 2.1、MacOS 10.12\\n[CLOCK_REALTIME_FAST3]100606.1，OpenBSD 5.4，MacOS 10.12\\n[CLOCK_VIRTUAL]免费3.0，OpenBSD 2.1 \\n[CLOCK_REALTIME_FAST7]FreeBSD 3.0，OpenBSD 2.1 \\n[CLOCK_REALTIME_FAST]FreeBSD 8.1 \\n[CLOCK_REALTIME_FAST]FreeBSD 8.1 \\n[CLOCK_REALTIME_FAST9]FreeBSD 8.1 \\n[CLOCK_REALTIME_COARSE]Linux2.6.32 \\n[CLOCK_REALTIME_ALARM]Linux3.0\\n[CLOCK_REALTIME_ALARM]Linux3.0 \\n[CLOCK_MONOTONIC_FAST]FreeBSD 2.1 \\n[CLOCK_MONOTONIC_PRECISE]FreeBSD 8.1 \\n[CLOCK_REALTIME_FAST7]FreeBSD 3.3.0]FreeBSD 3.0 3.0 3.0，OpenBSD 3.1]FreeBSD 3.1 \\n[CLOCK_PROF]FreeBSD 3.0 3.3.0 12 \\n[CLOCK_BOOTTIME]Linux 2.6.39 \\n[CLOCK_BOOTTIME_ALARM]Linux 3.0 \\n[CLOCK_UPTIME]freebsd 7.0，openbsd 5.5 \\n[CLOCK_UPTIME_FAST]freebsd 8.1 \\n[CLOCK_UPTIME_RAW]macos 10.12 \\n[CLOCK_UPTIME_RAW_APPROX]macos 10.12 \\n[CLOCK_UPTIME_PRECISE]freebsd 8.1 \\n[CLOCK_SECOND]freebsd 8.1 \\n \\n请注意sus代表单个unix规范。\\n SUS包含POSIX，clock_gettime在POSIX部分中定义。\\n sus定义CLOCK_REALTIME是必需的，但CLOCK_MONOTONIC、CLOCK_PROCESS_CPUTIME_ID和CLOCK_THREAD_CPUTIME_ID是可选的。\\n \\n此外，多个符号被接受为+clock_id+。\\n有clock \\gettime（）的模拟。\\n \\n例如，当时钟\\u gettime（）不可用时，进程：：CLOCK_REALTIME定义为\\n+：GETTIMEOFDAY_BASED_CLOCK_REALTIME+。\\n \\n对+CLOCK_REALTIME+的模拟：\\n[：GETTIMEOFDAY_BASED_CLOCK_REALTIME]\n  Use gettimeofday() defined by SUS.\n  (SUSv4 obsoleted it, though.)\n  The resolution is 1 microsecond.\n[：TIME_BASED_CLOCK_REALTIME]\n  Use time() defined by ISO C.\n  The resolution is 1 second.\n \\n对+CLOCK_MONOTONIC+的模拟：\\n[：MACH_ABSOLUTE_TIME_BASED_CLOCK_MONOTONIC]\n  Use mach_absolute_time(), available on Darwin.\n  The resolution is CPU dependent.\n[：TIMES_BASED_CLOCK_MONOTONIC]\n  Use the result value of times() defined by POSIX.\n  POSIX defines it as \"times() shall return the elapsed real time, in clock ticks, since an arbitrary point in the past (for example, system start-up time)\".\n  For example, GNU/Linux returns a value based on jiffies and it is monotonic.\n  However, 4.4BSD uses gettimeofday() and it is not monotonic.\n  (FreeBSD uses clock_gettime(CLOCK_MONOTONIC) instead, though.)\n  The resolution is the clock tick.\n  \"getconf CLK_TCK\" command shows the clock ticks per second.\n  (The clock ticks per second is defined by HZ macro in older systems.)\n  If it is 100 and clock_t is 32 bits integer type, the resolution is 10 millisecond and\n  cannot represent over 497 days.\n \\n对+CLOCK_PROCESS_CPUTIME_ID+的模拟：\\n[：GETRUSAGE_BASED_CLOCK_PROCESS_CPUTIME_ID]\n  Use getrusage() defined by SUS.\n  getrusage() is used with RUSAGE_SELF to obtain the time only for\n  the calling process (excluding the time for child processes).\n  The result is addition of user time (ru_utime) and system time (ru_stime).\n  The resolution is 1 microsecond.\n[：TIMES_BASED_CLOCK_PROCESS_CPUTIME_ID]\n  Use times() defined by POSIX.\n  The result is addition of user time (tms_utime) and system time (tms_stime).\n  tms_cutime and tms_cstime are ignored to exclude the time for child processes.\n  The resolution is the clock tick.\n  \"getconf CLK_TCK\" command shows the clock ticks per second.\n  (The clock ticks per second is defined by HZ macro in older systems.)\n  If it is 100, the resolution is 10 millisecond.\n[：CLOCK_BASED_CLOCK_PROCESS_CPUTIME_ID]\n  Use clock() defined by ISO C.\n  The resolution is 1/CLOCKS_PER_SEC.\n  CLOCKS_PER_SEC is the C-level macro defined by time.h.\n  SUS defines CLOCKS_PER_SEC is \n   ary = [1, \"two\", 3.0] #=> [1, \"two\", 3.0]\n.\n  Non-Unix systems may define it a different value, though.\n  If CLOCKS_PER_SEC is \n   ary = [1, \"two\", 3.0] #=> [1, \"two\", 3.0]\n as SUS, the resolution is 1 microsecond.\n  If CLOCKS_PER_SEC is \n   ary = [1, \"two\", 3.0] #=> [1, \"two\", 3.0]\n and clock_t is 32 bits integer type, it cannot represent over 72 minutes.\n \\n如果不支持给定的+clock_id+，则引发错误号：：EINVAL。\\n \\n +unit+指定返回值的类型。\\n \\n[：float_second]作为浮点的秒数（默认值）\\n[：float_millisecond]作为浮点的毫秒数\\n[：float_microsecond]作为浮点的微秒数\\n[：second]作为整数的秒数\\n[：millisecond]作为整数的毫秒数\\n[：microsecond]作为整数的微秒数\\n[：纳秒]以整数表示的纳秒数\\n \\n基础函数clock \\u gettime（）返回纳秒数。\\n float对象（IEEE 754 double）不足以表示CLOCK_REALTIME的返回值。\\n如果需要精确的纳秒值，请使用+：纳秒+作为+unit+。\\n \\n传回值的来源（零）会有所不同。\\n例如，系统启动时间、进程启动时间、epoch等。\\n \\n CLOCK_REALTIME中的原点定义为epoch（1970-01-01 00:00:00 UTC）。\\n但有些系统计算闰秒，而其他系统不计算闰秒。\\n因此，可以在不同的系统中对结果进行不同的解释。\\n建议Time.now大于CLOCK_REALTIME。", "name": "gid=", "namespace": "Process", "path": "Process.gid=", "type": "module_function", "visibility": "public"}, "Process.groups": {"description": "将进程与控制终端分离，并作为系统守护程序在后台运行。除非参数nochdir为true（即非false），否则它会将当前工作目录更改为根（“/”）。除非参数noclose为true，否则daemon（）会将标准输入、标准输出和标准错误重定向到/dev/null。\\n成功时返回零，或引发一个errno:：*。", "name": "groups", "namespace": "Process", "path": "Process.groups", "type": "module_function", "visibility": "public"}, "Process.groups=": {"description": "一些操作系统保留终止的子进程的状态，直到父进程收集到该状态（通常使用<code>wait()</code>的某个变量）。如果父级从不收集此状态，则子级将作为僵尸保留在周围。\\n <code>Process::detach</code>通过设置一个单独的Ruby线程来防止这种情况，该线程的唯一任务是在进程PID终止时获取其状态。仅当不打算显式等待子级终止时才使用<code>detach</code>。\\n \\n等待线程终止时返回分离进程的退出状态，因此可以使用<code>Thread#join</code>了解结果。如果指定的PID不是有效的子进程ID，则线程将立即返回+nil+。\\n \\n等待线程具有<code>pid</code>方法，该方法返回PID。\\n \\n在第一个示例中，我们不获取第一个子进程，因此它在进程状态显示中显示为僵尸。\\n \n   p1 = fork { sleep 0.1 }\n   p2 = fork { sleep 0.2 }\n   Process.waitpid(p2)\n   sleep 2\n   system(\"ps -ho pid,state -p #{p1}\")\n \\n<em>products:-<em>\\n \n   27389 Z\n \\n在下一个示例中，<code>Process::detach</code>用于自动获取子级。\\n \n   p1 = fork { sleep 0.1 }\n   p2 = fork { sleep 0.2 }\n   Process.detach(p1)\n   Process.waitpid(p2)\n   sleep 2\n   system(\"ps -ho pid,state -p #{p1}\")\n \\n<em>（products no output）</em>", "name": "groups=", "namespace": "Process", "path": "Process.groups=", "type": "module_function", "visibility": "public"}, "Process.initgroups": {"description": "返回此进程的有效组ID。并非所有平台都可用。\\n n    Process.egid   #=> 500", "name": "initgroups", "namespace": "Process", "path": "Process.initgroups", "type": "module_function", "visibility": "public"}, "Process.kill": {"description": "返回此进程的有效用户ID。\\n n    Process.euid   #=> 501", "name": "kill", "namespace": "Process", "path": "Process.kill", "type": "module_function", "visibility": "public"}, "Process.last_status": {"description": "设置此进程的有效用户ID。并非所有平台都可用。", "name": "last_status", "namespace": "Process", "path": "Process.last_status", "type": "module_function", "visibility": "public"}, "Process.maxgroups": {"description": "通过运行给定的外部命令来替换当前进程，该外部命令可以采用以下形式之一：\\n\\n[<code>exec(commandline)</code>]\\n传递给标准shell的命令行字符串\\n[<code>exec(cmdname, arg1, ...)</code>]\\n命令名和一个或多个参数（无shell）\\n[<code>exec([cmdname, argv0], arg1, ...)</code>]\\n命令名、argv[0]和零个或多个参数（无shell）\\n\\n在FI中rst形式，字符串被作为命令行，在执行之前要进行shell扩展。\\n \\n在类Unix系统上，标准shell始终意味着<code>\"/bin/sh\"</code>，与<code>ENV[\"RUBYSHELL\"]</code> \\n（或Windows NT系列上的<code>ENV[\"COMSPEC\"]</code>）相同，并且类似。\\n \\n如果第一个表单（<code>exec(\"command\")</code>）中的字符串遵循以下简单规则：\\n \\n*没有元字符\\n*没有shell保留字和特殊内置字\\n*ruby在没有shell的情况下直接调用命令\\n \\n可以通过向字符串中添加“；”来强制shell调用（因为“；”是元字符）。\\n \\n请注意，此行为可通过获取的pid观察到\\n（prown（）的返回值和io.popen的io pid）是被调用命令的pid，而不是shell。\\n \\n在第二种形式（<code>exec(\"command1\", \"arg1\", ...)</code>）中，第一种形式作为命令名，其余形式作为参数传递给命令，不进行shell扩展。\\n \\n在第三种形式（<code>exec([\"command\", \"argv0\"], \"arg1\", ...)</code>）中，从命令开头的两元素数组开始，第一个元素是要执行的命令，第二个参数用作<code>argv[0]</code>值，该值可能显示在进程列表中。\\n \\n为了执行该命令，将使用<code>exec(2)</code>系统调用之一，因此正在运行的命令可能会继承原始程序的某些环境（包括打开的文件描述符）。\\n \\n此行为由给定的+env+和+options+参数修改。有关详细信息，请参阅\\n:：Spawn。\\n \\n如果命令无法执行（通常在找不到时为<code>Errno::ENOENT</code>），则会引发SystemCallError异常。\\n \\n此方法在<code>exec(2)</code>系统调用之前根据给定的+options+修改进程属性。有关给定+options+的详细信息，请参见：：spawn。\\n \\n当<code>exec(2)</code>系统调用失败时，可以保留修改的属性。\\n \\n例如，硬资源限制不可恢复。\\n \\n如果不可接受，请考虑使用：：spawn或kernel系统创建子进程。\\n \n   exec \"echo *\"       # echoes list of files in current directory\n   # never get here\n\n   exec \"echo\", \"*\"    # echoes an asterisk\n永远不要到这里", "name": "maxgroups", "namespace": "Process", "path": "Process.maxgroups", "type": "module_function", "visibility": "public"}, "Process.maxgroups=": {"description": "通过引发<code>SystemExit</code>异常来启动Ruby脚本的终止。可能会捕获此异常。可选参数用于将状态代码返回到调用环境。\\n状态的+true+和+FALSE+分别表示成功和失败。其他整数值的解释取决于系统。\\n \n   begin\n     exit\n     puts \"never get here\"\n   rescue SystemExit\n     puts \"rescued a SystemExit exception\"\n   end\n   puts \"after begin block\"\n \\n<em>生成：.<em>\\n \n   rescued a SystemExit exception\n   after begin block\n \\n就在终止之前，Ruby执行任何<code>at_exit</code>函数\\n（请参阅kernel:：at_exit）并运行任何对象终结器（请参阅ObjectSpace:：define_finalizer）。\\n \n   at_exit { puts \"at_exit function\" }\n   ObjectSpace.define_finalizer(\"string\",  proc { puts \"in finalizer\" })\n   exit\n \\n<em>产生：.<em>\\n \n   at_exit function\n in finalizer", "name": "maxgroups=", "namespace": "Process", "path": "Process.maxgroups=", "type": "module_function", "visibility": "public"}, "Process.pid": {"description": "立即退出进程。没有运行退出处理程序。<em>status<em>作为退出状态返回到基础系统。\\n \\n process.exit！（真）", "name": "pid", "namespace": "Process", "path": "Process.pid", "type": "module_function", "visibility": "public"}, "Process.ppid": {"description": "创建子进程。如果指定了块，则该块在子进程中运行，子进程以零状态终止。否则，+fork+调用将返回两次，一次在父级中，返回子级的进程ID，一次在子级中，返回nil。子进程可以使用<code>Kernel.exit!</code>退出，以避免运行任何<code>at_exit</code>函数。父进程应该使用<code>Process.wait</code>来收集其子进程的终止状态，或者使用<code>Process.detach</code>在其status;中注册disinterest，否则，操作系统可能会累积僵尸进程。\\n \\n线程调用分叉是创建的子进程中唯一的线程。\\n fork不复制其他线程。\\n \\n如果fork不可用，process.response\\u？（：fork）返回false。\\n \\n请注意，fork（2）在某些平台（如Windows和NetBSD 4）上不可用。\\n因此，您应该使用spawn（）而不是fork（）。", "name": "ppid", "namespace": "Process", "path": "Process.ppid", "type": "module_function", "visibility": "public"}, "Process.setpgid": {"description": "返回给定进程ID的进程组ID。并非所有平台都可用。\\n n    Process.getpgid(Process.ppid())   #=> 25527", "name": "setpgid", "namespace": "Process", "path": "Process.setpgid", "type": "module_function", "visibility": "public"}, "Process.setpgrp": {"description": "返回此进程的进程组ID。并非所有平台都可用。n \n   Process.getpgid(0)   #=> 25527\n   Process.getpgrp      #=> 25527", "name": "setpgrp", "namespace": "Process", "path": "Process.setpgrp", "type": "module_function", "visibility": "public"}, "Process.setpriority": {"description": "获取指定进程、进程组或用户的计划优先级。<em>kind<em>表示要查找的实体类型：<code>Process::PRIO_PGRP</code>、<code>Process::PRIO_USER</code>或<code>Process::PRIO_PROCESS</code>中的一个。整数是指示特定进程、进程组或用户的ID（ID为0表示当前）。较低的优先级更有利于调度。并非所有平台都可用。n \n   Process.getpriority(Process::PRIO_USER, 0)      #=> 19\n   Process.getpriority(Process::PRIO_PROCESS, 0)   #=> 19", "name": "setpriority", "namespace": "Process", "path": "Process.setpriority", "type": "module_function", "visibility": "public"}, "Process.setproctitle": {"description": "获取进程的资源限制。\\n cur-limit表示当前（软）限制，max-limit表示最大（硬）限制。\\n \\n resource表示要限制的资源类型。\\n它被指定为一个符号（如<code>:CORE</code>）、一个字符串（如<code>\"CORE\"</code>）或一个常量（如<code>Process::RLIMIT_CORE</code>）。\\n有关详细信息，请参阅Process.setrlimit。\\n \\n cur_limit_uu和max_limit可以是<code>Process::RLIM_INFINITY</code>、\\n <code>Process::RLIM_SAVED_MAX</code>或<code>Process::RLIM_SAVED_CUR</code>。\\n有关详细信息，请参阅Process.setrlimit和系统getrlimit（2）手册。", "name": "setproctitle", "namespace": "Process", "path": "Process.setproctitle", "type": "module_function", "visibility": "public"}, "Process.setrlimit": {"description": "返回给定进程ID的会话ID。如果没有给定，则返回当前进程ID。并非所有平台都可用。n \n   Process.getsid()                #=> 27422\n   Process.getsid(0)               #=> 27422\n   Process.getsid(Process.pid())   #=> 27422", "name": "setrlimit", "namespace": "Process", "path": "Process.setrlimit", "type": "module_function", "visibility": "public"}, "Process.setsid": {"description": "返回此进程的（实际）组ID。\\n n    Process.gid   #=> 500", "name": "setsid", "namespace": "Process", "path": "Process.setsid", "type": "module_function", "visibility": "public"}, "Process.spawn": {"description": "设置此进程的组ID。", "name": "spawn", "namespace": "Process", "path": "Process.spawn", "type": "module_function", "visibility": "public"}, "Process.times": {"description": "在这个过程的补充组访问列表中获取<code>Array</code>个组的GID。\\n n    Process.groups   #=> [27, 6, 10, 11]", "name": "times", "namespace": "Process", "path": "Process.times", "type": "module_function", "visibility": "public"}, "Process.uid": {"description": "将补充组访问列表设置为给定的\\n <code>Array</code>组ID。n \n   Process.groups   #=> [0, 1, 2, 3, 4, 6, 10, 11, 20, 26, 27]\n   Process.groups = [27, 6, 10, 11]   #=> [27, 6, 10, 11]\n   Process.groups   #=> [27, 6, 10, 11]", "name": "uid", "namespace": "Process", "path": "Process.uid", "type": "module_function", "visibility": "public"}, "Process.uid=": {"description": "通过读取系统组数据库并使用给定用户所属的所有组初始化补充组访问列表。具有指定<em>gid的组也添加到列表中。返回补充组访问列表中所有组的GID结果<code>Array</code>。并非所有平台都可用。n \n   Process.groups   #=> [0, 1, 2, 3, 4, 6, 10, 11, 20, 26, 27]\n   Process.initgroups( \"mgranger\", 30 )   #=> [30, 6, 10, 11]\n   Process.groups   #=> [30, 6, 10, 11]", "name": "uid=", "namespace": "Process", "path": "Process.uid=", "type": "module_function", "visibility": "public"}, "Process.wait": {"description": "设置补充组访问列表中允许的最大gid数。", "name": "wait", "namespace": "Process", "path": "Process.wait", "type": "module_function", "visibility": "public"}, "Process.wait2": {"description": "返回此进程的进程ID。并非所有平台都可用。\\n n    Process.pid   #=> 27415", "name": "wait2", "namespace": "Process", "path": "Process.wait2", "type": "module_function", "visibility": "public"}, "Process.waitall": {"description": "返回补充组访问列表中允许的最大gid数。\\n n    Process.maxgroups   #=> 32", "name": "waitall", "namespace": "Process", "path": "Process.waitall", "type": "module_function", "visibility": "public"}, "Process.waitpid": {"description": "设置补充组访问列表中允许的最大gid数。", "name": "waitpid", "namespace": "Process", "path": "Process.waitpid", "type": "module_function", "visibility": "public"}, "Process.waitpid2": {"description": "返回此进程的进程ID。并非所有平台都可用。\\n n    Process.pid   #=> 27415", "name": "waitpid2", "namespace": "Process", "path": "Process.waitpid2", "type": "module_function", "visibility": "public"}, "Process::CLOCK_BOOTTIME": {"description": "see Process.clock_gettime", "name": "CLOCK_BOOTTIME", "namespace": "Process", "path": "Process::CLOCK_BOOTTIME", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "Process::CLOCK_BOOTTIME_ALARM": {"description": "see Process.clock_gettime", "name": "CLOCK_BOOTTIME_ALARM", "namespace": "Process", "path": "Process::CLOCK_BOOTTIME_ALARM", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "Process::CLOCK_MONOTONIC": {"description": "see Process.clock_gettime", "name": "CLOCK_MONOTONIC", "namespace": "Process", "path": "Process::CLOCK_MONOTONIC", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "Process::CLOCK_MONOTONIC_COARSE": {"description": "see Process.clock_gettime", "name": "CLOCK_MONOTONIC_COARSE", "namespace": "Process", "path": "Process::CLOCK_MONOTONIC_COARSE", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "Process::CLOCK_MONOTONIC_FAST": {"description": "see Process.clock_gettime", "name": "CLOCK_MONOTONIC_FAST", "namespace": "Process", "path": "Process::CLOCK_MONOTONIC_FAST", "type": "constant", "return": null, "visibility": "public"}, "Process::CLOCK_MONOTONIC_PRECISE": {"description": "see Process.clock_gettime", "name": "CLOCK_MONOTONIC_PRECISE", "namespace": "Process", "path": "Process::CLOCK_MONOTONIC_PRECISE", "type": "constant", "return": null, "visibility": "public"}, "Process::CLOCK_MONOTONIC_RAW": {"description": "see Process.clock_gettime", "name": "CLOCK_MONOTONIC_RAW", "namespace": "Process", "path": "Process::CLOCK_MONOTONIC_RAW", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "Process::CLOCK_MONOTONIC_RAW_APPROX": {"description": "see Process.clock_gettime", "name": "CLOCK_MONOTONIC_RAW_APPROX", "namespace": "Process", "path": "Process::CLOCK_MONOTONIC_RAW_APPROX", "type": "constant", "return": null, "visibility": "public"}, "Process::CLOCK_PROCESS_CPUTIME_ID": {"description": "see Process.clock_gettime", "name": "CLOCK_PROCESS_CPUTIME_ID", "namespace": "Process", "path": "Process::CLOCK_PROCESS_CPUTIME_ID", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "Process::CLOCK_PROF": {"description": "see Process.clock_gettime", "name": "CLOCK_PROF", "namespace": "Process", "path": "Process::CLOCK_PROF", "type": "constant", "return": null, "visibility": "public"}, "Process::CLOCK_REALTIME": {"description": "see Process.clock_gettime", "name": "CLOCK_REALTIME", "namespace": "Process", "path": "Process::CLOCK_REALTIME", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "Process::CLOCK_REALTIME_ALARM": {"description": "see Process.clock_gettime", "name": "CLOCK_REALTIME_ALARM", "namespace": "Process", "path": "Process::CLOCK_REALTIME_ALARM", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "Process::CLOCK_REALTIME_COARSE": {"description": "see Process.clock_gettime", "name": "CLOCK_REALTIME_COARSE", "namespace": "Process", "path": "Process::CLOCK_REALTIME_COARSE", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "Process::CLOCK_REALTIME_FAST": {"description": "see Process.clock_gettime", "name": "CLOCK_REALTIME_FAST", "namespace": "Process", "path": "Process::CLOCK_REALTIME_FAST", "type": "constant", "return": null, "visibility": "public"}, "Process::CLOCK_REALTIME_PRECISE": {"description": "see Process.clock_gettime", "name": "CLOCK_REALTIME_PRECISE", "namespace": "Process", "path": "Process::CLOCK_REALTIME_PRECISE", "type": "constant", "return": null, "visibility": "public"}, "Process::CLOCK_SECOND": {"description": "see Process.clock_gettime", "name": "CLOCK_SECOND", "namespace": "Process", "path": "Process::CLOCK_SECOND", "type": "constant", "return": null, "visibility": "public"}, "Process::CLOCK_THREAD_CPUTIME_ID": {"description": "see Process.clock_gettime", "name": "CLOCK_THREAD_CPUTIME_ID", "namespace": "Process", "path": "Process::CLOCK_THREAD_CPUTIME_ID", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "Process::CLOCK_UPTIME": {"description": "see Process.clock_gettime", "name": "CLOCK_UPTIME", "namespace": "Process", "path": "Process::CLOCK_UPTIME", "type": "constant", "return": null, "visibility": "public"}, "Process::CLOCK_UPTIME_FAST": {"description": "see Process.clock_gettime", "name": "CLOCK_UPTIME_FAST", "namespace": "Process", "path": "Process::CLOCK_UPTIME_FAST", "type": "constant", "return": null, "visibility": "public"}, "Process::CLOCK_UPTIME_PRECISE": {"description": "see Process.clock_gettime", "name": "CLOCK_UPTIME_PRECISE", "namespace": "Process", "path": "Process::CLOCK_UPTIME_PRECISE", "type": "constant", "return": null, "visibility": "public"}, "Process::CLOCK_UPTIME_RAW": {"description": "see Process.clock_gettime", "name": "CLOCK_UPTIME_RAW", "namespace": "Process", "path": "Process::CLOCK_UPTIME_RAW", "type": "constant", "return": null, "visibility": "public"}, "Process::CLOCK_UPTIME_RAW_APPROX": {"description": "see Process.clock_gettime", "name": "CLOCK_UPTIME_RAW_APPROX", "namespace": "Process", "path": "Process::CLOCK_UPTIME_RAW_APPROX", "type": "constant", "return": null, "visibility": "public"}, "Process::CLOCK_VIRTUAL": {"description": "see Process.clock_gettime", "name": "CLOCK_VIRTUAL", "namespace": "Process", "path": "Process::CLOCK_VIRTUAL", "type": "constant", "return": null, "visibility": "public"}, "Process::GID": {"description": "see Process.clock_gettime", "name": "GID", "namespace": "Process", "path": "Process::GID", "type": "class", "visibility": "public"}, "Process::PRIO_PGRP": {"description": "see Process.clock_gettime", "name": "PRIO_PGRP", "namespace": "Process", "path": "Process::PRIO_PGRP", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "Process::PRIO_PROCESS": {"description": "see Process.clock_gettime", "name": "PRIO_PROCESS", "namespace": "Process", "path": "Process::PRIO_PROCESS", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "Process::PRIO_USER": {"description": "see Process.clock_gettime", "name": "PRIO_USER", "namespace": "Process", "path": "Process::PRIO_USER", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "Process::RLIMIT_AS": {"description": "see Process.clock_gettime", "name": "RLIMIT_AS", "namespace": "Process", "path": "Process::RLIMIT_AS", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "Process::RLIMIT_CORE": {"description": "see Process.clock_gettime", "name": "RLIMIT_CORE", "namespace": "Process", "path": "Process::RLIMIT_CORE", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "Process::RLIMIT_CPU": {"description": "see Process.clock_gettime", "name": "RLIMIT_CPU", "namespace": "Process", "path": "Process::RLIMIT_CPU", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "Process::RLIMIT_DATA": {"description": "see Process.clock_gettime", "name": "RLIMIT_DATA", "namespace": "Process", "path": "Process::RLIMIT_DATA", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "Process::RLIMIT_FSIZE": {"description": "see Process.clock_gettime", "name": "RLIMIT_FSIZE", "namespace": "Process", "path": "Process::RLIMIT_FSIZE", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "Process::RLIMIT_MEMLOCK": {"description": "see Process.clock_gettime", "name": "RLIMIT_MEMLOCK", "namespace": "Process", "path": "Process::RLIMIT_MEMLOCK", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "Process::RLIMIT_MSGQUEUE": {"description": "see Process.clock_gettime", "name": "RLIMIT_MSGQUEUE", "namespace": "Process", "path": "Process::RLIMIT_MSGQUEUE", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "Process::RLIMIT_NICE": {"description": "see Process.clock_gettime", "name": "RLIMIT_NICE", "namespace": "Process", "path": "Process::RLIMIT_NICE", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "Process::RLIMIT_NOFILE": {"description": "see Process.clock_gettime", "name": "RLIMIT_NOFILE", "namespace": "Process", "path": "Process::RLIMIT_NOFILE", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "Process::RLIMIT_NPROC": {"description": "see Process.clock_gettime", "name": "RLIMIT_NPROC", "namespace": "Process", "path": "Process::RLIMIT_NPROC", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "Process::RLIMIT_RSS": {"description": "see Process.clock_gettime", "name": "RLIMIT_RSS", "namespace": "Process", "path": "Process::RLIMIT_RSS", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "Process::RLIMIT_RTPRIO": {"description": "see Process.clock_gettime", "name": "RLIMIT_RTPRIO", "namespace": "Process", "path": "Process::RLIMIT_RTPRIO", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "Process::RLIMIT_RTTIME": {"description": "****************************************************************** \\n  \\n \n  The <code>Process::GID</code> module contains a collection of\n  module functions which can be used to portably get, set, and\n  switch the current process's real, effective, and saved group IDs.", "name": "RLIMIT_RTTIME", "namespace": "Process", "path": "Process::RLIMIT_RTTIME", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "Process::RLIMIT_SBSIZE": {"description": "see Process.setpriority", "name": "RLIMIT_SBSIZE", "namespace": "Process", "path": "Process::RLIMIT_SBSIZE", "type": "constant", "return": null, "visibility": "public"}, "Process::RLIMIT_SIGPENDING": {"description": "see Process.setpriority", "name": "RLIMIT_SIGPENDING", "namespace": "Process", "path": "Process::RLIMIT_SIGPENDING", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "Process::RLIMIT_STACK": {"description": "see Process.setpriority", "name": "RLIMIT_STACK", "namespace": "Process", "path": "Process::RLIMIT_STACK", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "Process::RLIM_INFINITY": {"description": "CPU time limit in seconds. \\n  \\n see the system getrlimit(2) manual for details.", "name": "RLIM_INFINITY", "namespace": "Process", "path": "Process::RLIM_INFINITY", "type": "constant", "return": ["Bignum", ""], "visibility": "public"}, "Process::RLIM_SAVED_CUR": {"description": "CPU time limit in seconds. \\n  \\n see the system getrlimit(2) manual for details.", "name": "RLIM_SAVED_CUR", "namespace": "Process", "path": "Process::RLIM_SAVED_CUR", "type": "constant", "return": ["Bignum", ""], "visibility": "public"}, "Process::RLIM_SAVED_MAX": {"description": "CPU time limit in seconds. \\n  \\n see the system getrlimit(2) manual for details.", "name": "RLIM_SAVED_MAX", "namespace": "Process", "path": "Process::RLIM_SAVED_MAX", "type": "constant", "return": ["Bignum", ""], "visibility": "public"}, "Process::Status": {"description": "Maximum size of the process's data segment. \\n  \\n see the system getrlimit(2) manual for details.", "name": "Status", "namespace": "Process", "path": "Process::Status", "type": "class", "visibility": "public"}, "Process::Status#&": {"description": "Maximum size of files that the process may create. \\n  \\n see the system getrlimit(2) manual for details.", "name": "&", "namespace": "Process::Status", "path": "Process::Status#&", "type": "instance_method", "visibility": "public"}, "Process::Status#==": {"description": "Maximum number of bytes of memory that may be locked into RAM. \\n  \\n see the system getrlimit(2) manual for details.", "name": "==", "namespace": "Process::Status", "path": "Process::Status#==", "type": "instance_method", "visibility": "public"}, "Process::Status#>>": {"description": "Specifies the limit on the number of bytes that can be allocated for POSIX message queues for the real user ID of the calling process. \\n  \\n see the system getrlimit(2) manual for details.", "name": ">>", "namespace": "Process::Status", "path": "Process::Status#>>", "type": "instance_method", "visibility": "public"}, "Process::Status#coredump?": {"description": "Specifies a ceiling to which the process's nice value can be raised. \\n  \\n see the system getrlimit(2) manual for details.", "name": "coredump?", "namespace": "Process::Status", "path": "Process::Status#coredump?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Process::Status#exited?": {"description": "Specifies a value one greater than the maximum file descriptor number that can be opened by this process. \\n  \\n see the system getrlimit(2) manual for details.", "name": "exited?", "namespace": "Process::Status", "path": "Process::Status#exited?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Process::Status#exitstatus": {"description": "The maximum number of processes that can be created for the real user ID of the calling process. \\n  \\n see the system getrlimit(2) manual for details.", "name": "exitstatus", "namespace": "Process::Status", "path": "Process::Status#exitstatus", "type": "instance_method", "visibility": "public"}, "Process::Status#inspect": {"description": "Specifies the limit (in pages) of the process's resident set. \\n  \\n see the system getrlimit(2) manual for details.", "name": "inspect", "namespace": "Process::Status", "path": "Process::Status#inspect", "type": "instance_method", "visibility": "public"}, "Process::Status#pid": {"description": "指定可为此进程设置的实时优先级上限。\\n \\n有关详细信息，请参阅系统getrlimit（2）手册。", "name": "pid", "namespace": "Process::Status", "path": "Process::Status#pid", "type": "instance_method", "visibility": "public"}, "Process::Status#signaled?": {"description": "指定在实时计划策略下计划的此进程可以使用的CPU时间限制。\\n \\n有关详细信息，请参阅系统getrlimit（2）手册。", "name": "signaled?", "namespace": "Process::Status", "path": "Process::Status#signaled?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Process::Status#stopped?": {"description": "套接字缓冲区的最大大小。", "name": "stopped?", "namespace": "Process::Status", "path": "Process::Status#stopped?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Process::Status#stopsig": {"description": "指定对可能排队等待调用进程的实际用户ID的信号数的限制。\\n \\n有关详细信息，请参阅系统getrlimit（2）手册。", "name": "stopsig", "namespace": "Process::Status", "path": "Process::Status#stopsig", "type": "instance_method", "visibility": "public"}, "Process::Status#success?": {"description": "堆栈的最大大小（字节）。\\n \\n有关详细信息，请参阅系统getrlimit（2）手册。", "name": "success?", "namespace": "Process::Status", "path": "Process::Status#success?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Process::Status#termsig": {"description": "参见process.setrlimit", "name": "termsig", "namespace": "Process::Status", "path": "Process::Status#termsig", "type": "instance_method", "visibility": "public"}, "Process::Status#to_i": {"description": "参见process.setrlimit", "name": "to_i", "namespace": "Process::Status", "path": "Process::Status#to_i", "type": "instance_method", "visibility": "public"}, "Process::Status#to_s": {"description": "参见process.setrlimit", "name": "to_s", "namespace": "Process::Status", "path": "Process::Status#to_s", "type": "instance_method", "visibility": "public"}, "Process::Sys": {"description": "*******************************************************************\\n\\n \n  <code>Process::Status</code> encapsulates the information on the\n  status of a running or terminated system process. The built-in\n  variable <code>$?</code> is either +nil+ or a\n  <code>Process::Status</code> object.\n\n     fork { exit 99 }   #=> 26557\n     Process.wait       #=> 26557\n     $?.class           #=> Process::Status\n     $?.to_i            #=> 25344\n     $? >> 8            #=> 99\n     $?.stopped?        #=> false\n     $?.exited?         #=> true\n     $?.exitstatus      #=> 99\n\n  Posix systems record information on processes using a 16-bit\n  integer.  The lower bits record the process status (stopped,\n  exited, signaled) and the upper bits possibly contain additional\n  information (for example the program's return code in the case of\n  exited processes). Pre Ruby 1.8, these bits were exposed directly\n  to the Ruby program. Ruby now encapsulates these in a\n  <code>Process::Status</code> object. To maximize compatibility,\n  however, these objects retain a bit-oriented interface. In the\n  descriptions that follow, when we talk about the integer value of\n _stat_u，我们指的是这个16位值。", "name": "Sys", "namespace": "Process", "path": "Process::Sys", "type": "class", "visibility": "public"}, "Process::UID": {"description": "stat中位的逻辑与与，使用<em>num>n \n   fork { exit 0x37 }\n   Process.wait\n   sprintf('%04x', $?.to_i)       #=> \"3700\"\n   sprintf('%04x', $? & 0x1e00)   #=> \"1600\"", "name": "UID", "namespace": "Process", "path": "Process::UID", "type": "class", "visibility": "public"}, "Process::WNOHANG": {"description": "将位右移到stat right<em>num<em>places。n \n   fork { exit 99 }   #=> 26563\n   Process.wait       #=> 26563\n   $?.to_i            #=> 25344\n   $? >> 8            #=> 99", "name": "WNOHANG", "namespace": "Process", "path": "Process::WNOHANG", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "Process::WUNTRACED": {"description": "将位右移到stat right<em>num<em>places。n \n   fork { exit 99 }   #=> 26563\n   Process.wait       #=> 26563\n   $?.to_i            #=> 25344\n   $? >> 8            #=> 99", "name": "WUNTRACED", "namespace": "Process", "path": "Process::WUNTRACED", "type": "constant", "return": ["Fixnum", ""], "visibility": "public"}, "Process::Waiter": {"description": "", "name": "Waiter", "namespace": "Process", "path": "Process::Waiter", "type": "class", "visibility": "public"}, "Process::Waiter#pid": {"description": "", "name": "pid", "namespace": "Process::Waiter", "path": "Process::Waiter#pid", "type": "instance_method", "visibility": "public"}, "Signal": {"description": "", "name": "Signal", "namespace": "", "path": "Signal", "type": "module", "visibility": "public"}, "Signal#list": {"description": "替代检验方法。n \n  system(\"false\")\n  p $?.inspect #=> \"#<Process::Status: pid 12861 exit 1>\"", "name": "list", "namespace": "Signal", "path": "Signal#list", "type": "module_function", "visibility": "private"}, "Signal#signame": {"description": "返回此状态对象表示的进程ID。n \n   fork { exit }   #=> 26569\n   Process.wait    #=> 26569\n   $?.pid          #=> 26569", "name": "signame", "namespace": "Signal", "path": "Signal#signame", "type": "module_function", "visibility": "private"}, "Signal#trap": {"description": "如果stat因未捕获信号而终止，则返回+true+。", "name": "trap", "namespace": "Signal", "path": "Signal#trap", "type": "module_function", "visibility": "private"}, "Signal.list": {"description": "替代检验方法。n \n  system(\"false\")\n  p $?.inspect #=> \"#<Process::Status: pid 12861 exit 1>\"", "name": "list", "namespace": "Signal", "path": "Signal.list", "type": "module_function", "visibility": "public"}, "Signal.signame": {"description": "返回此状态对象表示的进程ID。n \n   fork { exit }   #=> 26569\n   Process.wait    #=> 26569\n   $?.pid          #=> 26569", "name": "signame", "namespace": "Signal", "path": "Signal.signame", "type": "module_function", "visibility": "public"}, "Signal.trap": {"description": "如果stat因未捕获信号而终止，则返回+true+。", "name": "trap", "namespace": "Signal", "path": "Signal.trap", "type": "module_function", "visibility": "public"}, "Symbol": {"description": "如果此进程停止，则返回+true+。只有在相应的<code>wait</code>调用设置了<code>WUNTRACED</code>标志时，才会返回此消息。", "name": "Symbol", "namespace": "", "path": "Symbol", "type": "class", "visibility": "public"}, "Symbol#<=>": {"description": "返回导致stat停止的信号数\\n（如果self未停止，则返回+nil+）。", "name": "<=>", "namespace": "Symbol", "path": "Symbol#<=>", "type": "instance_method", "visibility": "public"}, "Symbol#==": {"description": "", "name": "==", "namespace": "Symbol", "path": "Symbol#==", "type": "instance_method", "visibility": "public"}, "Symbol#===": {"description": "", "name": "===", "namespace": "Symbol", "path": "Symbol#===", "type": "instance_method", "visibility": "public"}, "Symbol#=~": {"description": "如果stat成功返回+true+，否则返回+false+。\\n如果<code>exited?</code>不是+true+，则返回+nil+。", "name": "=~", "namespace": "Symbol", "path": "Symbol#=~", "type": "instance_method", "visibility": "public"}, "Symbol#[]": {"description": "返回<code>sym.to_s =~ obj</code>。", "name": "[]", "namespace": "Symbol", "path": "Symbol#[]", "type": "instance_method", "visibility": "public"}, "Symbol#capitalize": {"description": "以<code>Integer</code>的形式返回stat中的位。在这些位中四处搜索是依赖于平台的。n \n   fork { exit 0xab }         #=> 26566\n   Process.wait               #=> 26566\n   sprintf('%04x', $?.to_i)   #=> \"ab00\"", "name": "capitalize", "namespace": "Symbol", "path": "Symbol#capitalize", "type": "instance_method", "visibility": "public"}, "Symbol#casecmp": {"description": "以字符串形式显示PID和退出状态。n \n  system(\"false\")\n  p $?.to_s         #=> \"pid 12766 exit 1\"", "name": "casecmp", "namespace": "Symbol", "path": "Symbol#casecmp", "type": "instance_method", "visibility": "public"}, "Symbol#casecmp?": {"description": "*******************************************************************\\n \n  The <code>Process::Sys</code> module contains UID and GID\n  functions which provide direct bindings to the system calls of the\n  same names instead of the more-portable versions of the same\n  functionality found in the <code>Process</code>,\n <code>Process::UID</code>和<code>Process::GID</code>模块。", "name": "casecmp?", "namespace": "Symbol", "path": "Symbol#casecmp?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Symbol#downcase": {"description": "************************************************************\\n\\n \n  The <code>Process::UID</code> module contains a collection of\n  module functions which can be used to portably get, set, and\n切换当前进程的真实、有效和已保存的用户ID。", "name": "downcase", "namespace": "Symbol", "path": "Symbol#downcase", "type": "instance_method", "visibility": "public"}, "Symbol#empty?": {"description": "请参阅process.wait", "name": "empty?", "namespace": "Symbol", "path": "Symbol#empty?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Symbol#encoding": {"description": "请参阅process.wait", "name": "encoding", "namespace": "Symbol", "path": "Symbol#encoding", "type": "instance_method", "visibility": "public"}, "Symbol#id2name": {"description": "如果+sym+和+other_symbol+在Unicode大小写折叠后相等，则返回+true+；如果它们不相等，则返回+false+。\\n \n  :aBcDeF.casecmp?(:abcde)     #=> false\n  :aBcDeF.casecmp?(:abcdef)    #=> true\n  :aBcDeF.casecmp?(:abcdefg)   #=> false\n  :abcdef.casecmp?(:ABCDEF)    #=> true\n  :\"\\u{e4 f6 fc}\".casecmp?(:\"\\u{c4 d6 dc}\")   #=> true\n \\n如果这两个符号有不兼容的编码，或者+other_symbol+不是符号，则返回+nil+。n \n  :foo.casecmp?(2)   #=> nil\n  \"\\u{e4 f6 fc}\".encode(\"ISO-8859-1\").to_sym.casecmp?(:\"\\u{c4 d6 dc}\")   #=> nil", "name": "id2name", "namespace": "Symbol", "path": "Symbol#id2name", "type": "instance_method", "visibility": "public"}, "Symbol#inspect": {"description": "将信号编号转换为信号名称。\\n如果signo是无效的信号号，则返回+nil+。\\n \n    Signal.trap(\"INT\") { |signo| puts Signal.signame(signo) }\n    Process.kill(\"INT\", 0)\n \\n<em>生成：.<em>\\n\\n int", "name": "inspect", "namespace": "Symbol", "path": "Symbol#inspect", "type": "instance_method", "visibility": "public"}, "Symbol#intern": {"description": "同<code>sym.to_s.downcase.intern</code>。", "name": "intern", "namespace": "Symbol", "path": "Symbol#intern", "type": "instance_method", "visibility": "public"}, "Symbol#length": {"description": "在调用每个符号的“to”后，将+symbol+与+other_symbol+进行比较。根据+symbol+是小于、等于还是大于+other_symbol+，返回-1、0、+1或+nil+。\\n \\n如果这两个值不可比较，则返回+nil+。\\n \\n有关详细信息，请参阅字符串<=>。", "name": "length", "namespace": "Symbol", "path": "Symbol#length", "type": "instance_method", "visibility": "public"}, "Symbol#match": {"description": "将信号编号转换为信号名称。\\n如果signo是无效的信号号，则返回+nil+。\\n \n    Signal.trap(\"INT\") { |signo| puts Signal.signame(signo) }\n    Process.kill(\"INT\", 0)\n \\n<em>产生：.<em>\\n\\n int", "name": "match", "namespace": "Symbol", "path": "Symbol#match", "type": "instance_method", "visibility": "public"}, "Symbol#match?": {"description": "指定信号的处理。第一个参数是信号名（字符串，如“SIGALRM”、“sigusr1”等）或信号号。信号名称中可以省略字符“sig”。命令或块指定在发出信号时要运行的代码。\\n如果命令是字符串“IGNORE”或“SIG_IGN”，则信号将被忽略。\\n如果命令是``DEFAULT'或``SIG_DFL'，将调用Ruby的默认处理程序。\\n如果命令是``EXIT'，脚本将被信号终止。\\n如果命令为``SYSTEM_DEFAULT'，将调用操作系统的默认处理程序。\\n否则，将运行给定的命令或块。\\n在程序终止之前，将调用特殊信号名``EXIT'或信号号零。\\n trap返回给定信号的前一个处理程序。\\n \n    Signal.trap(0, proc { puts \"Terminating: #{$$}\" })\n    Signal.trap(\"CLD\")  { puts \"Child died\" }\n    fork && Process.wait\n \\n产生：\n    Terminating: 27461\n    Child died\n终止：27460", "name": "match?", "namespace": "Symbol", "path": "Symbol#match?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Symbol#next": {"description": "返回<code>sym.to_s[]</code>。", "name": "next", "namespace": "Symbol", "path": "Symbol#next", "type": "instance_method", "visibility": "public"}, "Symbol#size": {"description": "在调用每个符号的“to”后，将+symbol+与+other_symbol+进行比较。根据+symbol+是小于、等于还是大于+other_symbol+，返回-1、0、+1或+nil+。\\n \\n如果这两个值不可比较，则返回+nil+。\\n \\n有关详细信息，请参阅字符串<=>。", "name": "size", "namespace": "Symbol", "path": "Symbol#size", "type": "instance_method", "visibility": "public"}, "Symbol#slice": {"description": "返回<code>sym.to_s =~ obj</code>。", "name": "slice", "namespace": "Symbol", "path": "Symbol#slice", "type": "instance_method", "visibility": "public"}, "Symbol#succ": {"description": "返回<code>sym.to_s[]</code>。", "name": "succ", "namespace": "Symbol", "path": "Symbol#succ", "type": "instance_method", "visibility": "public"}, "Symbol#swapcase": {"description": "同<code>sym.to_s.capitalize.intern</code>。", "name": "swapcase", "namespace": "Symbol", "path": "Symbol#swapcase", "type": "instance_method", "visibility": "public"}, "Symbol#to_proc": {"description": "<code>Symbol#<=></code>的不区分大小写版本。\\n目前，大小写不敏感只适用于字符A-Z/A-z，不是所有Unicode字符。这与符号“casecmp”不同？.\\n \n  :aBcDeF.casecmp(:abcde)     #=> 1\n  :aBcDeF.casecmp(:abcdef)    #=> 0\n  :aBcDeF.casecmp(:abcdefg)   #=> -1\n  :abcdef.casecmp(:ABCDEF)    #=> 0\n \\n如果这两个符号有不兼容的编码，或者+other_symbol+不是符号，则返回+nil+。n \n  :foo.casecmp(2)   #=> nil\n  \"\\u{e4 f6 fc}\".encode(\"ISO-8859-1\").to_sym.casecmp(:\"\\u{c4 d6 dc}\")   #=> nil", "name": "to_proc", "namespace": "Symbol", "path": "Symbol#to_proc", "type": "instance_method", "visibility": "public"}, "Symbol#to_s": {"description": "如果+sym+和+other_symbol+在Unicode大小写折叠后相等，则返回+true+；如果它们不相等，则返回+false+。\\n \n  :aBcDeF.casecmp?(:abcde)     #=> false\n  :aBcDeF.casecmp?(:abcdef)    #=> true\n  :aBcDeF.casecmp?(:abcdefg)   #=> false\n  :abcdef.casecmp?(:ABCDEF)    #=> true\n  :\"\\u{e4 f6 fc}\".casecmp?(:\"\\u{c4 d6 dc}\")   #=> true\n \\n如果这两个符号有不兼容的编码，或者+other_symbol+不是符号，则返回+nil+。n \n  :foo.casecmp?(2)   #=> nil\n  \"\\u{e4 f6 fc}\".encode(\"ISO-8859-1\").to_sym.casecmp?(:\"\\u{c4 d6 dc}\")   #=> nil", "name": "to_s", "namespace": "Symbol", "path": "Symbol#to_s", "type": "instance_method", "visibility": "public"}, "Symbol#to_sym": {"description": "同<code>sym.to_s.downcase.intern</code>。", "name": "to_sym", "namespace": "Symbol", "path": "Symbol#to_sym", "type": "instance_method", "visibility": "public"}, "Symbol#upcase": {"description": "返回sym是否为：“”。", "name": "upcase", "namespace": "Symbol", "path": "Symbol#upcase", "type": "instance_method", "visibility": "public"}, "Symbol.all_symbols": {"description": "返回表示sym编码的编码对象。", "name": "all_symbols", "namespace": "Symbol", "path": "Symbol.all_symbols", "type": "class_method", "visibility": "public"}, "UnicodeNormalize": {"description": "", "name": "UnicodeNormalize", "namespace": "", "path": "UnicodeNormalize", "type": "module", "visibility": "public"}, "Struct": {"description": "返回与sym对应的名称或字符串。n \n   :fred.id2name   #=> \"fred\"\n   :ginger.to_s    #=> \"ginger\"", "name": "Struct", "namespace": "", "path": "Struct", "type": "class", "visibility": "public"}, "Struct#==": {"description": "以符号文字形式返回<i>sym的表示形式。\\n n    :fred.inspect   #=> \":fred\"", "name": "==", "namespace": "Struct", "path": "Struct#==", "type": "instance_method", "visibility": "public"}, "Struct#[]": {"description": "通常，<code>to_sym</code>返回与对象对应的<code>Symbol</code>。由于sym<i>i>is already a symbol，<code>self</code> is returned in this case.", "name": "[]", "namespace": "Struct", "path": "Struct#[]", "type": "instance_method", "visibility": "public"}, "Struct#[]=": {"description": "同<code>sym.to_s.length</code>。", "name": "[]=", "namespace": "Struct", "path": "Struct#[]=", "type": "instance_method", "visibility": "public"}, "Struct#dig": {"description": "返回<code>sym.to_s.match</code>。", "name": "dig", "namespace": "Struct", "path": "Struct#dig", "type": "instance_method", "visibility": "public"}, "Struct#each": {"description": "返回<code>sym.to_s.match?</code>。", "name": "each", "namespace": "Struct", "path": "Struct#each", "type": "instance_method", "visibility": "public"}, "Struct#each_pair": {"description": "同<code>sym.to_s.succ.intern</code>。", "name": "each_pair", "namespace": "Struct", "path": "Struct#each_pair", "type": "instance_method", "visibility": "public"}, "Struct#eql?": {"description": "同<code>sym.to_s.length</code>。", "name": "eql?", "namespace": "Struct", "path": "Struct#eql?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Struct#hash": {"description": "返回<code>sym.to_s[]</code>。", "name": "hash", "namespace": "Struct", "path": "Struct#hash", "type": "instance_method", "visibility": "public"}, "Struct#initialize": {"description": "", "name": "initialize", "namespace": "Struct", "path": "Struct#initialize", "type": "instance_method", "visibility": "public"}, "Struct#initialize_copy": {"description": ":nodoc:", "name": "initialize_copy", "namespace": "Struct", "path": "Struct#initialize_copy", "type": "instance_method", "visibility": "public"}, "Struct#inspect": {"description": "同<code>sym.to_s.swapcase.intern</code>。", "name": "to_s", "namespace": "Struct", "path": "Struct#to_s", "type": "instance_method", "visibility": "public"}, "Struct#to_s": {"description": "同<code>sym.to_s.swapcase.intern</code>。", "name": "to_s", "namespace": "Struct", "path": "Struct#to_s", "type": "instance_method", "visibility": "public"}, "Struct#length": {"description": "同<code>sym.to_s.upcase.intern</code>。", "name": "length", "namespace": "Struct", "path": "Struct#length", "type": "instance_method", "visibility": "public"}, "Struct#members": {"description": "返回与sym对应的名称或字符串。n \n   :fred.id2name   #=> \"fred\"\n   :ginger.to_s    #=> \"ginger\"", "name": "members", "namespace": "Struct", "path": "Struct#members", "type": "instance_method", "visibility": "public"}, "Struct#select": {"description": "通常，<code>to_sym</code>返回与对象对应的<code>Symbol</code>。由于sym<i>i>is already a symbol，<code>self</code> is returned in this case.", "name": "select", "namespace": "Struct", "path": "Struct#select", "type": "instance_method", "visibility": "public"}, "Struct#size": {"description": "同<code>sym.to_s.upcase.intern</code>。", "name": "size", "namespace": "Struct", "path": "Struct#size", "type": "instance_method", "visibility": "public"}, "Struct#to_a": {"description": "equality-如果+other+具有相同的结构子类并且具有相同的成员值（根据对象=），则返回+true+。n \n   Customer = Struct.new(:name, :address, :zip)\n   joe   = Customer.new(\"Joe Smith\", \"123 Maple, Anytown NC\", 12345)\n   joejr = Customer.new(\"Joe Smith\", \"123 Maple, Anytown NC\", 12345)\n   jane  = Customer.new(\"Jane Doe\", \"456 Elm, Anytown NC\", 12345)\n   joe == joejr   #=> true\n   joe == jane    #=> false", "name": "to_a", "namespace": "Struct", "path": "Struct#to_a", "type": "instance_method", "visibility": "public"}, "Struct#to_h": {"description": "结构是一种使用访问器方法将多个属性捆绑在一起的方便方法，而不必编写显式类。\\n \\n struct类生成包含一组成员及其值的新子类。为每个成员创建一个读写器方法，类似于module-attr-u访问器。\\n \n   Customer = Struct.new(:name, :address) do\n     def greeting\n       \"Hello #{name}!\"\n     end\n   end\n\n   dave = Customer.new(\"Dave\", \"123 Main\")\n   dave.name     #=> \"Dave\"\n   dave.greeting #=> \"Hello Dave!\"\n \\n有关创建结构子类和实例的更多示例，请参阅struct:：new。\\n \\n在后面的方法描述中，“member”参数指的是引用字符串（<code>\"name\"</code>）或符号（<code>:name</code>）的结构成员。", "name": "to_h", "namespace": "Struct", "path": "Struct#to_h", "type": "instance_method", "visibility": "public"}, "Struct#values": {"description": "equality-如果+other+具有相同的结构子类并且具有相同的成员值（根据对象=），则返回+true+。n \n   Customer = Struct.new(:name, :address, :zip)\n   joe   = Customer.new(\"Joe Smith\", \"123 Maple, Anytown NC\", 12345)\n   joejr = Customer.new(\"Joe Smith\", \"123 Maple, Anytown NC\", 12345)\n   jane  = Customer.new(\"Jane Doe\", \"456 Elm, Anytown NC\", 12345)\n   joe == joejr   #=> true\n   joe == jane    #=> false", "name": "values", "namespace": "Struct", "path": "Struct#values", "type": "instance_method", "visibility": "public"}, "Struct#values_at": {"description": "属性引用-返回给定结构+member+或给定+index+处的成员的值。如果+member+不存在，则引发NameError；如果+index+超出范围，则引发IndexError。n \n   Customer = Struct.new(:name, :address, :zip)\n   joe = Customer.new(\"Joe Smith\", \"123 Maple, Anytown NC\", 12345)\n\n   joe[\"name\"]   #=> \"Joe Smith\"\n   joe[:name]    #=> \"Joe Smith\"\n   joe[0]        #=> \"Joe Smith\"", "name": "values_at", "namespace": "Struct", "path": "Struct#values_at", "type": "instance_method", "visibility": "public"}, "Struct.new": {"description": "属性分配-设置给定结构+member+或给定+index+处的成员的值。如果+member+不存在，则提升NameError；如果+index+超出范围，则提升IndexError。n \n   Customer = Struct.new(:name, :address, :zip)\n   joe = Customer.new(\"Joe Smith\", \"123 Maple, Anytown NC\", 12345)\n\n   joe[\"name\"] = \"Luke\"\n   joe[:zip]   = \"90210\"\n\n   joe.name   #=> \"Luke\"\n   joe.zip    #=> \"90210\"", "name": "new", "namespace": "Struct", "path": "Struct.new", "type": "class_method", "visibility": "public"}, "Struct::Tms": {"description": "通过在每个步骤调用+dig+提取由+key+对象序列指定的嵌套值，如果中间步骤为+nil+，则返回+nil+。\\n \n  Foo = Struct.new(:a)\n  f = Foo.new(Foo.new({b: [1, 2, 3]}))\n\n  f.dig(:a, :a, :b, 0)    # => 1\n  f.dig(:b, 0)            # => nil\n f.dig（：a，：a，：b，：c）TypeError：无符号到整数的隐式转换", "name": "Tms", "namespace": "Struct", "path": "Struct::Tms", "type": "constant", "return": ["Class", ""], "visibility": "public"}, "ThreadGroup": {"description": "按顺序生成每个结构成员的值。如果没有给定块，则返回\\n枚举器。\\n \n   Customer = Struct.new(:name, :address, :zip)\n   joe = Customer.new(\"Joe Smith\", \"123 Maple, Anytown NC\", 12345)\n   joe.each {|x| puts(x) }\n \\n生成：\\n \n   Joe Smith\n   123 Maple, Anytown NC\n 12345", "name": "ThreadGroup", "namespace": "", "path": "ThreadGroup", "type": "class", "visibility": "public"}, "ThreadGroup#add": {"description": "按顺序生成每个结构成员的名称和值。如果没有给定块，则返回枚举器。\\n \n   Customer = Struct.new(:name, :address, :zip)\n   joe = Customer.new(\"Joe Smith\", \"123 Maple, Anytown NC\", 12345)\n   joe.each_pair {|name, value| puts(\"#{name} => #{value}\") }\n \\n生成：\\n \n   name => Joe Smith\n   address => 123 Maple, Anytown NC\n zip=>12345", "name": "add", "namespace": "ThreadGroup", "path": "ThreadGroup#add", "type": "instance_method", "visibility": "public"}, "ThreadGroup#enclose": {"description": "如果哈希相等---+其他+和+struct+具有相同的结构子类，并且具有相同的成员值（根据对象eql？），则它们引用相同的哈希键。.", "name": "enclose", "namespace": "ThreadGroup", "path": "ThreadGroup#enclose", "type": "instance_method", "visibility": "public"}, "ThreadGroup#enclosed?": {"description": "基于此结构的内容返回哈希值。\\n \\n另请参阅对象哈希。", "name": "enclosed?", "namespace": "ThreadGroup", "path": "ThreadGroup#enclosed?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "ThreadGroup#list": {"description": "以字符串形式返回此结构的说明。", "name": "list", "namespace": "ThreadGroup", "path": "ThreadGroup#list", "type": "instance_method", "visibility": "public"}, "ThreadGroup::Default": {"description": "以字符串形式返回此结构的说明。", "name": "Default", "namespace": "ThreadGroup", "path": "ThreadGroup::Default", "type": "constant", "return": ["ThreadGroup", ""], "visibility": "public"}, "ThreadError": {"description": "返回结构成员的数目。n \n   Customer = Struct.new(:name, :address, :zip)\n   joe = Customer.new(\"Joe Smith\", \"123 Maple, Anytown NC\", 12345)\n   joe.length   #=> 3", "name": "ThreadError", "namespace": "", "path": "ThreadError", "type": "class", "visibility": "public"}, "Thread": {"description": "以符号数组形式返回结构成员：\\n \n   Customer = Struct.new(:name, :address, :zip)\n   joe = Customer.new(\"Joe Smith\", \"123 Maple, Anytown NC\", 12345)\n   joe.members   #=> [:name, :address, :zip]", "name": "Thread", "namespace": "", "path": "Thread", "type": "class", "visibility": "public"}, "Thread#[]": {"description": "从结构到块生成每个成员值，并返回一个数组，该数组包含+struct+中的成员值，对于该数组，给定的块返回一个真值（相当于Enumerable Select）。n \n   Lots = Struct.new(:a, :b, :c, :d, :e, :f)\n   l = Lots.new(11, 22, 33, 44, 55, 66)\n   l.select {|v| v.even? }   #=> [22, 44, 66]", "name": "[]", "namespace": "Thread", "path": "Thread#[]", "type": "instance_method", "visibility": "public"}, "Thread#[]=": {"description": "返回结构成员的数目。n \n   Customer = Struct.new(:name, :address, :zip)\n   joe = Customer.new(\"Joe Smith\", \"123 Maple, Anytown NC\", 12345)\n   joe.length   #=> 3", "name": "[]=", "namespace": "Thread", "path": "Thread#[]=", "type": "instance_method", "visibility": "public"}, "Thread#abort_on_exception": {"description": "以数组形式返回此结构的值。n \n   Customer = Struct.new(:name, :address, :zip)\n   joe = Customer.new(\"Joe Smith\", \"123 Maple, Anytown NC\", 12345)\n   joe.to_a[1]   #=> \"123 Maple, Anytown NC\"", "name": "abort_on_exception", "namespace": "Thread", "path": "Thread#abort_on_exception", "type": "instance_method", "visibility": "public"}, "Thread#abort_on_exception=": {"description": "返回包含结构成员的名称和值的哈希。n \n   Customer = Struct.new(:name, :address, :zip)\n   joe = Customer.new(\"Joe Smith\", \"123 Maple, Anytown NC\", 12345)\n   joe.to_h[:address]   #=> \"123 Maple, Anytown NC\"", "name": "abort_on_exception=", "namespace": "Thread", "path": "Thread#abort_on_exception=", "type": "instance_method", "visibility": "public"}, "Thread#add_trace_func": {"description": "以数组形式返回此结构的值。n \n   Customer = Struct.new(:name, :address, :zip)\n   joe = Customer.new(\"Joe Smith\", \"123 Maple, Anytown NC\", 12345)\n   joe.to_a[1]   #=> \"123 Maple, Anytown NC\"", "name": "add_trace_func", "namespace": "Thread", "path": "Thread#add_trace_func", "type": "instance_method", "visibility": "public"}, "Thread#alive?": {"description": "以数组形式返回每个+selector+的结构成员值。+selector+可以是整数偏移量，也可以是偏移量的范围（如数组中的值）。n \n   Customer = Struct.new(:name, :address, :zip)\n   joe = Customer.new(\"Joe Smith\", \"123 Maple, Anytown NC\", 12345)\n   joe.values_at(0, 2)   #=> [\"Joe Smith\", 12345]", "name": "alive?", "namespace": "Thread", "path": "Thread#alive?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Thread#backtrace": {"description": "前两个表单用于创建新的结构子类+class_name+，该子类可以包含每个+member_name+的值。这个子类可以像其他类一样用来创建结构的实例。\\n \\n如果省略+class_name+，将创建匿名结构类。否则，此结构的名称将在类结构中显示为常量，因此它对于系统中的所有结构都必须是唯一的，并且必须以大写字母开头。将一个结构类赋给常量也会给类一个常量的名称。\\n \n   # Create a structure with a name under Struct\n   Struct.new(\"Customer\", :name, :address)\n   #=> Struct::Customer\n   Struct::Customer.new(\"Dave\", \"123 Main\")\n   #=> #<struct Struct::Customer name=\"Dave\", address=\"123 Main\">\n\n   # Create a structure named by its constant\n   Customer = Struct.new(:name, :address)\n   #=> Customer\n   Customer.new(\"Dave\", \"123 Main\")\n   #=> #<struct Customer name=\"Dave\", address=\"123 Main\">\n \\n如果可选的+keyword_init+关键字参数设置为+true+，则为\\n。new采用关键字参数而不是普通参数。\\n \n   Customer = Struct.new(:name, :address, keyword_init: true)\n   Customer.new(name: \"Dave\", address: \"123 Main\")\n   #=> #<struct Customer name=\"Dave\", address=\"123 Main\">\n \\n如果给定了块，则将在+StructClass+上下文中对其进行计算，并将创建的类作为参数传递：\\n \n   Customer = Struct.new(:name, :address) do\n     def greeting\n       \"Hello #{name}!\"\n     end\n   end\n   Customer.new(\"Dave\", \"123 Main\").greeting  #=> \"Hello Dave!\"\n \\n这是自定义结构的建议方法。对匿名结构进行子类化将创建一个永远不会使用的额外匿名类。\\n \\n最后两个窗体创建结构子类的新实例。+value+参数的数目必须小于或等于为结构定义的属性数目。取消设置参数默认为+nil+。\\n传递的参数多于属性数目将引发ArgumentError。n \n   Customer = Struct.new(:name, :address)\n   Customer.new(\"Dave\", \"123 Main\")\n   #=> #<struct Customer name=\"Dave\", address=\"123 Main\">\n   Customer[\"Dave\"]\n   #=> #<struct Customer name=\"Dave\", address=nil>", "name": "backtrace", "namespace": "Thread", "path": "Thread#backtrace", "type": "instance_method", "visibility": "public"}, "Thread#backtrace_locations": {"description": "为了向后兼容", "name": "backtrace_locations", "namespace": "Thread", "path": "Thread#backtrace_locations", "type": "instance_method", "visibility": "public"}, "Thread#exit": {"description": "如果给定字符串（或符号）作为光纤局部变量存在，则返回+true+。n \n   me = Thread.current\n   me[:oliver] = \"a\"\n   me.key?(:oliver)    #=> true\n   me.key?(:stanley)   #=> false", "name": "exit", "namespace": "Thread", "path": "Thread#exit", "type": "instance_method", "visibility": "public"}, "Thread#fetch": {"description": "", "name": "fetch", "namespace": "Thread", "path": "Thread#fetch", "type": "instance_method", "visibility": "public"}, "Thread#group": {"description": "将给定的+thread+添加到此组，并将其从以前可能是其成员的任何其他组中删除。\\n \n   puts \"Initial group is #{ThreadGroup::Default.list}\"\n   tg = ThreadGroup.new\n   t1 = Thread.new { sleep }\n   t2 = Thread.new { sleep }\n   puts \"t1 is #{t1}\"\n   puts \"t2 is #{t2}\"\n   tg.add(t1)\n   puts \"Initial group now #{ThreadGroup::Default.list}\"\n   puts \"tg group now #{tg.list}\"\n \\n这将产生：\\n \n   Initial group is #<Thread:0x401bdf4c>\n   t1 is #<Thread:0x401b3c90>\n   t2 is #<Thread:0x401b3c18>\n   Initial group now #<Thread:0x401b3c18>#<Thread:0x401bdf4c>\n tg group now<thread:0x401b3c90>", "name": "group", "namespace": "Thread", "path": "Thread#group", "type": "instance_method", "visibility": "public"}, "Thread#initialize": {"description": ":nodoc:", "name": "initialize", "namespace": "Thread", "path": "Thread#initialize", "type": "instance_method", "visibility": "public"}, "Thread#inspect": {"description": "返回目标线程的异步队列是否为空。\\n \\n如果给定+error+，则仅检查+error+类型的延迟事件。\\n \\n请参阅：：挂起中断？更多信息。", "name": "inspect", "namespace": "Thread", "path": "Thread#inspect", "type": "instance_method", "visibility": "public"}, "Thread#join": {"description": "如果包含+thgrp+，则返回+true+。另见ThreadGroup附页。", "name": "join", "namespace": "Thread", "path": "Thread#join", "type": "instance_method", "visibility": "public"}, "Thread#key?": {"description": "返回属于此组的所有现有线程对象的数组。\\n n    ThreadGroup::Default.list   #=> [#<Thread:0x401bdf4c run>]", "name": "key?", "namespace": "Thread", "path": "Thread#key?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Thread#keys": {"description": "默认情况下，当ruby starts;所有线程都属于它时创建的默认ThreadGroup。", "name": "keys", "namespace": "Thread", "path": "Thread#keys", "type": "instance_method", "visibility": "public"}, "Thread#kill": {"description": "如果给定字符串（或符号）作为光纤局部变量存在，则返回+true+。n \n   me = Thread.current\n   me[:oliver] = \"a\"\n   me.key?(:oliver)    #=> true\n   me.key?(:stanley)   #=> false", "name": "kill", "namespace": "Thread", "path": "Thread#kill", "type": "instance_method", "visibility": "public"}, "Thread#name": {"description": "线程是并发编程模型的Ruby实现。\\n \\n需要多个执行线程的程序是Ruby线程类的完美候选。\\n \\n例如，我们可以使用：：new创建一个独立于主线程执行的新线程。\\n \n    thr = Thread.new { puts \"Whats the big deal\" }\n \\n然后，我们可以暂停主线程的执行，并允许新线程完成，使用join:\\n \n    thr.join #=> \"Whats the big deal\"\n \\n如果在主线程终止之前不调用+thr.join+，则包括+thr+在内的所有其他线程都将被终止。\\n \\n或者，您也可以使用数组一次处理多个线程，如下例所示：\\n \n    threads = []\n    threads << Thread.new { puts \"Whats the big deal\" }\n    threads << Thread.new { 3.times { puts \"Threads are fun!\" } }\n \\n创建几个线程后，我们会等待所有线程连续完成。\\n \n    threads.each { |thr| thr.join }\n \\n==线程初始化\\n \\n为了创建新线程，Ruby提供了：：new、：：start和\\n：：fork。每个方法都必须提供一个块，否则将引发ThreadError。\\n \\n在对线程类进行子类化时，子类的+initialize+方法将被：：start和：：fork忽略。否则，请确保在+initialize+方法中调用super。\\n \\n==thread termination \\n \\n对于终止线程，Ruby提供了多种方法来完成此操作。\\n \\n class方法：：kill用于退出给定线程：\\n \n    thr = Thread.new { ... }\n    Thread.kill(thr) # sends exit() to thr\n \\n或者，您可以使用实例方法exit或其别名kill或terminate。\\n \n    thr.exit\n \\n==thread status \\n \\n ruby提供了一些查询给定线程状态的实例方法。要获取具有当前线程状态的字符串，请使用状态\n    thr = Thread.new { sleep }\n    thr.status # => \"sleep\"\n    thr.exit\n    thr.status # => false\n，您还可以使用活动？要判断线程是在运行还是在休眠，是否停止？如果线程已断开或正在休眠。\\n \\n==thread variables and scope \\n \\n因为线程是用块创建的，所以相同的规则适用于变量作用域的其他\\n ruby块。在此块中创建的任何本地变量都只能被此线程访问。\\n \\n===fiber-local与thread-local \\n \\n每个光纤都有自己的bucket用于线程[]存储。在本地设置新光纤时，只能在此光纤中访问。举例说明：\n    Thread.new {\n      Thread.current[:foo] = \"bar\"\n      Fiber.new {\n        p Thread.current[:foo] # => nil\n      }.resume\n    }.join\n \\n此示例使用[]获取和[]=设置光纤局部变量，您还可以使用键列出给定线程和键的光纤局部变量。检查光纤是否存在本地。\\n \\n当涉及线程局部变量时，可以在线程的整个范围内访问它们。给出以下示例：\\n \n    Thread.new{\n      Thread.current.thread_variable_set(:foo, 1)\n      p Thread.current.thread_variable_get(:foo) # => 1\n      Fiber.new{\n thread.current.thread_variable_set（：foo，2）\\n \tp Thread.current.thread_variable_get(:foo) # => 2\n      }.resume\n      p Thread.current.thread_variable_get(:foo)   # => 2\n    }.join\n\\n您可以看到线程local+：foo+被带到光纤中，并在线程结束时更改为+2+。\\n \\n此示例使用thread_variable_set创建新的线程局部变量，并thread_variable_get引用它们。\\n \\n还有thread_变量来列出所有线程局部变量，以及\\n thread_变量？检查给定的线程本地是否存在。\\n \\n==异常处理\\n \\n任何线程都可以使用raise实例方法引发异常，该方法的操作与内核raise类似。\\n \\n但是，重要的是要注意，在主线程以外的任何线程中发生的异常都取决于\\在\\异常上中止。默认情况下，此选项为+false+，这意味着任何未处理的异常都将导致线程在等待join \\n或值时自动终止。您可以通过abort_on_exception=\\n +true+或将$DEBUG设置为+true+来更改此默认值。\\n \\n通过添加class方法：：handle_interrupt，现在可以用线程异步处理异常。\\n \\n==scheduling \\n \\n ruby提供了一些方法来支持在程序中调度线程。\\n \\n第一种方法是使用class方法：：stop，使当前运行的线程进入睡眠状态，并计划另一个线程的执行。\\n \\n线程休眠后，可以使用实例方法唤醒\\n将线程标记为符合调度要求。\\n \\n您也可以尝试：：pass，它尝试将执行传递给另一个线程，但取决于操作系统正在运行的线程是否会切换。优先级也一样，它允许您向线程调度程序提示在传递执行时要优先哪个线程。此方法也依赖于操作系统，在某些平台上可能被忽略。", "name": "name", "namespace": "Thread", "path": "Thread#name", "type": "instance_method", "visibility": "public"}, "Thread#name=": {"description": "属性引用-使用符号或字符串名称返回光纤局部变量的值（如果光纤中没有显式定义，则返回当前线程的根光纤）。\\n如果指定的变量不存在，则返回+nil+。\\n \n   [\n     Thread.new { Thread.current[\"name\"] = \"A\" },\n     Thread.new { Thread.current[:name]  = \"B\" },\n     Thread.new { Thread.current[\"name\"] = \"C\" }\n   ].each do |th|\n     th.join\n     puts \"#{th.inspect}: #{th[:name]}\"\n   end\n \\n这将产生：\\n \n   #<Thread:0x00000002a54220 dead>: A\n   #<Thread:0x00000002a541a8 dead>: B\n   #<Thread:0x00000002a54130 dead>: C\n \\n thread[]和thread[]=不是本地线程，而是本地光纤。\\n Ruby1.8中不存在这种混淆，因为只有Ruby1.9之后才能使用光纤。\\n ruby 1.9选择这些方法在本地执行fiber操作，以便为动态范围保存以下习惯用法。\\n \n  def meth(newvalue)\n    begin\n      oldvalue = Thread.current[:name]\n      Thread.current[:name] = newvalue\n      yield\n    ensure\n      Thread.current[:name] = oldvalue\n    end\n  end\n \\n如果方法是线程本地的，并且给定的块切换为光纤，则习语可能无法用作动态范围。\\n \n  f = Fiber.new {\n    meth(1) {\n      Fiber.yield\n    }\n  }\n  meth(2) {\n    f.resume\n  }\n  f.resume\n  p Thread.current[:name]\n  #=> nil if fiber-local\n  #=> 2 if thread-local (The value 2 is leaked to outside of meth method.)\n \\n有关线程局部变量，请参阅线程变量get和线程变量set。", "name": "name=", "namespace": "Thread", "path": "Thread#name=", "type": "instance_method", "visibility": "public"}, "Thread#pending_interrupt?": {"description": "属性分配-使用符号或字符串设置或创建光纤局部变量的值。\\n \\n另请参阅线程[]。\\n \\n有关线程局部变量，请参阅线程变量设置和线程变量获取。", "name": "pending_interrupt?", "namespace": "Thread", "path": "Thread#pending_interrupt?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Thread#priority": {"description": "返回此+thr+的线程本地“异常时中止”条件的状态。\\n \\n预设为+false+。\\n \\n另请参见在_exception=上中止_。\\n \\n还有一个类级方法可以为所有线程设置此方法，请参阅\\n：：abort_on_exception。", "name": "priority", "namespace": "Thread", "path": "Thread#priority", "type": "instance_method", "visibility": "public"}, "Thread#priority=": {"description": "当设置为+true+时，如果此+thr+被异常中止，则引发的异常将在主线程中重新引发。\\n \\n另请参阅异常时中止操作。\\n \\n还有一个类级方法可以为所有线程设置此方法，请参阅\\n：：abort_on_exception=。", "name": "priority=", "namespace": "Thread", "path": "Thread#priority=", "type": "instance_method", "visibility": "public"}, "Thread#raise": {"description": "添加proc作为跟踪处理程序。\\n \\n请参阅thread set_trace_func和kernel set_trace_func。", "name": "raise", "namespace": "Thread", "path": "Thread#raise", "type": "instance_method", "visibility": "public"}, "Thread#report_on_exception": {"description": "如果+thr+正在运行或正在休眠，则返回+true+。\\n \n   thr = Thread.new { }\n   thr.join                #=> #<Thread:0x401b3fb0 dead>\n   Thread.current.alive?   #=> true\n   thr.alive?              #=> false\n \\n另见停止？和地位。", "name": "report_on_exception", "namespace": "Thread", "path": "Thread#report_on_exception", "type": "instance_method", "visibility": "public"}, "Thread#report_on_exception=": {"description": "返回目标线程的当前回溯。", "name": "report_on_exception=", "namespace": "Thread", "path": "Thread#report_on_exception=", "type": "instance_method", "visibility": "public"}, "Thread#run": {"description": "返回目标线程的执行堆栈-包含回溯位置对象的数组。\\n \\n有关详细信息，请参阅thread:：backtrace:：location。\\n \\n此方法的行为类似于内核调用者位置，但它适用于特定线程。", "name": "run", "namespace": "Thread", "path": "Thread#run", "type": "instance_method", "visibility": "public"}, "Thread#safe_level": {"description": "终止+thr+并计划运行另一个线程。\\n \\n如果此线程已标记为被终止，exit将返回该线程。\\n \\n如果这是主线程或最后一个线程，则退出进程。", "name": "safe_level", "namespace": "Thread", "path": "Thread#safe_level", "type": "instance_method", "visibility": "public"}, "Thread#set_trace_func": {"description": "返回包含给定线程的ThreadGroup，如果+thr+不是任何组的成员，则返回+nil+。\\n n    Thread.main.group   #=> #<ThreadGroup:0x4029d914>", "name": "set_trace_func", "namespace": "Thread", "path": "Thread#set_trace_func", "type": "instance_method", "visibility": "public"}, "Thread#status": {"description": "将THR的名称、ID和状态转储到字符串。", "name": "status", "namespace": "Thread", "path": "Thread#status", "type": "instance_method", "visibility": "public"}, "Thread#stop?": {"description": "调用线程将暂停执行并运行+thr+。\\n \\n在+thr+退出或给定的+limit+秒过去之前不会返回。\\n \\n如果时间限制过期，将返回+nil+，否则返回+thr+。\\n \\n当主程序退出时，任何未加入的线程都将被终止。\\n \\n如果+thr+以前引发了异常，并且未设置：：abort_on_exception或\\n$DEBUG标志（因此该异常尚未处理），则此时将处理该异常。\\n \n   a = Thread.new { print \"a\"; sleep(10); print \"b\"; print \"c\" }\n   x = Thread.new { print \"x\"; Thread.pass; print \"y\"; print \"z\" }\n   x.join # Let thread x finish, thread a will be killed on exit.\n   #=> \"axyz\"\n \\n下面的示例说明+limit+参数。\\n \n   y = Thread.new { 4.times { sleep 0.1; puts 'tick... ' }}\n   puts \"Waiting\" until y.join(0.15)\n \\n这将产生：\\n \n   tick...\n   Waiting\n   tick...\n   Waiting\n   tick...\n勾号…", "name": "stop?", "namespace": "Thread", "path": "Thread#stop?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Thread#terminate": {"description": "如果给定字符串（或符号）作为光纤局部变量存在，则返回+true+。n \n   me = Thread.current\n   me[:oliver] = \"a\"\n   me.key?(:oliver)    #=> true\n   me.key?(:stanley)   #=> false", "name": "terminate", "namespace": "Thread", "path": "Thread#terminate", "type": "instance_method", "visibility": "public"}, "Thread#thread_variable?": {"description": "返回光纤局部变量的名称数组（作为符号）。n \n   thr = Thread.new do\n     Thread.current[:cat] = 'meow'\n     Thread.current[\"dog\"] = 'woof'\n   end\n   thr.join   #=> #<Thread:0x401b3f10 dead>\n   thr.keys   #=> [:dog, :cat]", "name": "thread_variable?", "namespace": "Thread", "path": "Thread#thread_variable?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Thread#thread_variable_get": {"description": "终止+thr+并计划运行另一个线程。\\n \\n如果此线程已标记为被终止，exit将返回该线程。\\n \\n如果这是主线程或最后一个线程，则退出进程。", "name": "thread_variable_get", "namespace": "Thread", "path": "Thread#thread_variable_get", "type": "instance_method", "visibility": "public"}, "Thread#thread_variable_set": {"description": "显示线程的名称。", "name": "thread_variable_set", "namespace": "Thread", "path": "Thread#thread_variable_set", "type": "instance_method", "visibility": "public"}, "Thread#thread_variables": {"description": "将给定名称设置为Ruby线程。\\n在某些平台上，它可以将名称设置为pthread和/或kernel。", "name": "thread_variables", "namespace": "Thread", "path": "Thread#thread_variables", "type": "instance_method", "visibility": "public"}, "Thread#to_s": {"description": "返回目标线程的异步队列是否为空。\\n \\n如果给定+error+，则仅检查+error+类型的延迟事件。\\n \\n请参阅：：挂起中断？更多信息。", "name": "inspect", "namespace": "Thread", "path": "Thread#inspect", "type": "instance_method", "visibility": "public"}, "Thread#value": {"description": "返回<i>thr<i>的优先级。默认值是从创建新线程的当前线程继承的，或者对于初始主线程thread;，零优先级高的线程将比低优先级线程运行得更频繁（但低优先级线程也可以运行）。\\n \\n这只是Ruby线程计划程序的提示。在某些平台上可以忽略它。\\n n    Thread.current.priority   #=> 0", "name": "value", "namespace": "Thread", "path": "Thread#value", "type": "instance_method", "visibility": "public"}, "Thread#wakeup": {"description": "将优先级设置为<i>thr<i>to<i>integer<i>。优先级较高的线程比优先级较低的线程运行得更频繁（但优先级较低的线程也可以运行）。\\n \\n这只是Ruby线程计划程序的提示。在某些平台上可以忽略它。n \n   count1 = count2 = 0\n   a = Thread.new do\n         loop { count1 += 1 }\n       end\n   a.priority = -1\n\n   b = Thread.new do\n         loop { count2 += 1 }\n       end\n   b.priority = -2\n   sleep 1   #=> 1\n   count1    #=> 622504\n   count2    #=> 5832", "name": "wakeup", "namespace": "Thread", "path": "Thread#wakeup", "type": "instance_method", "visibility": "public"}, "Thread.DEBUG": {"description": "从给定线程引发异常。呼叫方不必是+thr+。有关更多信息，请参阅内核提升。\\n \n   Thread.abort_on_exception = true\n   a = Thread.new { sleep(200) }\n   a.raise(\"Gotcha\")\n \\n这将从prog.rb:2生成\\n \n   prog.rb:3: Gotcha (RuntimeError)\n   \tfrom prog.rb:2:in `initialize'\n   \tfrom prog.rb:2:in `new'\n", "name": "DEBUG", "namespace": "Thread", "path": "Thread.DEBUG", "type": "class_method", "visibility": "public"}, "Thread.DEBUG=": {"description": "返回此+thr+的线程本地“异常报告”条件的状态。\\n \\n创建线程时的默认值是全局标志thread.report_on_exception的值。\\n \\n另请参阅报告关于异常=。\\n \\n还有一个类级方法可以为所有新线程设置此方法，请参阅\\n：：report_on_exception=。", "name": "DEBUG=", "namespace": "Thread", "path": "Thread.DEBUG=", "type": "class_method", "visibility": "public"}, "Thread.abort_on_exception": {"description": "当设置为+true+时，如果有异常终止此+thr+，则会在$stderr上打印消息。有关详细信息，请参阅：：报告\\u异常。\\n \\n另请参阅报告异常。\\n \\n还有一个类级方法可以为所有新线程设置此方法，请参阅\\n：：report_on_exception=。", "name": "abort_on_exception", "namespace": "Thread", "path": "Thread.abort_on_exception", "type": "class_method", "visibility": "public"}, "Thread.abort_on_exception=": {"description": "唤醒+thr+，使其符合调度条件。\\n \n   a = Thread.new { puts \"a\"; Thread.stop; puts \"c\" }\n   sleep 0.1 while a.status!='sleep'\n   puts \"Got here\"\n   a.run\n   a.join\n \\n这将产生：\\n \n   a\n   Got here\n   c\n \\n另请参见实例方法唤醒。", "name": "abort_on_exception=", "namespace": "Thread", "path": "Thread.abort_on_exception=", "type": "class_method", "visibility": "public"}, "Thread.current": {"description": "返回有效的安全级别。设置线程本地安全级别有助于实现运行不安全代码的沙盒。n \n   thr = Thread.new { $SAFE = 1; sleep }\n   Thread.current.safe_level   #=> 0\n   thr.safe_level              #=> 1", "name": "current", "namespace": "Thread", "path": "Thread.current", "type": "class_method", "visibility": "public"}, "Thread.exit": {"description": "将proc_uuon_thr建立为跟踪处理程序，或者如果参数为+nil+，则禁用跟踪。\\n \\n请参阅内核设置跟踪函数。", "name": "exit", "namespace": "Thread", "path": "Thread.exit", "type": "class_method", "visibility": "public"}, "Thread.fork": {"description": "返回线程调试级别。仅当使用THREAD_DEBUG=-1编译时可用。", "name": "fork", "namespace": "Thread", "path": "Thread.fork", "type": "class_method", "visibility": "public"}, "Thread.handle_interrupt": {"description": "如果+thr+已死亡或正在睡觉，则返回+true+。\\n \n   a = Thread.new { Thread.stop }\n   b = Thread.current\n   a.stop?   #=> true\n   b.stop?   #=> false\n \\n另见“活着”？和地位。", "name": "handle_interrupt", "namespace": "Thread", "path": "Thread.handle_interrupt", "type": "class_method", "visibility": "public"}, "Thread.kill": {"description": "终止+thr+并计划运行另一个线程。\\n \\n如果此线程已标记为被终止，exit将返回该线程。\\n \\n如果这是主线程或最后一个线程，则退出进程。", "name": "kill", "namespace": "Thread", "path": "Thread.kill", "type": "class_method", "visibility": "public"}, "Thread.list": {"description": "如果给定的字符串（或符号）作为线程局部变量存在，则返回+true+。\\n \n   me = Thread.current\n   me.thread_variable_set(:oliver, \"a\")\n   me.thread_variable?(:oliver)    #=> true\n   me.thread_variable?(:stanley)   #=> false\n \\n请注意，这些不是光纤局部变量。有关更多详细信息，请参阅线程[]和线程线程变量GET。", "name": "list", "namespace": "Thread", "path": "Thread.list", "type": "class_method", "visibility": "public"}, "Thread.main": {"description": "返回已设置的线程局部变量的值。请注意，这些值与光纤局部值不同。有关光纤本地值，请参阅thread[]和thread[]。\\n \\n线程局部值随线程一起携带，不考虑光纤。例如：\\n \n  Thread.new {\n    Thread.current.thread_variable_set(\"foo\", \"bar\") # set a thread local\n    Thread.current[\"foo\"] = \"bar\"                    # set a fiber local\n\n    Fiber.new {\n      Fiber.yield [\n        Thread.current.thread_variable_get(\"foo\"), # get the thread local\n        Thread.current[\"foo\"],                     # get the fiber local\n      ]\n    }.resume\n  }.join.value # => ['bar', nil]\n \\n返回值“bar”表示线程本地，其中nil表示光纤本地。光纤在同一个线程中执行，因此线程本地值可用。", "name": "main", "namespace": "Thread", "path": "Thread.main", "type": "class_method", "visibility": "public"}, "Thread.new": {"description": "将+key+设置为+value+。请注意，这些是线程的局部，而不是光纤的局部。有关详细信息，请参阅线程线程_变量_get和线程[]。", "name": "new", "namespace": "Thread", "path": "Thread.new", "type": "class_method", "visibility": "public"}, "Thread.pass": {"description": "返回线程局部变量的名称数组（作为符号）。\\n \n   thr = Thread.new do\n     Thread.current.thread_variable_set(:cat, 'meow')\n     Thread.current.thread_variable_set(\"dog\", 'woof')\n   end\n   thr.join               #=> #<Thread:0x401b3f10 dead>\n   thr.thread_variables   #=> [:dog, :cat]\n \\n请注意，这些不是光纤局部变量。有关更多详细信息，请参阅线程[]和线程线程变量GET。", "name": "pass", "namespace": "Thread", "path": "Thread.pass", "type": "class_method", "visibility": "public"}, "Thread.pending_interrupt?": {"description": "将THR的名称、ID和状态转储到字符串。", "name": "pending_interrupt?", "namespace": "Thread", "path": "Thread.pending_interrupt?", "type": "class_method", "visibility": "public", "return": [["Boolean"], ""]}, "Thread.report_on_exception": {"description": "使用join等待+thr+完成，并返回其值或引发终止线程的异常。n \n   a = Thread.new { 2 + 2 }\n   a.value   #=> 4\n\n   b = Thread.new { raise 'something went wrong' }\n   b.value   #=> RuntimeError: something went wrong", "name": "report_on_exception", "namespace": "Thread", "path": "Thread.report_on_exception", "type": "class_method", "visibility": "public"}, "Thread.report_on_exception=": {"description": "将给定线程标记为符合调度条件，但它在I/O上仍可能被阻止。\\n\\n*注意：*这不会调用调度程序，有关详细信息，请参阅运行。n \n   c = Thread.new { Thread.stop; puts \"hey!\" }\n   sleep 0.1 while c.status!='sleep'\n   c.wakeup\n   c.join\n   #=> \"hey!\"", "name": "report_on_exception=", "namespace": "Thread", "path": "Thread.report_on_exception=", "type": "class_method", "visibility": "public"}, "Thread.start": {"description": "返回线程调试级别。仅当使用THREAD_DEBUG=-1编译时可用。", "name": "start", "namespace": "Thread", "path": "Thread.start", "type": "class_method", "visibility": "public"}, "Thread.stop": {"description": "设置线程调试级别。仅当使用THREAD_DEBUG=-1编译时可用。", "name": "stop", "namespace": "Thread", "path": "Thread.stop", "type": "class_method", "visibility": "public"}, "Thread::Backtrace": {"description": "", "name": "Backtrace", "namespace": "Thread", "path": "Thread::Backtrace", "type": "class", "visibility": "public"}, "Thread::Backtrace::Location": {"description": "", "name": "Location", "namespace": "Thread::Backtrace", "path": "Thread::Backtrace::Location", "type": "class", "visibility": "public"}, "Thread::Backtrace::Location#absolute_path": {"description": "返回全局“异常时中止”条件的状态。\\n \\n预设为+false+。\\n \\n当设为+true+时，如果任何线程因异常而中止，则引发的异常将在主线程中重新引发。\\n \\n也可以由全局$DEBUG标志或命令行选项\\n+-d+指定。\\n \\n另请参阅：：abort_on_exception=。\\n \\n还有一个实例级方法可以为特定线程设置此方法，请参见\\n在\\u异常时中止。", "name": "absolute_path", "namespace": "Thread::Backtrace::Location", "path": "Thread::Backtrace::Location#absolute_path", "type": "instance_method", "visibility": "public"}, "Thread::Backtrace::Location#base_label": {"description": "当设置为+true+时，如果任何线程被异常中止，则引发的异常将在主线程中重新引发。\\n返回新状态。\\n \n   Thread.abort_on_exception = true\n   t1 = Thread.new do\n     puts  \"In new thread\"\n     raise \"Exception from thread\"\n   end\n   sleep(1)\n   puts \"not reached\"\n \\n这将产生：\\n \n   In new thread\n   prog.rb:4: Exception from thread (RuntimeError)\n   \tfrom prog.rb:2:in `initialize'\n   \tfrom prog.rb:2:in `new'\n   \tfrom prog.rb:2\n \\n另请参阅：：abort_on_exception。\\n \\n还有一个实例级别的方法可以为特定线程设置此方法，请参见Abort_on_exception=。", "name": "base_label", "namespace": "Thread::Backtrace::Location", "path": "Thread::Backtrace::Location#base_label", "type": "instance_method", "visibility": "public"}, "Thread::Backtrace::Location#inspect": {"description": "返回当前正在执行的线程。\\n n    Thread.current   #=> #<Thread:0x401bdf4c run>", "name": "inspect", "namespace": "Thread::Backtrace::Location", "path": "Thread::Backtrace::Location#inspect", "type": "instance_method", "visibility": "public"}, "Thread::Backtrace::Location#label": {"description": "终止当前正在运行的线程并计划运行另一个线程。\\n \\n如果此线程已标记为要终止，则：：exit返回该线程。\\n \\n如果这是主线程或最后一个线程，请退出进程。", "name": "label", "namespace": "Thread::Backtrace::Location", "path": "Thread::Backtrace::Location#label", "type": "instance_method", "visibility": "public"}, "Thread::Backtrace::Location#lineno": {"description": "基本上与：：new相同。但是，如果类线程是子类的，那么在该子类中调用+start+将不会调用子类的+initialize+方法。", "name": "lineno", "namespace": "Thread::Backtrace::Location", "path": "Thread::Backtrace::Location#lineno", "type": "instance_method", "visibility": "public"}, "Thread::Backtrace::Location#path": {"description": "更改异步中断时间。\\n \\n interrupt是指异步事件和相应的过程，由线程引发、线程终止、信号陷阱（尚不支持）和主线程终止（如果主线程终止，则所有其他线程都将被终止）。\\n \\n给定的+hash+具有类似<code>ExceptionClass =>\n:TimingSymbol</code>的对。其中ExceptionClass是由给定块处理的中断。TimingSymbol可以是以下符号之一：\\n\\n[+：immediate+]立即调用中断。\\n[+：on_blocking+]在blockingoperation时调用中断。\\n[+：never+]从不调用所有中断。\\n \\n blockingoperation表示该操作将阻塞调用线程，如读和写。在cruby实现中，blockingoperation是在不使用gvl的情况下执行的任何操作。\\n \\n屏蔽的异步中断会延迟到启用为止。\\n此方法与sigprocmask（3）类似。\\n \\n==NOTE \\n \\n很难使用异步中断。\\n \\n如果需要在线程之间进行通信，请考虑使用其他方式，如队列。\\n \\n或在深入了解此方法的情况下使用它们。\\n \\n==用法\\n \\n在本例中，我们可以防止线程引发异常。\\n \\n使用+：never+TimingSymbol，RuntimeError异常将始终在主线程的第一个块中被忽略。在第二个\\n：：handle_中断块中，我们可以有目的地处理RuntimeError异常。\\n \n  th = Thread.new do\n    Thread.handle_interrupt(RuntimeError => :never) {\n      begin\n        # You can write resource allocation code safely.\n        Thread.handle_interrupt(RuntimeError => :immediate) {\n     # ...\n        }\n      ensure\n        # You can write resource deallocation code safely.\n      end\n    }\n  end\n  Thread.pass\n  # ...\n  th.raise \"stop\"\n \\n虽然我们忽略了RuntimeError异常，但编写资源分配代码是安全的。然后，确保块是我们可以安全地释放您的资源的地方。\\n \\n===防范超时：：错误\\n \\n在下一个示例中，我们将防范超时：：错误异常。这将有助于防止在正常的确保子句期间发生timeout:：error异常时泄漏资源。对于这个示例，我们使用标准库超时的帮助，从+timeout+块的第一部分lib/timeout.rb \n  require 'timeout'\n  Thread.handle_interrupt(Timeout::Error => :never) {\n    timeout(10){\n      # Timeout::Error doesn't occur here\n      Thread.handle_interrupt(Timeout::Error => :on_blocking) {\n        # possible to be killed by Timeout::Error\n        # while blocking operation\n      }\n      # Timeout::Error doesn't occur here\n    }\n  }\n\\n，我们可以依赖于超时：：错误被忽略。然后，在<code>Timeout::Error => :on_blocking</code>块中，任何将阻塞调用线程的操作都容易引发timeout:：error异常。\\n \\n===堆栈控制设置\\n \\n可以堆叠多个级别的：：handle_中断块，以便一次控制多个ExceptionClass和TimingSymbol。\\n \n  Thread.handle_interrupt(FooError => :never) {\n    Thread.handle_interrupt(BarError => :never) {\n       # FooError and BarError are prohibited.\n    }\n  }\n \\n===继承ExceptionClass \\n \\n将考虑从ExceptionClass参数继承的所有异常。\\n \n  Thread.handle_interrupt(Exception => :never) {\n    # all exceptions inherited from Exception are prohibited.\n }", "name": "path", "namespace": "Thread::Backtrace::Location", "path": "Thread::Backtrace::Location#path", "type": "instance_method", "visibility": "public"}, "Thread::Backtrace::Location#to_s": {"description": "使给定的+thread+退出，另请参见thread:：exit。n \n   count = 0\n   a = Thread.new { loop { count += 1 } }\n   sleep(0.1)       #=> 0\n   Thread.kill(a)   #=> #<Thread:0x401b3d30 dead>\n   count            #=> 93947\n   a.alive?         #=> false", "name": "to_s", "namespace": "Thread::Backtrace::Location", "path": "Thread::Backtrace::Location#to_s", "type": "instance_method", "visibility": "public"}, "Mutex": {"description": "为所有可运行或已停止的线程返回线程对象数组。\\n \n   Thread.new { sleep(200) }\n   Thread.new { \n   ary = [1, \"two\", 3.0] #=> [1, \"two\", 3.0]\n.times {|i| i*i } }\n   Thread.new { Thread.stop }\n   Thread.list.each {|t| p t}\n \\n这将产生：\\n \n   #<Thread:0x401b3e84 sleep>\n   #<Thread:0x401b3f38 run>\n   #<Thread:0x401b3fb0 sleep>\n<thread:0x401bdf4c run>", "name": "Mutex", "namespace": "", "path": "Mutex", "type": "class", "visibility": "public"}, "Mutex#initialize": {"description": "返回主线程。", "name": "initialize", "namespace": "Mutex", "path": "Mutex#initialize", "type": "instance_method", "visibility": "public"}, "Mutex#lock": {"description": "thread.new（*args，&proc）->thread\\n thread.new（*args）args…->线程\\n \\n创建执行给定块的新线程。\\n \\n任何给定给：：new的+args+都将传递给块：\\n \\n arr=[]\\n a，b，c=1，2，3 \\n thread.new（a，b，c）d，e，f arr<<d<<e<<f。join \\n arr #=> [1, 2, 3] \\n \\n如果在没有块的情况下调用：：new，则引发ThreadError异常。\\n \\n如果要子类线程，请确保在+initialize+方法中调用super，否则将引发ThreadError。", "name": "lock", "namespace": "Mutex", "path": "Mutex#lock", "type": "instance_method", "visibility": "public"}, "Mutex#locked?": {"description": "给线程调度程序一个提示，将执行传递给另一个线程。\\n正在运行的线程可能会切换，也可能不会切换，这取决于操作系统和处理器。", "name": "locked?", "namespace": "Mutex", "path": "Mutex#locked?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Mutex#owned?": {"description": "返回异步队列是否为空。\\n \\n由于thread:：handle中断可用于延迟异步事件，因此此方法可用于确定是否有任何延迟事件。\\n \\n如果发现此方法返回true，则可以完成+：Never+块。\\n \\n例如，以下方法立即处理延迟的异步事件。\\n \n  def Thread.kick_interrupt_immediately\n    Thread.handle_interrupt(Object => :immediate) {\n      Thread.pass\n    }\n  end\n \\n如果给定+error+，则仅检查+error+类型的延迟事件。\\n \\n==用法\n  th = Thread.new{\n    Thread.handle_interrupt(RuntimeError => :on_blocking){\n      while true\n        ...\n        # reach safe point to invoke interrupt\n        if Thread.pending_interrupt?\n          Thread.handle_interrupt(Object => :immediate){}\n        end\n        ...\n      end\n    }\n  }\n  ...\n  th.raise # stop thread\n \\n此示例也可以如下编写，您应该使用它来避免异步中断。\\n \n  flag = true\n  th = Thread.new{\n    Thread.handle_interrupt(RuntimeError => :on_blocking){\n      while true\n        ...\n        # reach safe point to invoke interrupt\n        break if flag == false\n        ...\n      end\n    }\n  }\n  ...\n flag=false停止线程", "name": "owned?", "namespace": "Mutex", "path": "Mutex#owned?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Mutex#sleep": {"description": "返回全局“异常报告”条件的状态。\\n \\n自Ruby 2.5以来，默认值为+true+。\\n \\n如果异常终止线程，则当此标志为true时创建的所有线程都将在$stderr上报告一条消息。\\n \n   Thread.new { 1.times { raise } }\n \\n将在$stderr上生成此输出：\\n \n   #<Thread:...> terminated with exception (report_on_exception is true):\n   Traceback (most recent call last):\n           2: from -e:1:in `block in <main>'\n           1: from -e:1:in `times'\n \\n这样做是为了尽早捕获线程中的错误。\\n在某些情况下，可能不需要此输出。\\n避免额外输出的方法有多种：\\n\\n*如果不打算使用异常，最好是修复\n  the exception so it does not happen anymore.\n*的原因。如果希望使用异常，最好将其恢复到\n  where it is raised rather then let it kill the Thread.\n*附近。如果保证线程将与线程连接join or\n  Thread#value, then it is safe to disable this report with\n  <code>Thread.current.report_on_exception = false</code>\n  when starting the Thread.\n  However, this might handle the exception much later, or not at all\n  if the Thread is never joined due to the parent thread being blocked, etc.\n\\n另请参见：：report_on_exception=。\\n \\n还有一个实例级别的方法可以为特定线程设置此方法，请参见报告关于异常=。", "name": "sleep", "namespace": "Mutex", "path": "Mutex#sleep", "type": "instance_method", "visibility": "public"}, "Mutex#synchronize": {"description": "返回新状态。\\n当设置为+true+时，如果异常终止线程，则随后创建的所有线程都将继承该条件并在$stderr上报告一条消息：\\n \n   Thread.report_on_exception = true\n   t1 = Thread.new do\n     puts  \"In new thread\"\n     raise \"Exception from thread\"\n   end\n   sleep(1)\n   puts \"In the main thread\"\n\\n这将产生：\\n \n   In new thread\n   #<Thread:...prog.rb:2> terminated with exception (report_on_exception is true):\n   Traceback (most recent call last):\n   prog.rb:4:in `block in <main>': Exception from thread (RuntimeError)\n   In the main thread\n\\n另请参阅：：report_on_exception。\\n \\n还有一个实例级别的方法可以为特定线程设置此方法，请参见报告关于异常=。", "name": "synchronize", "namespace": "Mutex", "path": "Mutex#synchronize", "type": "instance_method", "visibility": "public"}, "Mutex#try_lock": {"description": "基本上与：：new相同。但是，如果类线程是子类的，那么在该子类中调用+start+将不会调用子类的+initialize+方法。", "name": "try_lock", "namespace": "Mutex", "path": "Mutex#try_lock", "type": "instance_method", "visibility": "public"}, "Mutex#unlock": {"description": "停止当前线程的执行，将其置于“休眠”状态，并计划其他线程的执行。n \n   a = Thread.new { print \"a\"; Thread.stop; print \"c\" }\n   sleep 0.1 while a.status!='sleep'\n   print \"b\"\n   a.run\n   a.join\n   #=> \"abc\"", "name": "unlock", "namespace": "Mutex", "path": "Mutex#unlock", "type": "instance_method", "visibility": "public"}, "Queue": {"description": "返回此帧的完整文件路径。\\n \\n与path相同，但包含绝对路径。", "name": "Queue", "namespace": "", "path": "Queue", "type": "class", "visibility": "public"}, "Queue#<<": {"description": "尝试获取锁并立即返回。如果授予了锁，则返回+true+。", "name": "<<", "namespace": "Queue", "path": "Queue#<<", "type": "instance_method", "visibility": "public"}, "Queue#clear": {"description": "将给定的+object+推送到队列。", "name": "clear", "namespace": "Queue", "path": "Queue#clear", "type": "instance_method", "visibility": "public"}, "Queue#close": {"description": "返回此框架的标签。\\n \\n通常由方法、类、模块等名称组成，并带有装饰。\\n \\n请考虑以下示例：\\n \\n def foo\n  puts caller_locations(0).first.label\n\n  1.times do\n    puts caller_locations(0).first.label\n\n    1.times do\n      puts caller_locations(0).first.label\n    end\n\n  end\nend \\n \\n调用+foo+的结果如下：\\n \\n label:foo label:block in foo label:block（2级）in foo", "name": "close", "namespace": "Queue", "path": "Queue#close", "type": "instance_method", "visibility": "public"}, "Queue#closed?": {"description": "返回此帧的行号。\\n \\n例如，使用+caller_locations.rb+from thread:：backtrace:：location \\n \\n loc=c（0..1）。第一个loc.lineno #=> 2", "name": "closed?", "namespace": "Queue", "path": "Queue#closed?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Queue#deq": {"description": "返回等待队列的线程数。", "name": "shift", "namespace": "Queue", "path": "Queue#shift", "type": "instance_method", "visibility": "public"}, "Queue#empty?": {"description": "如果队列已关闭，则返回+true+。", "name": "empty?", "namespace": "Queue", "path": "Queue#empty?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Queue#enq": {"description": "尝试获取锁并立即返回。如果授予了锁，则返回+true+。", "name": "<<", "namespace": "Queue", "path": "Queue#<<", "type": "instance_method", "visibility": "public"}, "Queue#initialize": {"description": "创建新的互斥体", "name": "initialize", "namespace": "Queue", "path": "Queue#initialize", "type": "instance_method", "visibility": "public"}, "Queue#length": {"description": "如果此锁当前由某个线程持有，则返回+true+。", "name": "size", "namespace": "Queue", "path": "Queue#size", "type": "instance_method", "visibility": "public"}, "Queue#size": {"description": "如果此锁当前由某个线程持有，则返回+true+。", "name": "size", "namespace": "Queue", "path": "Queue#size", "type": "instance_method", "visibility": "public"}, "Queue#marshal_dump": {"description": ":nodoc:", "name": "marshal_dump", "namespace": "Queue", "path": "Queue#marshal_dump", "type": "instance_method", "visibility": "public"}, "Queue#num_waiting": {"description": "返回队列的长度。", "name": "num_waiting", "namespace": "Queue", "path": "Queue#num_waiting", "type": "instance_method", "visibility": "public"}, "Queue#pop": {"description": "返回等待队列的线程数。", "name": "shift", "namespace": "Queue", "path": "Queue#shift", "type": "instance_method", "visibility": "public"}, "Queue#shift": {"description": "返回等待队列的线程数。", "name": "shift", "namespace": "Queue", "path": "Queue#shift", "type": "instance_method", "visibility": "public"}, "Queue#push": {"description": "尝试获取锁并立即返回。如果授予了锁，则返回+true+。", "name": "<<", "namespace": "Queue", "path": "Queue#<<", "type": "instance_method", "visibility": "public"}, "SizedQueue": {"description": "释放锁。\\n如果+mutex+未被当前线程锁定，则引发+ThreadError+。", "name": "SizedQueue", "namespace": "", "path": "SizedQueue", "type": "class", "visibility": "public"}, "SizedQueue#<<": {"description": "从队列中检索数据。\\n \\n如果队列为空，则调用线程将挂起，直到将数据推送到队列中。如果+non_block+为真，则线程不会被挂起，而+ThreadError+被提升。", "name": "<<", "namespace": "SizedQueue", "path": "SizedQueue#<<", "type": "instance_method", "visibility": "public"}, "SizedQueue#clear": {"description": "将给定的+object+推送到队列。", "name": "clear", "namespace": "SizedQueue", "path": "SizedQueue#clear", "type": "instance_method", "visibility": "public"}, "SizedQueue#close": {"description": "从队列中删除所有对象。", "name": "close", "namespace": "SizedQueue", "path": "SizedQueue#close", "type": "instance_method", "visibility": "public"}, "SizedQueue#deq": {"description": "返回等待队列的线程数。", "name": "shift", "namespace": "SizedQueue", "path": "SizedQueue#shift", "type": "instance_method", "visibility": "public"}, "SizedQueue#empty?": {"description": "如果队列已关闭，则返回+true+。", "name": "empty?", "namespace": "SizedQueue", "path": "SizedQueue#empty?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "SizedQueue#enq": {"description": "从队列中检索数据。\\n \\n如果队列为空，则调用线程将挂起，直到将数据推送到队列中。如果+non_block+为真，则线程不会被挂起，而+ThreadError+被提升。", "name": "<<", "namespace": "SizedQueue", "path": "SizedQueue#<<", "type": "instance_method", "visibility": "public"}, "SizedQueue#initialize": {"description": "如果队列为空，则返回+true+。", "name": "initialize", "namespace": "SizedQueue", "path": "SizedQueue#initialize", "type": "instance_method", "visibility": "public"}, "SizedQueue#length": {"description": "", "name": "size", "namespace": "SizedQueue", "path": "SizedQueue#size", "type": "instance_method", "visibility": "public"}, "SizedQueue#size": {"description": "", "name": "size", "namespace": "SizedQueue", "path": "SizedQueue#size", "type": "instance_method", "visibility": "public"}, "SizedQueue#max": {"description": "将给定的+object+推送到队列。", "name": "max", "namespace": "SizedQueue", "path": "SizedQueue#max", "type": "instance_method", "visibility": "public"}, "SizedQueue#max=": {"description": "创建新队列实例。", "name": "max=", "namespace": "SizedQueue", "path": "SizedQueue#max=", "type": "instance_method", "visibility": "public"}, "SizedQueue#num_waiting": {"description": "返回队列的长度。", "name": "num_waiting", "namespace": "SizedQueue", "path": "SizedQueue#num_waiting", "type": "instance_method", "visibility": "public"}, "SizedQueue#pop": {"description": "返回等待队列的线程数。", "name": "shift", "namespace": "SizedQueue", "path": "SizedQueue#shift", "type": "instance_method", "visibility": "public"}, "SizedQueue#shift": {"description": "返回等待队列的线程数。", "name": "shift", "namespace": "SizedQueue", "path": "SizedQueue#shift", "type": "instance_method", "visibility": "public"}, "SizedQueue#push": {"description": "从队列中检索数据。\\n \\n如果队列为空，则调用线程将挂起，直到将数据推送到队列中。如果+non_block+为真，则线程不会被挂起，而+ThreadError+被提升。", "name": "<<", "namespace": "SizedQueue", "path": "SizedQueue#<<", "type": "instance_method", "visibility": "public"}, "ConditionVariable": {"description": "从队列中检索数据。\\n \\n如果队列为空，则调用线程将挂起，直到将数据推送到队列中。如果+non_block+为真，则线程不会被挂起，而+ThreadError+被提升。", "name": "ConditionVariable", "namespace": "", "path": "ConditionVariable", "type": "class", "visibility": "public"}, "ConditionVariable#broadcast": {"description": "将给定的+object+推送到队列。", "name": "broadcast", "namespace": "ConditionVariable", "path": "ConditionVariable#broadcast", "type": "instance_method", "visibility": "public"}, "ConditionVariable#initialize": {"description": "此类表示具有指定大小容量的队列。如果容量已满，推送操作\\n可能会被阻止。\\n \\n有关SizedQueue如何工作的示例，请参阅队列。", "name": "initialize", "namespace": "ConditionVariable", "path": "ConditionVariable#initialize", "type": "instance_method", "visibility": "public"}, "ConditionVariable#marshal_dump": {"description": ":nodoc:", "name": "marshal_dump", "namespace": "ConditionVariable", "path": "ConditionVariable#marshal_dump", "type": "instance_method", "visibility": "public"}, "ConditionVariable#signal": {"description": "pushes +object+ \\ queue。是N是N，如果没有太空离开在queue等待，直到太空变得可用，除非+non_block+是真实的。如果+non_block+是真实的，是不是suspended线程T，和+ThreadError+也raised。", "name": "signal", "namespace": "ConditionVariable", "path": "ConditionVariable#signal", "type": "instance_method", "visibility": "public"}, "ConditionVariable#wait": {"description": "removes所有的物体从queue。", "name": "wait", "namespace": "ConditionVariable", "path": "ConditionVariable#wait", "type": "instance_method", "visibility": "public"}, "ClosedQueueError": {"description": "", "name": "ClosedQueueError", "namespace": "", "path": "ClosedQueueError", "type": "class", "visibility": "public"}, "Time": {"description": "similar到queue #闭上。是N是N的behavior等也都与enqueuing线程。是N是N，如果有enqueuing线程在等待，他们是interrupted by爱丽丝ClosedQueueError（queue“封闭的”）。", "name": "Time", "namespace": "", "path": "Time", "type": "class", "visibility": "public"}, "Time#+": {"description": "retrieves数据从queue。是N是N，如果queue也是空的，打电话也suspended线程，直到数据推queue发现的。如果+non_block+是真实的，是不是suspended线程T，和+ThreadError+也raised。", "name": "+", "namespace": "Time", "path": "Time#+", "type": "instance_method", "visibility": "public"}, "Time#-": {"description": "returns +true+如果queue也是空的。", "name": "-", "namespace": "Time", "path": "Time#-", "type": "instance_method", "visibility": "public"}, "Time#<=>": {"description": "pushes +object+ \\ queue。是N是N，如果没有太空离开在queue等待，直到太空变得可用，除非+non_block+是真实的。如果+non_block+是真实的，是不是suspended线程T，和+ThreadError+也raised。", "name": "<=>", "namespace": "Time", "path": "Time#<=>", "type": "instance_method", "visibility": "public"}, "Time#_dump": {"description": ":nodoc:", "name": "_dump", "namespace": "Time", "path": "Time#_dump", "type": "instance_method", "visibility": "private"}, "Time#asctime": {"description": "returns最大尺寸的queue。", "name": "asctime", "namespace": "Time", "path": "Time#asctime", "type": "instance_method", "visibility": "public"}, "Time#ctime": {"description": "returns最大尺寸的queue。", "name": "ctime", "namespace": "Time", "path": "Time#ctime", "type": "instance_method", "visibility": "public"}, "Time#day": {"description": "如果时间发生在其时区的夏令时，则返回+true+。\\n \\n cst6cdt:\n   Time.local(2000, 1, 1).zone    #=> \"CST\"\n   Time.local(2000, 1, 1).isdst   #=> false\n   Time.local(2000, 1, 1).dst?    #=> false\n   Time.local(2000, 7, 1).zone    #=> \"CDT\"\n   Time.local(2000, 7, 1).isdst   #=> true\n   Time.local(2000, 7, 1).dst?    #=> true\n \\n  # Asia/Tokyo:\n   Time.local(2000, 1, 1).zone    #=> \"JST\"\n   Time.local(2000, 1, 1).isdst   #=> false\n   Time.local(2000, 1, 1).dst?    #=> false\n   Time.local(2000, 7, 1).zone    #=> \"JST\"\n   Time.local(2000, 7, 1).isdst   #=> false\n   Time.local(2000, 7, 1).dst?    #=> false", "name": "day", "namespace": "Time", "path": "Time#day", "type": "instance_method", "visibility": "public"}, "Time#dst?": {"description": "返回时间的规范字符串表示形式。n \n   Time.now.asctime   #=> \"Wed Apr  9 08:56:03 2003\"\n   Time.now.ctime     #=> \"Wed Apr  9 08:56:03 2003\"", "name": "dst?", "namespace": "Time", "path": "Time#dst?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Time#eql?": {"description": "retrieves数据从queue。是N是N，如果queue也是空的，打电话也suspended线程，直到数据推queue发现的。如果+non_block+是真实的，是不是suspended线程T，和+ThreadError+也raised。", "name": "eql?", "namespace": "Time", "path": "Time#eql?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Time#friday?": {"description": "retrieves数据从queue。是N是N，如果queue也是空的，打电话也suspended线程，直到数据推queue发现的。如果+non_block+是真实的，是不是suspended线程T，和+ThreadError+也raised。", "name": "friday?", "namespace": "Time", "path": "Time#friday?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Time#getgm": {"description": "wakes起来，所有的线程在等待这锁。", "name": "getgm", "namespace": "Time", "path": "Time#getgm", "type": "instance_method", "visibility": "public"}, "Time#getlocal": {"description": "conditionvariable物体augment mutex舱。使用条件变量的描述，它也可能是N到挂起，而在中间的附件部分，直到的资源变得可用。我是N N N”的例子：\n  mutex = Mutex.new\n  resource = ConditionVariable.new\n\n  a = Thread.new {\nmutex.synchronize {\n  # Thread 'a' now needs the resource\n  resource.wait(mutex)\n  # 'a' can now have the resource\n}\n  }\n\n  b = Thread.new {\nmutex.synchronize {\n  # Thread 'b' has finished using the resource\n  resource.signal\n} n”}", "name": "getlocal", "namespace": "Time", "path": "Time#getlocal", "type": "instance_method", "visibility": "public"}, "Time#getutc": {"description": "wakes起来，所有的线程在等待这锁。", "name": "getutc", "namespace": "Time", "path": "Time#getutc", "type": "instance_method", "visibility": "public"}, "Time#gmt?": {"description": "返回分钟的秒（0..60）作为时间。\\n \\n*注：*秒的范围从零到60，允许系统注入闰秒。更多详细信息，请参见http://en.wikipedia.org/wiki/leap_second。n \n   t = Time.now   #=> 2007-11-19 08:25:02 -0600\n   t.sec          #=> 2", "name": "gmt?", "namespace": "Time", "path": "Time#gmt?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Time#gmt_offset": {"description": "根据给定格式字符串中的指令格式化时间。\\n \\n指令以百分比（%）字符开头。\\n未作为指令列出的任何文本都将传递给输出字符串。\\n \\n指令由百分比（%）字符、零个或多个标志、可选最小字段宽度、可选修饰符和转换说明符组成，如下所示：\\n \n  %<flags><width><modifier><conversion>\n \\n标志：\n  -  don't pad a numerical output\n  _  use spaces for padding\n  0  use zeros for padding\n  ^  upcase the result string\n  #  change case\n  :  use colons for %z\n \\n最小字段宽度指定最小宽度。\\n \\n修饰符是“e”和“o”。\\n它们被忽略。\\n \\n格式指令：\\n \n  Date (Year, Month, Day):\n    %Y - Year with century if provided, will pad result at least 4 digits.\n            -0001, 0000, 1995, 2009, 14292, etc.\n    %C - year / 100 (rounded down such as 20 in 2009)\n    %y - year % 100 (00..99)\n\n    %m - Month of the year, zero-padded (01..12)\n            %_m  blank-padded ( 1..12)\n            %-m  no-padded (1..12)\n    %B - The full month name (``January'')\n            %^B  uppercased (``JANUARY'')\n    %b - The abbreviated month name (``Jan'')\n            %^b  uppercased (``JAN'')\n    %h - Equivalent to %b\n\n    %d - Day of the month, zero-padded (01..31)\n            %-d  no-padded (1..31)\n    %e - Day of the month, blank-padded ( 1..31)\n\n    %j - Day of the year (001..366)\n\n  Time (Hour, Minute, Second, Subsecond):\n    %H - Hour of the day, 24-hour clock, zero-padded (00..23)\n    %k - Hour of the day, 24-hour clock, blank-padded ( 0..23)\n    %I - Hour of the day, 12-hour clock, zero-padded (01..12)\n    %l - Hour of the day, 12-hour clock, blank-padded ( 1..12)\n    %P - Meridian indicator, lowercase (``am'' or ``pm'')\n    %p - Meridian indicator, uppercase (``AM'' or ``PM'')\n\n    %M - Minute of the hour (00..59)\n\n    %S - Second of the minute (00..60)\n\n    %L - Millisecond of the second (000..999)\n         The digits under millisecond are truncated to not produce 1000.\n    %N - Fractional seconds digits, default is 9 digits (nanosecond)\n            %3N  millisecond (3 digits)\n            %6N  microsecond (6 digits)\n            %9N  nanosecond (9 digits)\n            %12N picosecond (12 digits)\n            %15N femtosecond (15 digits)\n            %18N attosecond (18 digits)\n            %21N zeptosecond (21 digits)\n            %24N yoctosecond (24 digits)\n         The digits under the specified length are truncated to avoid\n         carry up.\n\n  Time zone:\n    %z - Time zone as hour and minute offset from UTC (e.g. +0900)\n            %:z - hour and minute offset from UTC with a colon (e.g. +09:00)\n            %::z - hour, minute and second offset from UTC (e.g. +09:00:00)\n    %Z - Abbreviated time zone name or similar information.  (OS dependent)\n\n  Weekday:\n    %A - The full weekday name (``Sunday'')\n            %^A  uppercased (``SUNDAY'')\n    %a - The abbreviated name (``Sun'')\n            %^a  uppercased (``SUN'')\n    %u - Day of the week (Monday is 1, 1..7)\n    %w - Day of the week (Sunday is 0, 0..6)\n\n  ISO 8601 week-based year and week number:\n  The first week of YYYY starts with a Monday and includes YYYY-01-04.\n  The days in the year before the first week are in the last week of\n  the previous year.\n    %G - The week-based year\n    %g - The last 2 digits of the week-based year (00..99)\n    %V - Week number of the week-based year (01..53)\n\n  ISO 8601 week-based year and week number:\n  The first week of YYYY starts with a Monday and includes YYYY-01-04.\n  The days in the year before the first week are in the last week of\n  the previous year.\n    %G - The week-based year\n    %g - The last 2 digits of the week-based year (00..99)\n    %V - Week number of the week-based year (01..53)\n\n  Week number:\n  The first week of YYYY that starts with a Sunday or Monday (according to %U\n  or %W). The days in the year before the first week are in week 0.\n    %U - Week number of the year. The week starts with Sunday. (00..53)\n    %W - Week number of the year. The week starts with Monday. (00..53)\n\n  Seconds since the Epoch:\n    %s - Number of seconds since 1970-01-01 00:00:00 UTC.\n\n  Literal string:\n    %n - Newline character (\\n)\n    %t - Tab character (\\t)\n    %% - Literal ``%'' character\n\n  Combination:\n    %c - date and time (%a %b %e %T %Y)\n    %D - Date (%m/%d/%y)\n    %F - The ISO 8601 date format (%Y-%m-%d)\n    %v - VMS date (%e-%^b-%4Y)\n    %x - Same as %D\n    %X - Same as %T\n    %r - 12-hour time (%I:%M:%S %p)\n    %R - 24-hour time (%H:%M)\n    %T - 24-hour time (%H:%M:%S)\n \\n此方法类似于ISO C和POSIX中定义的strftime（）函数。\\n \\n由于Ruby1.9，虽然所有指令都与区域设置无关，但%z依赖于平台。\\n因此，即使在其他系统（如C）中使用相同的格式字符串，结果也可能不同。\\n\\n建议在%z上使用%z。\\n%z不标识时区。\\n例如，在美国/芝加哥（-06:00）、美国/哈瓦那（-05:00）、亚洲/哈尔滨（+08:00）、澳大利亚/达尔文（+09:30）和澳大利亚/阿德莱德（+10:30）使用“cst”。\\n另外，%z高度依赖于操作系统。\\n例如，它可能会在日语窗口上生成非ASCII字符串。\\n也就是说，结果可能与“jst”不同。\\n因此，建议使用数字时区偏移量%z。\\n \\n示例：\\n \n  t = Time.new(2007,11,19,8,37,48,\"-06:00\") #=> 2007-11-19 08:37:48 -0600\n  t.strftime(\"Printed on %m/%d/%Y\")   #=> \"Printed on 11/19/2007\"\n  t.strftime(\"at %I:%M%p\")            #=> \"at 08:37AM\"\n \\n各种ISO 8601格式：\n  %Y%m%d           => 20071119                  Calendar date (basic)\n  %F               => 2007-11-19                Calendar date (extended)\n  %Y-%m            => 2007-11                   Calendar date, reduced accuracy, specific month\n  %Y               => 2007                      Calendar date, reduced accuracy, specific year\n  %C               => 20                        Calendar date, reduced accuracy, specific century\n  %Y%j             => 2007323                   Ordinal date (basic)\n  %Y-%j            => 2007-323                  Ordinal date (extended)\n  %GW%V%u          => 2007W471                  Week date (basic)\n  %G-W%V-%u        => 2007-W47-1                Week date (extended)\n  %GW%V            => 2007W47                   Week date, reduced accuracy, specific week (basic)\n  %G-W%V           => 2007-W47                  Week date, reduced accuracy, specific week (extended)\n  %H%M%S           => 083748                    Local time (basic)\n  %T               => 08:37:48                  Local time (extended)\n  %H%M             => 0837                      Local time, reduced accuracy, specific minute (basic)\n  %H:%M            => 08:37                     Local time, reduced accuracy, specific minute (extended)\n  %H               => 08                        Local time, reduced accuracy, specific hour\n  %H%M%S,%L        => 083748,000                Local time with decimal fraction, comma as decimal sign (basic)\n  %T,%L            => 08:37:48,000              Local time with decimal fraction, comma as decimal sign (extended)\n  %H%M%S.%L        => 083748.000                Local time with decimal fraction, full stop as decimal sign (basic)\n  %T.%L            => 08:37:48.000              Local time with decimal fraction, full stop as decimal sign (extended)\n  %H%M%S%z         => 083748-0600               Local time and the difference from UTC (basic)\n  %T%:z            => 08:37:48-06:00            Local time and the difference from UTC (extended)\n  %Y%m%dT%H%M%S%z  => 20071119T083748-0600      Date and time of day for calendar date (basic)\n  %FT%T%:z         => 2007-11-19T08:37:48-06:00 Date and time of day for calendar date (extended)\n  %Y%jT%H%M%S%z    => 2007323T083748-0600       Date and time of day for ordinal date (basic)\n  %Y-%jT%T%:z      => 2007-323T08:37:48-06:00   Date and time of day for ordinal date (extended)\n  %GW%V%uT%H%M%S%z => 2007W471T083748-0600      Date and time of day for week date (basic)\n  %G-W%V-%uT%T%:z  => 2007-W47-1T08:37:48-06:00 Date and time of day for week date (extended)\n  %Y%m%dT%H%M      => 20071119T0837             Calendar date and local time (basic)\n  %FT%R            => 2007-11-19T08:37          Calendar date and local time (extended)\n  %Y%jT%H%MZ       => 2007323T0837Z             Ordinal date and UTC of day (basic)\n  %Y-%jT%RZ        => 2007-323T08:37Z           Ordinal date and UTC of day (extended)\n  %GW%V%uT%H%M%z   => 2007W471T0837-0600        Week date and local time and difference from UTC (basic)\n%g-w%v-%ut%r%：z=>2007-W47-1T08:37-06:00星期日期和本地时间以及与UTC的差异（扩展）", "name": "gmt_offset", "namespace": "Time", "path": "Time#gmt_offset", "type": "instance_method", "visibility": "public"}, "Time#gmtime": {"description": "如果时间表示星期六，则返回+true+。n \n   t = Time.local(2006, 6, 10)      #=> 2006-06-10 00:00:00 -0500\n   t.saturday?                      #=> true", "name": "gmtime", "namespace": "Time", "path": "Time#gmtime", "type": "instance_method", "visibility": "public"}, "Time#gmtoff": {"description": "根据给定格式字符串中的指令格式化时间。\\n \\n指令以百分比（%）字符开头。\\n未作为指令列出的任何文本都将传递给输出字符串。\\n \\n指令由百分比（%）字符、零个或多个标志、可选最小字段宽度、可选修饰符和转换说明符组成，如下所示：\\n \n  %<flags><width><modifier><conversion>\n \\n标志：\n  -  don't pad a numerical output\n  _  use spaces for padding\n  0  use zeros for padding\n  ^  upcase the result string\n  #  change case\n  :  use colons for %z\n \\n最小字段宽度指定最小宽度。\\n \\n修饰符是“e”和“o”。\\n它们被忽略。\\n \\n格式指令：\\n \n  Date (Year, Month, Day):\n    %Y - Year with century if provided, will pad result at least 4 digits.\n            -0001, 0000, 1995, 2009, 14292, etc.\n    %C - year / 100 (rounded down such as 20 in 2009)\n    %y - year % 100 (00..99)\n\n    %m - Month of the year, zero-padded (01..12)\n            %_m  blank-padded ( 1..12)\n            %-m  no-padded (1..12)\n    %B - The full month name (``January'')\n            %^B  uppercased (``JANUARY'')\n    %b - The abbreviated month name (``Jan'')\n            %^b  uppercased (``JAN'')\n    %h - Equivalent to %b\n\n    %d - Day of the month, zero-padded (01..31)\n            %-d  no-padded (1..31)\n    %e - Day of the month, blank-padded ( 1..31)\n\n    %j - Day of the year (001..366)\n\n  Time (Hour, Minute, Second, Subsecond):\n    %H - Hour of the day, 24-hour clock, zero-padded (00..23)\n    %k - Hour of the day, 24-hour clock, blank-padded ( 0..23)\n    %I - Hour of the day, 12-hour clock, zero-padded (01..12)\n    %l - Hour of the day, 12-hour clock, blank-padded ( 1..12)\n    %P - Meridian indicator, lowercase (``am'' or ``pm'')\n    %p - Meridian indicator, uppercase (``AM'' or ``PM'')\n\n    %M - Minute of the hour (00..59)\n\n    %S - Second of the minute (00..60)\n\n    %L - Millisecond of the second (000..999)\n         The digits under millisecond are truncated to not produce 1000.\n    %N - Fractional seconds digits, default is 9 digits (nanosecond)\n            %3N  millisecond (3 digits)\n            %6N  microsecond (6 digits)\n            %9N  nanosecond (9 digits)\n            %12N picosecond (12 digits)\n            %15N femtosecond (15 digits)\n            %18N attosecond (18 digits)\n            %21N zeptosecond (21 digits)\n            %24N yoctosecond (24 digits)\n         The digits under the specified length are truncated to avoid\n         carry up.\n\n  Time zone:\n    %z - Time zone as hour and minute offset from UTC (e.g. +0900)\n            %:z - hour and minute offset from UTC with a colon (e.g. +09:00)\n            %::z - hour, minute and second offset from UTC (e.g. +09:00:00)\n    %Z - Abbreviated time zone name or similar information.  (OS dependent)\n\n  Weekday:\n    %A - The full weekday name (``Sunday'')\n            %^A  uppercased (``SUNDAY'')\n    %a - The abbreviated name (``Sun'')\n            %^a  uppercased (``SUN'')\n    %u - Day of the week (Monday is 1, 1..7)\n    %w - Day of the week (Sunday is 0, 0..6)\n\n  ISO 8601 week-based year and week number:\n  The first week of YYYY starts with a Monday and includes YYYY-01-04.\n  The days in the year before the first week are in the last week of\n  the previous year.\n    %G - The week-based year\n    %g - The last 2 digits of the week-based year (00..99)\n    %V - Week number of the week-based year (01..53)\n\n  ISO 8601 week-based year and week number:\n  The first week of YYYY starts with a Monday and includes YYYY-01-04.\n  The days in the year before the first week are in the last week of\n  the previous year.\n    %G - The week-based year\n    %g - The last 2 digits of the week-based year (00..99)\n    %V - Week number of the week-based year (01..53)\n\n  Week number:\n  The first week of YYYY that starts with a Sunday or Monday (according to %U\n  or %W). The days in the year before the first week are in week 0.\n    %U - Week number of the year. The week starts with Sunday. (00..53)\n    %W - Week number of the year. The week starts with Monday. (00..53)\n\n  Seconds since the Epoch:\n    %s - Number of seconds since 1970-01-01 00:00:00 UTC.\n\n  Literal string:\n    %n - Newline character (\\n)\n    %t - Tab character (\\t)\n    %% - Literal ``%'' character\n\n  Combination:\n    %c - date and time (%a %b %e %T %Y)\n    %D - Date (%m/%d/%y)\n    %F - The ISO 8601 date format (%Y-%m-%d)\n    %v - VMS date (%e-%^b-%4Y)\n    %x - Same as %D\n    %X - Same as %T\n    %r - 12-hour time (%I:%M:%S %p)\n    %R - 24-hour time (%H:%M)\n    %T - 24-hour time (%H:%M:%S)\n \\n此方法类似于ISO C和POSIX中定义的strftime（）函数。\\n \\n由于Ruby1.9，虽然所有指令都与区域设置无关，但%z依赖于平台。\\n因此，即使在其他系统（如C）中使用相同的格式字符串，结果也可能不同。\\n\\n建议在%z上使用%z。\\n%z不标识时区。\\n例如，在美国/芝加哥（-06:00）、美国/哈瓦那（-05:00）、亚洲/哈尔滨（+08:00）、澳大利亚/达尔文（+09:30）和澳大利亚/阿德莱德（+10:30）使用“cst”。\\n另外，%z高度依赖于操作系统。\\n例如，它可能会在日语窗口上生成非ASCII字符串。\\n也就是说，结果可能与“jst”不同。\\n因此，建议使用数字时区偏移量%z。\\n \\n示例：\\n \n  t = Time.new(2007,11,19,8,37,48,\"-06:00\") #=> 2007-11-19 08:37:48 -0600\n  t.strftime(\"Printed on %m/%d/%Y\")   #=> \"Printed on 11/19/2007\"\n  t.strftime(\"at %I:%M%p\")            #=> \"at 08:37AM\"\n \\n各种ISO 8601格式：\n  %Y%m%d           => 20071119                  Calendar date (basic)\n  %F               => 2007-11-19                Calendar date (extended)\n  %Y-%m            => 2007-11                   Calendar date, reduced accuracy, specific month\n  %Y               => 2007                      Calendar date, reduced accuracy, specific year\n  %C               => 20                        Calendar date, reduced accuracy, specific century\n  %Y%j             => 2007323                   Ordinal date (basic)\n  %Y-%j            => 2007-323                  Ordinal date (extended)\n  %GW%V%u          => 2007W471                  Week date (basic)\n  %G-W%V-%u        => 2007-W47-1                Week date (extended)\n  %GW%V            => 2007W47                   Week date, reduced accuracy, specific week (basic)\n  %G-W%V           => 2007-W47                  Week date, reduced accuracy, specific week (extended)\n  %H%M%S           => 083748                    Local time (basic)\n  %T               => 08:37:48                  Local time (extended)\n  %H%M             => 0837                      Local time, reduced accuracy, specific minute (basic)\n  %H:%M            => 08:37                     Local time, reduced accuracy, specific minute (extended)\n  %H               => 08                        Local time, reduced accuracy, specific hour\n  %H%M%S,%L        => 083748,000                Local time with decimal fraction, comma as decimal sign (basic)\n  %T,%L            => 08:37:48,000              Local time with decimal fraction, comma as decimal sign (extended)\n  %H%M%S.%L        => 083748.000                Local time with decimal fraction, full stop as decimal sign (basic)\n  %T.%L            => 08:37:48.000              Local time with decimal fraction, full stop as decimal sign (extended)\n  %H%M%S%z         => 083748-0600               Local time and the difference from UTC (basic)\n  %T%:z            => 08:37:48-06:00            Local time and the difference from UTC (extended)\n  %Y%m%dT%H%M%S%z  => 20071119T083748-0600      Date and time of day for calendar date (basic)\n  %FT%T%:z         => 2007-11-19T08:37:48-06:00 Date and time of day for calendar date (extended)\n  %Y%jT%H%M%S%z    => 2007323T083748-0600       Date and time of day for ordinal date (basic)\n  %Y-%jT%T%:z      => 2007-323T08:37:48-06:00   Date and time of day for ordinal date (extended)\n  %GW%V%uT%H%M%S%z => 2007W471T083748-0600      Date and time of day for week date (basic)\n  %G-W%V-%uT%T%:z  => 2007-W47-1T08:37:48-06:00 Date and time of day for week date (extended)\n  %Y%m%dT%H%M      => 20071119T0837             Calendar date and local time (basic)\n  %FT%R            => 2007-11-19T08:37          Calendar date and local time (extended)\n  %Y%jT%H%MZ       => 2007323T0837Z             Ordinal date and UTC of day (basic)\n  %Y-%jT%RZ        => 2007-323T08:37Z           Ordinal date and UTC of day (extended)\n  %GW%V%uT%H%M%z   => 2007W471T0837-0600        Week date and local time and difference from UTC (basic)\n%g-w%v-%ut%r%：z=>2007-W47-1T08:37-06:00星期日期和本地时间以及与UTC的差异（扩展）", "name": "gmtoff", "namespace": "Time", "path": "Time#gmtoff", "type": "instance_method", "visibility": "public"}, "Time#hash": {"description": "此外adds -一些的数秒（可能fractional）到时间和returns value，20世纪的时代新的对象。我\n   t = Time.now         #=> 2007-11-19 08:22:21 -0600\n   t + (60 * 60 * 24)   #=> 2007-11-20 08:22:21 -0600 n", "name": "hash", "namespace": "Time", "path": "Time#hash", "type": "instance_method", "visibility": "public"}, "Time#hour": {"description": "差-以秒为单位返回时间与+other_time+之间的浮点差，或从时间中减去+numeric+中给定的秒数。n \n   t = Time.now       #=> 2007-11-19 08:23:10 -0600\n   t2 = t + 2592000   #=> 2007-12-19 08:23:10 -0600\n   t2 - t             #=> 2592000.0\n   t2 - 2592000       #=> 2007-11-19 08:23:10 -0600", "name": "hour", "namespace": "Time", "path": "Time#hour", "type": "instance_method", "visibility": "public"}, "Time#initialize": {"description": "比较-比较+time+和+other_time+。\\n \\n- 1、0、+1或nil，取决于+time+是否小于、等于或大于+other_time+。\\n \\n如果这两个值不可比较，则返回+nil+。n \n   t = Time.now       #=> 2007-11-19 08:12:12 -0600\n   t2 = t + 2592000   #=> 2007-12-19 08:12:12 -0600\n   t <=> t2           #=> -1\n   t2 <=> t           #=> 1\n\n   t = Time.now       #=> 2007-11-19 08:13:38 -0600\n   t2 = t + 0.1       #=> 2007-11-19 08:13:38 -0600\n   t.nsec             #=> 98222999\n   t2.nsec            #=> 198222999\n   t <=> t2           #=> -1\n   t2 <=> t           #=> 1\n   t <=> t            #=> 0", "name": "initialize", "namespace": "Time", "path": "Time#initialize", "type": "instance_method", "visibility": "public"}, "Time#initialize_copy": {"description": ":nodoc:", "name": "initialize_copy", "namespace": "Time", "path": "Time#initialize_copy", "type": "instance_method", "visibility": "public"}, "Time#inspect": {"description": "返回时间的小时分钟（0..59）。n \n   t = Time.now   #=> 2007-11-19 08:25:51 -0600\n   t.min          #=> 25", "name": "inspect", "namespace": "Time", "path": "Time#inspect", "type": "instance_method", "visibility": "public"}, "Time#isdst": {"description": "返回时间的规范字符串表示形式。n \n   Time.now.asctime   #=> \"Wed Apr  9 08:56:03 2003\"\n   Time.now.ctime     #=> \"Wed Apr  9 08:56:03 2003\"", "name": "isdst", "namespace": "Time", "path": "Time#isdst", "type": "instance_method", "visibility": "public"}, "Time#localtime": {"description": "返回时间的月份日期（1..n）。n \n   t = Time.now   #=> 2007-11-19 08:27:03 -0600\n   t.day          #=> 19\n   t.mday         #=> 19", "name": "localtime", "namespace": "Time", "path": "Time#localtime", "type": "instance_method", "visibility": "public"}, "Time#marshal_dump": {"description": ":nodoc:", "name": "marshal_dump", "namespace": "Time", "path": "Time#marshal_dump", "type": "instance_method", "visibility": "private"}, "Time#marshal_load": {"description": ":nodoc:", "name": "marshal_load", "namespace": "Time", "path": "Time#marshal_load", "type": "instance_method", "visibility": "private"}, "Time#mday": {"description": "如果时间发生在其时区的夏令时，则返回+true+。\\n \\n cst6cdt:\n   Time.local(2000, 1, 1).zone    #=> \"CST\"\n   Time.local(2000, 1, 1).isdst   #=> false\n   Time.local(2000, 1, 1).dst?    #=> false\n   Time.local(2000, 7, 1).zone    #=> \"CDT\"\n   Time.local(2000, 7, 1).isdst   #=> true\n   Time.local(2000, 7, 1).dst?    #=> true\n \\n  # Asia/Tokyo:\n   Time.local(2000, 1, 1).zone    #=> \"JST\"\n   Time.local(2000, 1, 1).isdst   #=> false\n   Time.local(2000, 1, 1).dst?    #=> false\n   Time.local(2000, 7, 1).zone    #=> \"JST\"\n   Time.local(2000, 7, 1).isdst   #=> false\n   Time.local(2000, 7, 1).dst?    #=> false", "name": "mday", "namespace": "Time", "path": "Time#mday", "type": "instance_method", "visibility": "public"}, "Time#min": {"description": "如果时间和+other_time+都是具有相同秒和小数秒的时间对象，则返回+true+。", "name": "min", "namespace": "Time", "path": "Time#min", "type": "instance_method", "visibility": "public"}, "Time#mon": {"description": "返回一个新的时间对象，该对象表示以本地时间表示的时间（使用对此进程有效的本地时区）。\\n \\n如果给定+utc_offset+，则使用它而不是本地时间。\\n +utc_offset+可以作为人类可读的字符串（例如<code>\"+09:00\"</code>）或秒数（例如<code>32400</code>）提供。n \n   t = Time.utc(2000,1,1,20,15,1)  #=> 2000-01-01 20:15:01 UTC\n   t.utc?                          #=> true\n\n   l = t.getlocal                  #=> 2000-01-01 14:15:01 -0600\n   l.utc?                          #=> false\n   t == l                          #=> true\n\n   j = t.getlocal(\"+09:00\")        #=> 2000-01-02 05:15:01 +0900\n   j.utc?                          #=> false\n   t == j                          #=> true\n\n   k = t.getlocal(9*60*60)         #=> 2000-01-02 05:15:01 +0900\n   k.utc?                          #=> false\n   t == k                          #=> true", "name": "mon", "namespace": "Time", "path": "Time#mon", "type": "instance_method", "visibility": "public"}, "Time#monday?": {"description": "返回一个新的时间对象，该对象以UTC表示时间。n \n   t = Time.local(2000,1,1,20,15,1)   #=> 2000-01-01 20:15:01 -0600\n   t.gmt?                             #=> false\n   y = t.getgm                        #=> 2000-01-02 02:15:01 UTC\n   y.gmt?                             #=> true\n   t == y                             #=> true", "name": "monday?", "namespace": "Time", "path": "Time#monday?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Time#month": {"description": "返回一个新的时间对象，该对象表示以本地时间表示的时间（使用对此进程有效的本地时区）。\\n \\n如果给定+utc_offset+，则使用它而不是本地时间。\\n +utc_offset+可以作为人类可读的字符串（例如<code>\"+09:00\"</code>）或秒数（例如<code>32400</code>）提供。n \n   t = Time.utc(2000,1,1,20,15,1)  #=> 2000-01-01 20:15:01 UTC\n   t.utc?                          #=> true\n\n   l = t.getlocal                  #=> 2000-01-01 14:15:01 -0600\n   l.utc?                          #=> false\n   t == l                          #=> true\n\n   j = t.getlocal(\"+09:00\")        #=> 2000-01-02 05:15:01 +0900\n   j.utc?                          #=> false\n   t == j                          #=> true\n\n   k = t.getlocal(9*60*60)         #=> 2000-01-02 05:15:01 +0900\n   k.utc?                          #=> false\n   t == k                          #=> true", "name": "month", "namespace": "Time", "path": "Time#month", "type": "instance_method", "visibility": "public"}, "Time#nsec": {"description": "如果时间表示星期一，则返回+true+。n \n   t = Time.local(2003, 8, 4)       #=> 2003-08-04 00:00:00 -0500\n   p t.monday?                      #=> true", "name": "nsec", "namespace": "Time", "path": "Time#nsec", "type": "instance_method", "visibility": "public"}, "Time#round": {"description": "如果时间表示以UTC（GMT）表示的时间，则返回+true+。n \n   t = Time.now                        #=> 2007-11-19 08:15:23 -0600\n   t.utc?                              #=> false\n   t = Time.gm(2000,\"jan\",1,20,15,1)   #=> 2000-01-01 20:15:01 UTC\n   t.utc?                              #=> true\n\n   t = Time.now                        #=> 2007-11-19 08:16:03 -0600\n   t.gmt?                              #=> false\n   t = Time.gm(2000,1,1,20,15,1)       #=> 2000-01-01 20:15:01 UTC\n   t.gmt?                              #=> true", "name": "round", "namespace": "Time", "path": "Time#round", "type": "instance_method", "visibility": "public"}, "Time#saturday?": {"description": "返回时区和UTC之间以秒为单位的偏移量。n \n   t = Time.gm(2000,1,1,20,15,1)   #=> 2000-01-01 20:15:01 UTC\n   t.gmt_offset                    #=> 0\n   l = t.getlocal                  #=> 2000-01-01 14:15:01 -0600\n   l.gmt_offset                    #=> -21600", "name": "saturday?", "namespace": "Time", "path": "Time#saturday?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Time#sec": {"description": "将时间转换为UTC（GMT），修改接收器。n \n   t = Time.now   #=> 2007-11-19 08:18:31 -0600\n   t.gmt?         #=> false\n   t.gmtime       #=> 2007-11-19 14:18:31 UTC\n   t.gmt?         #=> true\n\n   t = Time.now   #=> 2007-11-19 08:18:51 -0600\n   t.utc?         #=> false\n   t.utc          #=> 2007-11-19 14:18:51 UTC\n   t.utc?         #=> true", "name": "sec", "namespace": "Time", "path": "Time#sec", "type": "instance_method", "visibility": "public"}, "Time#strftime": {"description": "返回时区和UTC之间以秒为单位的偏移量。n \n   t = Time.gm(2000,1,1,20,15,1)   #=> 2000-01-01 20:15:01 UTC\n   t.gmt_offset                    #=> 0\n   l = t.getlocal                  #=> 2000-01-01 14:15:01 -0600\n   l.gmt_offset                    #=> -21600", "name": "strftime", "namespace": "Time", "path": "Time#strftime", "type": "instance_method", "visibility": "public"}, "Time#subsec": {"description": "返回此时间对象的哈希代码。\\n \\n另请参阅对象哈希。", "name": "subsec", "namespace": "Time", "path": "Time#subsec", "type": "instance_method", "visibility": "public"}, "Time#succ": {"description": "", "name": "succ", "namespace": "Time", "path": "Time#succ", "type": "instance_method", "visibility": "public"}, "Time#sunday?": {"description": "返回一天中时间的小时（0..23）。n \n   t = Time.now   #=> 2007-11-19 08:26:20 -0600\n   t.hour         #=> 8", "name": "sunday?", "namespace": "Time", "path": "Time#sunday?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Time#thursday?": {"description": "返回时间对象。\\n \\n如果没有给定参数，则初始化为当前系统时间。\\n\\n*注：*新对象将使用系统时钟上可用的分辨率，可能包括小数秒。\\n \\n如果指定了一个或多个参数，则时间将初始化为指定的时间。\\n \\n +sec+如果是有理数，则可能具有小数。\\n \\n +utc_offset+是与UTC的偏移量。\\n它可以是一个字符串，如“+09:00”，也可以是一些秒数，如32400。n \n   a = Time.new      #=> 2007-11-19 07:50:02 -0600\n   b = Time.new      #=> 2007-11-19 07:50:02 -0600\n   a == b            #=> false\n   \"%.6f\" % a.to_f   #=> \"1195480202.282373\"\n   \"%.6f\" % b.to_f   #=> \"1195480202.283415\"\n\n   Time.new(2008,6,21, 13,30,0, \"+09:00\") #=> 2008-06-21 13:30:00 +0900\n\n   # A trip for RubyConf 2007\n   t1 = Time.new(2007,11,1,15,25,0, \"+09:00\") # JST (Narita)\n   t2 = Time.new(2007,11,1,12, 5,0, \"-05:00\") # CDT (Minneapolis)\n   t3 = Time.new(2007,11,1,13,25,0, \"-05:00\") # CDT (Minneapolis)\n   t4 = Time.new(2007,11,1,16,53,0, \"-04:00\") # EDT (Charlotte)\n   t5 = Time.new(2007,11,5, 9,24,0, \"-05:00\") # EST (Charlotte)\n   t6 = Time.new(2007,11,5,11,21,0, \"-05:00\") # EST (Detroit)\n   t7 = Time.new(2007,11,5,13,45,0, \"-05:00\") # EST (Detroit)\n   t8 = Time.new(2007,11,6,17,10,0, \"+09:00\") # JST (Narita)\n   p((t2-t1)/3600.0)                          #=> 10.666666666666666\n   p((t4-t3)/3600.0)                          #=> 2.466666666666667\n   p((t6-t5)/3600.0)                          #=> 1.95\n   p((t8-t7)/3600.0)                          #=> 13.416666666666666", "name": "thursday?", "namespace": "Time", "path": "Time#thursday?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Time#to_a": {"description": "返回表示时间的字符串。相当于使用适当的格式字符串调用\\n strftime。\\n \n   t = Time.now\n   t.to_s                              => \"2012-11-10 18:16:12 +0100\"\n   t.strftime \"%Y-%m-%d %H:%M:%S %z\"   => \"2012-11-10 18:16:12 +0100\"\n\n   t.utc.to_s                          => \"2012-11-10 17:16:12 UTC\"\n t.strftime“%y-%m-%d%h:%m:%s UTC”=>“2012-11-10 17:16:12 UTC”", "name": "to_a", "namespace": "Time", "path": "Time#to_a", "type": "instance_method", "visibility": "public"}, "Time#to_f": {"description": "如果时间发生在其时区的夏令时，则返回+true+。\\n \\n cst6cdt:\n   Time.local(2000, 1, 1).zone    #=> \"CST\"\n   Time.local(2000, 1, 1).isdst   #=> false\n   Time.local(2000, 1, 1).dst?    #=> false\n   Time.local(2000, 7, 1).zone    #=> \"CDT\"\n   Time.local(2000, 7, 1).isdst   #=> true\n   Time.local(2000, 7, 1).dst?    #=> true\n \\n  # Asia/Tokyo:\n   Time.local(2000, 1, 1).zone    #=> \"JST\"\n   Time.local(2000, 1, 1).isdst   #=> false\n   Time.local(2000, 1, 1).dst?    #=> false\n   Time.local(2000, 7, 1).zone    #=> \"JST\"\n   Time.local(2000, 7, 1).isdst   #=> false\n   Time.local(2000, 7, 1).dst?    #=> false", "name": "to_f", "namespace": "Time", "path": "Time#to_f", "type": "instance_method", "visibility": "public"}, "Time#to_i": {"description": "返回一年中时间的月份（1..12）。n \n   t = Time.now   #=> 2007-11-19 08:27:30 -0600\n   t.mon          #=> 11\n   t.month        #=> 11", "name": "to_i", "namespace": "Time", "path": "Time#to_i", "type": "instance_method", "visibility": "public"}, "Time#to_r": {"description": "返回时间的月份日期（1..n）。n \n   t = Time.now   #=> 2007-11-19 08:27:03 -0600\n   t.day          #=> 19\n   t.mday         #=> 19", "name": "to_r", "namespace": "Time", "path": "Time#to_r", "type": "instance_method", "visibility": "public"}, "Time#to_s": {"description": "返回时间的小时分钟（0..59）。n \n   t = Time.now   #=> 2007-11-19 08:25:51 -0600\n   t.min          #=> 25", "name": "to_s", "namespace": "Time", "path": "Time#to_s", "type": "instance_method", "visibility": "public"}, "Time#tuesday?": {"description": "返回一年中时间的月份（1..12）。n \n   t = Time.now   #=> 2007-11-19 08:27:30 -0600\n   t.mon          #=> 11\n   t.month        #=> 11", "name": "tuesday?", "namespace": "Time", "path": "Time#tuesday?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Time#tv_nsec": {"description": "如果时间表示星期一，则返回+true+。n \n   t = Time.local(2003, 8, 4)       #=> 2003-08-04 00:00:00 -0500\n   p t.monday?                      #=> true", "name": "tv_nsec", "namespace": "Time", "path": "Time#tv_nsec", "type": "instance_method", "visibility": "public"}, "Time#tv_sec": {"description": "返回一年中时间的月份（1..12）。n \n   t = Time.now   #=> 2007-11-19 08:27:30 -0600\n   t.mon          #=> 11\n   t.month        #=> 11", "name": "tv_sec", "namespace": "Time", "path": "Time#tv_sec", "type": "instance_method", "visibility": "public"}, "Time#tv_usec": {"description": "将秒数舍入到以十进制数字表示的给定精度（默认为0位）。\\n它返回新的时间对象。\\n +ndigits+应为零或正整数。n \n    require 'time'\n\n    t = Time.utc(2010,3,30, 5,43,\"25.123456789\".to_r)\n    p t.iso8601(10)           #=> \"2010-03-30T05:43:25.1234567890Z\"\n    p t.round.iso8601(10)     #=> \"2010-03-30T05:43:25.0000000000Z\"\n    p t.round(0).iso8601(10)  #=> \"2010-03-30T05:43:25.0000000000Z\"\n    p t.round(1).iso8601(10)  #=> \"2010-03-30T05:43:25.1000000000Z\"\n    p t.round(2).iso8601(10)  #=> \"2010-03-30T05:43:25.1200000000Z\"\n    p t.round(3).iso8601(10)  #=> \"2010-03-30T05:43:25.1230000000Z\"\n    p t.round(4).iso8601(10)  #=> \"2010-03-30T05:43:25.1235000000Z\"\n    p t.round(5).iso8601(10)  #=> \"2010-03-30T05:43:25.1234600000Z\"\n    p t.round(6).iso8601(10)  #=> \"2010-03-30T05:43:25.1234570000Z\"\n    p t.round(7).iso8601(10)  #=> \"2010-03-30T05:43:25.1234568000Z\"\n    p t.round(8).iso8601(10)  #=> \"2010-03-30T05:43:25.1234567900Z\"\n    p t.round(9).iso8601(10)  #=> \"2010-03-30T05:43:25.1234567890Z\"\n    p t.round(10).iso8601(10) #=> \"2010-03-30T05:43:25.1234567890Z\"\n\n    t = Time.utc(1999,12,31, 23,59,59)\n    p((t + 0.4).round.iso8601(3))    #=> \"1999-12-31T23:59:59.000Z\"\n    p((t + 0.49).round.iso8601(3))   #=> \"1999-12-31T23:59:59.000Z\"\n    p((t + 0.5).round.iso8601(3))    #=> \"2000-01-01T00:00:00.000Z\"\n    p((t + 1.4).round.iso8601(3))    #=> \"2000-01-01T00:00:00.000Z\"\n    p((t + 1.49).round.iso8601(3))   #=> \"2000-01-01T00:00:00.000Z\"\n    p((t + 1.5).round.iso8601(3))    #=> \"2000-01-01T00:00:01.000Z\"\n\n    t = Time.utc(1999,12,31, 23,59,59)\n    p (t + 0.123456789).round(4).iso8601(6)  #=> \"1999-12-31T23:59:59.123500Z\"", "name": "tv_usec", "namespace": "Time", "path": "Time#tv_usec", "type": "instance_method", "visibility": "public"}, "Time#usec": {"description": "将秒数舍入到以十进制数字表示的给定精度（默认为0位）。\\n它返回新的时间对象。\\n +ndigits+应为零或正整数。n \n    require 'time'\n\n    t = Time.utc(2010,3,30, 5,43,\"25.123456789\".to_r)\n    p t.iso8601(10)           #=> \"2010-03-30T05:43:25.1234567890Z\"\n    p t.round.iso8601(10)     #=> \"2010-03-30T05:43:25.0000000000Z\"\n    p t.round(0).iso8601(10)  #=> \"2010-03-30T05:43:25.0000000000Z\"\n    p t.round(1).iso8601(10)  #=> \"2010-03-30T05:43:25.1000000000Z\"\n    p t.round(2).iso8601(10)  #=> \"2010-03-30T05:43:25.1200000000Z\"\n    p t.round(3).iso8601(10)  #=> \"2010-03-30T05:43:25.1230000000Z\"\n    p t.round(4).iso8601(10)  #=> \"2010-03-30T05:43:25.1235000000Z\"\n    p t.round(5).iso8601(10)  #=> \"2010-03-30T05:43:25.1234600000Z\"\n    p t.round(6).iso8601(10)  #=> \"2010-03-30T05:43:25.1234570000Z\"\n    p t.round(7).iso8601(10)  #=> \"2010-03-30T05:43:25.1234568000Z\"\n    p t.round(8).iso8601(10)  #=> \"2010-03-30T05:43:25.1234567900Z\"\n    p t.round(9).iso8601(10)  #=> \"2010-03-30T05:43:25.1234567890Z\"\n    p t.round(10).iso8601(10) #=> \"2010-03-30T05:43:25.1234567890Z\"\n\n    t = Time.utc(1999,12,31, 23,59,59)\n    p((t + 0.4).round.iso8601(3))    #=> \"1999-12-31T23:59:59.000Z\"\n    p((t + 0.49).round.iso8601(3))   #=> \"1999-12-31T23:59:59.000Z\"\n    p((t + 0.5).round.iso8601(3))    #=> \"2000-01-01T00:00:00.000Z\"\n    p((t + 1.4).round.iso8601(3))    #=> \"2000-01-01T00:00:00.000Z\"\n    p((t + 1.49).round.iso8601(3))   #=> \"2000-01-01T00:00:00.000Z\"\n    p((t + 1.5).round.iso8601(3))    #=> \"2000-01-01T00:00:01.000Z\"\n\n    t = Time.utc(1999,12,31, 23,59,59)\n    p (t + 0.123456789).round(4).iso8601(6)  #=> \"1999-12-31T23:59:59.123500Z\"", "name": "usec", "namespace": "Time", "path": "Time#usec", "type": "instance_method", "visibility": "public"}, "Time#utc": {"description": "如果时间表示星期六，则返回+true+。n \n   t = Time.local(2006, 6, 10)      #=> 2006-06-10 00:00:00 -0500\n   t.saturday?                      #=> true", "name": "utc", "namespace": "Time", "path": "Time#utc", "type": "instance_method", "visibility": "public"}, "Time#utc?": {"description": "返回分钟的秒（0..60）作为时间。\\n \\n*注：*秒的范围从零到60，允许系统注入闰秒。更多详细信息，请参见http://en.wikipedia.org/wiki/leap_second。n \n   t = Time.now   #=> 2007-11-19 08:25:02 -0600\n   t.sec          #=> 2", "name": "utc?", "namespace": "Time", "path": "Time#utc?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Time#utc_offset": {"description": "根据给定格式字符串中的指令格式化时间。\\n \\n指令以百分比（%）字符开头。\\n未作为指令列出的任何文本都将传递给输出字符串。\\n \\n指令由百分比（%）字符、零个或多个标志、可选最小字段宽度、可选修饰符和转换说明符组成，如下所示：\\n \n  %<flags><width><modifier><conversion>\n \\n标志：\n  -  don't pad a numerical output\n  _  use spaces for padding\n  0  use zeros for padding\n  ^  upcase the result string\n  #  change case\n  :  use colons for %z\n \\n最小字段宽度指定最小宽度。\\n \\n修饰符是“e”和“o”。\\n它们被忽略。\\n \\n格式指令：\\n \n  Date (Year, Month, Day):\n    %Y - Year with century if provided, will pad result at least 4 digits.\n            -0001, 0000, 1995, 2009, 14292, etc.\n    %C - year / 100 (rounded down such as 20 in 2009)\n    %y - year % 100 (00..99)\n\n    %m - Month of the year, zero-padded (01..12)\n            %_m  blank-padded ( 1..12)\n            %-m  no-padded (1..12)\n    %B - The full month name (``January'')\n            %^B  uppercased (``JANUARY'')\n    %b - The abbreviated month name (``Jan'')\n            %^b  uppercased (``JAN'')\n    %h - Equivalent to %b\n\n    %d - Day of the month, zero-padded (01..31)\n            %-d  no-padded (1..31)\n    %e - Day of the month, blank-padded ( 1..31)\n\n    %j - Day of the year (001..366)\n\n  Time (Hour, Minute, Second, Subsecond):\n    %H - Hour of the day, 24-hour clock, zero-padded (00..23)\n    %k - Hour of the day, 24-hour clock, blank-padded ( 0..23)\n    %I - Hour of the day, 12-hour clock, zero-padded (01..12)\n    %l - Hour of the day, 12-hour clock, blank-padded ( 1..12)\n    %P - Meridian indicator, lowercase (``am'' or ``pm'')\n    %p - Meridian indicator, uppercase (``AM'' or ``PM'')\n\n    %M - Minute of the hour (00..59)\n\n    %S - Second of the minute (00..60)\n\n    %L - Millisecond of the second (000..999)\n         The digits under millisecond are truncated to not produce 1000.\n    %N - Fractional seconds digits, default is 9 digits (nanosecond)\n            %3N  millisecond (3 digits)\n            %6N  microsecond (6 digits)\n            %9N  nanosecond (9 digits)\n            %12N picosecond (12 digits)\n            %15N femtosecond (15 digits)\n            %18N attosecond (18 digits)\n            %21N zeptosecond (21 digits)\n            %24N yoctosecond (24 digits)\n         The digits under the specified length are truncated to avoid\n         carry up.\n\n  Time zone:\n    %z - Time zone as hour and minute offset from UTC (e.g. +0900)\n            %:z - hour and minute offset from UTC with a colon (e.g. +09:00)\n            %::z - hour, minute and second offset from UTC (e.g. +09:00:00)\n    %Z - Abbreviated time zone name or similar information.  (OS dependent)\n\n  Weekday:\n    %A - The full weekday name (``Sunday'')\n            %^A  uppercased (``SUNDAY'')\n    %a - The abbreviated name (``Sun'')\n            %^a  uppercased (``SUN'')\n    %u - Day of the week (Monday is 1, 1..7)\n    %w - Day of the week (Sunday is 0, 0..6)\n\n  ISO 8601 week-based year and week number:\n  The first week of YYYY starts with a Monday and includes YYYY-01-04.\n  The days in the year before the first week are in the last week of\n  the previous year.\n    %G - The week-based year\n    %g - The last 2 digits of the week-based year (00..99)\n    %V - Week number of the week-based year (01..53)\n\n  ISO 8601 week-based year and week number:\n  The first week of YYYY starts with a Monday and includes YYYY-01-04.\n  The days in the year before the first week are in the last week of\n  the previous year.\n    %G - The week-based year\n    %g - The last 2 digits of the week-based year (00..99)\n    %V - Week number of the week-based year (01..53)\n\n  Week number:\n  The first week of YYYY that starts with a Sunday or Monday (according to %U\n  or %W). The days in the year before the first week are in week 0.\n    %U - Week number of the year. The week starts with Sunday. (00..53)\n    %W - Week number of the year. The week starts with Monday. (00..53)\n\n  Seconds since the Epoch:\n    %s - Number of seconds since 1970-01-01 00:00:00 UTC.\n\n  Literal string:\n    %n - Newline character (\\n)\n    %t - Tab character (\\t)\n    %% - Literal ``%'' character\n\n  Combination:\n    %c - date and time (%a %b %e %T %Y)\n    %D - Date (%m/%d/%y)\n    %F - The ISO 8601 date format (%Y-%m-%d)\n    %v - VMS date (%e-%^b-%4Y)\n    %x - Same as %D\n    %X - Same as %T\n    %r - 12-hour time (%I:%M:%S %p)\n    %R - 24-hour time (%H:%M)\n    %T - 24-hour time (%H:%M:%S)\n \\n此方法类似于ISO C和POSIX中定义的strftime（）函数。\\n \\n由于Ruby1.9，虽然所有指令都与区域设置无关，但%z依赖于平台。\\n因此，即使在其他系统（如C）中使用相同的格式字符串，结果也可能不同。\\n\\n建议在%z上使用%z。\\n%z不标识时区。\\n例如，在美国/芝加哥（-06:00）、美国/哈瓦那（-05:00）、亚洲/哈尔滨（+08:00）、澳大利亚/达尔文（+09:30）和澳大利亚/阿德莱德（+10:30）使用“cst”。\\n另外，%z高度依赖于操作系统。\\n例如，它可能会在日语窗口上生成非ASCII字符串。\\n也就是说，结果可能与“jst”不同。\\n因此，建议使用数字时区偏移量%z。\\n \\n示例：\\n \n  t = Time.new(2007,11,19,8,37,48,\"-06:00\") #=> 2007-11-19 08:37:48 -0600\n  t.strftime(\"Printed on %m/%d/%Y\")   #=> \"Printed on 11/19/2007\"\n  t.strftime(\"at %I:%M%p\")            #=> \"at 08:37AM\"\n \\n各种ISO 8601格式：\n  %Y%m%d           => 20071119                  Calendar date (basic)\n  %F               => 2007-11-19                Calendar date (extended)\n  %Y-%m            => 2007-11                   Calendar date, reduced accuracy, specific month\n  %Y               => 2007                      Calendar date, reduced accuracy, specific year\n  %C               => 20                        Calendar date, reduced accuracy, specific century\n  %Y%j             => 2007323                   Ordinal date (basic)\n  %Y-%j            => 2007-323                  Ordinal date (extended)\n  %GW%V%u          => 2007W471                  Week date (basic)\n  %G-W%V-%u        => 2007-W47-1                Week date (extended)\n  %GW%V            => 2007W47                   Week date, reduced accuracy, specific week (basic)\n  %G-W%V           => 2007-W47                  Week date, reduced accuracy, specific week (extended)\n  %H%M%S           => 083748                    Local time (basic)\n  %T               => 08:37:48                  Local time (extended)\n  %H%M             => 0837                      Local time, reduced accuracy, specific minute (basic)\n  %H:%M            => 08:37                     Local time, reduced accuracy, specific minute (extended)\n  %H               => 08                        Local time, reduced accuracy, specific hour\n  %H%M%S,%L        => 083748,000                Local time with decimal fraction, comma as decimal sign (basic)\n  %T,%L            => 08:37:48,000              Local time with decimal fraction, comma as decimal sign (extended)\n  %H%M%S.%L        => 083748.000                Local time with decimal fraction, full stop as decimal sign (basic)\n  %T.%L            => 08:37:48.000              Local time with decimal fraction, full stop as decimal sign (extended)\n  %H%M%S%z         => 083748-0600               Local time and the difference from UTC (basic)\n  %T%:z            => 08:37:48-06:00            Local time and the difference from UTC (extended)\n  %Y%m%dT%H%M%S%z  => 20071119T083748-0600      Date and time of day for calendar date (basic)\n  %FT%T%:z         => 2007-11-19T08:37:48-06:00 Date and time of day for calendar date (extended)\n  %Y%jT%H%M%S%z    => 2007323T083748-0600       Date and time of day for ordinal date (basic)\n  %Y-%jT%T%:z      => 2007-323T08:37:48-06:00   Date and time of day for ordinal date (extended)\n  %GW%V%uT%H%M%S%z => 2007W471T083748-0600      Date and time of day for week date (basic)\n  %G-W%V-%uT%T%:z  => 2007-W47-1T08:37:48-06:00 Date and time of day for week date (extended)\n  %Y%m%dT%H%M      => 20071119T0837             Calendar date and local time (basic)\n  %FT%R            => 2007-11-19T08:37          Calendar date and local time (extended)\n  %Y%jT%H%MZ       => 2007323T0837Z             Ordinal date and UTC of day (basic)\n  %Y-%jT%RZ        => 2007-323T08:37Z           Ordinal date and UTC of day (extended)\n  %GW%V%uT%H%M%z   => 2007W471T0837-0600        Week date and local time and difference from UTC (basic)\n%g-w%v-%ut%r%：z=>2007-W47-1T08:37-06:00星期日期和本地时间以及与UTC的差异（扩展）", "name": "utc_offset", "namespace": "Time", "path": "Time#utc_offset", "type": "instance_method", "visibility": "public"}, "Time#wday": {"description": "返回时间分数。\\n \\n返回值可以是有理数。\\n \n   t = Time.now        #=> 2009-03-26 22:33:12 +0900\n   \"%10.9f\" % t.to_f   #=> \"1238074392.940563917\"\n   t.subsec            #=> (94056401/\n   ary = [1, \"two\", 3.0] #=> [1, \"two\", 3.0]\n00)\n \\n由于IEEE 754 double的精度不足以表示有理数，因此到f和subsec的最低位数是不同的。\\n \\n更准确的值由subsc返回。", "name": "wday", "namespace": "Time", "path": "Time#wday", "type": "instance_method", "visibility": "public"}, "Time#wednesday?": {"description": "如果时间表示星期日，则返回+true+。\\n \n   t = Time.local(1990, 4, 1)       #=> 1990-04-01 00:00:00 -0600\n   t.sunday?                        #=> true", "name": "wednesday?", "namespace": "Time", "path": "Time#wednesday?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "Time#yday": {"description": "如果时间表示星期四，则返回+true+。\\n \n   t = Time.local(1995, 12, 21)     #=> 1995-12-21 00:00:00 -0600\n   p t.thursday?                    #=> true", "name": "yday", "namespace": "Time", "path": "Time#yday", "type": "instance_method", "visibility": "public"}, "Time#year": {"description": "返回值的十元素数组，时间为\\n \n   [sec, min, hour, day, month, year, wday, yday, isdst, zone]\n \\n有关每个值的有效范围的说明，请参阅各个方法。这十个元素可以直接传递给time:：utc或time:：local以创建新的时间对象。\\n \n   t = Time.now     #=> 2007-11-19 08:36:01 -0600\n   now = t.to_a     #=> [1, 36, 8, 19, 11, 2007, 1, 323, false, \"CST\"]", "name": "year", "namespace": "Time", "path": "Time#year", "type": "instance_method", "visibility": "public"}, "Time#zone": {"description": "以浮点形式返回时间值（从纪元开始的秒数）。\\n \n   t = Time.now\n   \"%10.5f\" % t.to_f   #=> \"1270968744.77658\"\n   t.to_i              #=> 1270968744\n \\n请注意，IEEE 754 double的精度不足以表示自该纪元以来的纳秒数。", "name": "zone", "namespace": "Time", "path": "Time#zone", "type": "instance_method", "visibility": "public"}, "Time.at": {"description": "返回时间值，该值为自epoch以来的整数秒数。\\n \n   t = Time.now\n   \"%10.5f\" % t.to_f   #=> \"1270968656.89607\"\n   t.to_i              #=> 1270968656", "name": "at", "namespace": "Time", "path": "Time.at", "type": "class_method", "visibility": "public"}, "Time.gm": {"description": "返回时间值，该值为自epoch以来的整数秒数。\\n \n   t = Time.now\n   \"%10.5f\" % t.to_f   #=> \"1270968656.89607\"\n   t.to_i              #=> 1270968656", "name": "gm", "namespace": "Time", "path": "Time.gm", "type": "class_method", "visibility": "public"}, "Time.local": {"description": "如果时间表示星期二，则返回+true+。\\n \n   t = Time.local(1991, 2, 19)      #=> 1991-02-19 00:00:00 -0600\n   p t.tuesday?                     #=> true", "name": "local", "namespace": "Time", "path": "Time.local", "type": "class_method", "visibility": "public"}, "Time.mktime": {"description": "如果时间表示星期二，则返回+true+。\\n \n   t = Time.local(1991, 2, 19)      #=> 1991-02-19 00:00:00 -0600\n   p t.tuesday?                     #=> true", "name": "mktime", "namespace": "Time", "path": "Time.mktime", "type": "class_method", "visibility": "public"}, "Time.now": {"description": "返回时间的纳秒数。\\n \n   t = Time.now        #=> 2007-11-17 15:18:03 +0900\n   \"%10.9f\" % t.to_f   #=> \"1195280283.536151409\"\n   t.nsec              #=> 536151406\n \\n从到f和nsec的最低位数不同，因为IEEE 754 double的精度不足以表示自该纪元以来的精确纳秒数。\\n \\n更准确的值由nsec返回。", "name": "now", "namespace": "Time", "path": "Time.now", "type": "class_method", "visibility": "public"}, "Time.utc": {"description": "返回时间值，该值为自epoch以来的整数秒数。\\n \n   t = Time.now\n   \"%10.5f\" % t.to_f   #=> \"1270968656.89607\"\n   t.to_i              #=> 1270968656", "name": "utc", "namespace": "Time", "path": "Time.utc", "type": "class_method", "visibility": "public"}, "RubyVM": {"description": "", "name": "RubyVM", "namespace": "", "path": "RubyVM", "type": "class", "visibility": "public"}, "RubyVM.NSDR": {"description": ":nodoc:", "name": "NSDR", "namespace": "RubyVM", "path": "RubyVM.NSDR", "type": "class_method", "visibility": "public"}, "RubyVM.SDR": {"description": ":nodoc:", "name": "SDR", "namespace": "RubyVM", "path": "RubyVM.SDR", "type": "class_method", "visibility": "public"}, "RubyVM.USAGE_ANALYSIS_INSN_STOP": {"description": "", "name": "USAGE_ANALYSIS_INSN_STOP", "namespace": "RubyVM", "path": "RubyVM.USAGE_ANALYSIS_INSN_STOP", "type": "class_method", "visibility": "public"}, "RubyVM.USAGE_ANALYSIS_OPERAND_STOP": {"description": "", "name": "USAGE_ANALYSIS_OPERAND_STOP", "namespace": "RubyVM", "path": "RubyVM.USAGE_ANALYSIS_OPERAND_STOP", "type": "class_method", "visibility": "public"}, "RubyVM.USAGE_ANALYSIS_REGISTER_STOP": {"description": "", "name": "USAGE_ANALYSIS_REGISTER_STOP", "namespace": "RubyVM", "path": "RubyVM.USAGE_ANALYSIS_REGISTER_STOP", "type": "class_method", "visibility": "public"}, "RubyVM.stat": {"description": "返回时间的微秒数。\\n \n   t = Time.now        #=> 2007-11-19 08:03:26 -0600\n   \"%10.6f\" % t.to_f   #=> \"1195481006.775195\"\n   t.usec              #=> 775195", "name": "stat", "namespace": "RubyVM", "path": "RubyVM.stat", "type": "class_method", "visibility": "public"}, "RubyVM::DEFAULT_PARAMS": {"description": "返回时间的微秒数。\\n \n   t = Time.now        #=> 2007-11-19 08:03:26 -0600\n   \"%10.6f\" % t.to_f   #=> \"1195481006.775195\"\n   t.usec              #=> 775195", "name": "DEFAULT_PARAMS", "namespace": "RubyVM", "path": "RubyVM::DEFAULT_PARAMS", "type": "constant", "return": ["Hash", ""], "visibility": "public"}, "RubyVM::INSTRUCTION_NAMES": {"description": "将时间转换为UTC（GMT），修改接收器。\\n \n   t = Time.now   #=> 2007-11-19 08:18:31 -0600\n   t.gmt?         #=> false\n   t.gmtime       #=> 2007-11-19 14:18:31 UTC\n   t.gmt?         #=> true\n\n   t = Time.now   #=> 2007-11-19 08:18:51 -0600\n   t.utc?         #=> false\n   t.utc          #=> 2007-11-19 14:18:51 UTC\n   t.utc?         #=> true", "name": "INSTRUCTION_NAMES", "namespace": "RubyVM", "path": "RubyVM::INSTRUCTION_NAMES", "type": "constant", "return": ["Array", ""], "visibility": "public"}, "RubyVM::InstructionSequence": {"description": "如果时间表示以UTC（GMT）表示的时间，则返回+true+。\\n \n   t = Time.now                        #=> 2007-11-19 08:15:23 -0600\n   t.utc?                              #=> false\n   t = Time.gm(2000,\"jan\",1,20,15,1)   #=> 2000-01-01 20:15:01 UTC\n   t.utc?                              #=> true\n\n   t = Time.now                        #=> 2007-11-19 08:16:03 -0600\n   t.gmt?                              #=> false\n   t = Time.gm(2000,1,1,20,15,1)       #=> 2000-01-01 20:15:01 UTC\n   t.gmt?                              #=> true", "name": "InstructionSequence", "namespace": "RubyVM", "path": "RubyVM::InstructionSequence", "type": "class", "visibility": "public"}, "RubyVM::InstructionSequence#absolute_path": {"description": "返回时区和UTC之间以秒为单位的偏移量。\\n \n   t = Time.gm(2000,1,1,20,15,1)   #=> 2000-01-01 20:15:01 UTC\n   t.gmt_offset                    #=> 0\n   l = t.getlocal                  #=> 2000-01-01 14:15:01 -0600\n   l.gmt_offset                    #=> -21600", "name": "absolute_path", "namespace": "RubyVM::InstructionSequence", "path": "RubyVM::InstructionSequence#absolute_path", "type": "instance_method", "visibility": "public"}, "RubyVM::InstructionSequence#base_label": {"description": "返回一个表示星期几的整数，0..6，其中星期日=0。\\n \n   t = Time.now   #=> 2007-11-20 02:35:35 -0600\n   t.wday         #=> 2\n   t.sunday?      #=> false\n   t.monday?      #=> false\n   t.tuesday?     #=> true\n   t.wednesday?   #=> false\n   t.thursday?    #=> false\n   t.friday?      #=> false\n   t.saturday?    #=> false", "name": "base_label", "namespace": "RubyVM::InstructionSequence", "path": "RubyVM::InstructionSequence#base_label", "type": "instance_method", "visibility": "public"}, "RubyVM::InstructionSequence#disasm": {"description": "返回一个整数，表示一年中的某一天，1..366。\\n \n   t = Time.now   #=> 2007-11-19 08:32:31 -0600\n   t.yday         #=> 323", "name": "disasm", "namespace": "RubyVM::InstructionSequence", "path": "RubyVM::InstructionSequence#disasm", "type": "instance_method", "visibility": "public"}, "RubyVM::InstructionSequence#disassemble": {"description": "返回一个整数，表示一年中的某一天，1..366。\\n \n   t = Time.now   #=> 2007-11-19 08:32:31 -0600\n   t.yday         #=> 323", "name": "disassemble", "namespace": "RubyVM::InstructionSequence", "path": "RubyVM::InstructionSequence#disassemble", "type": "instance_method", "visibility": "public"}, "RubyVM::InstructionSequence#each_child": {"description": "返回时间的年份（包括世纪）。\\n \n   t = Time.now   #=> 2007-11-19 08:27:51 -0600\n   t.year         #=> 2007", "name": "each_child", "namespace": "RubyVM::InstructionSequence", "path": "RubyVM::InstructionSequence#each_child", "type": "instance_method", "visibility": "public"}, "RubyVM::InstructionSequence#eval": {"description": "返回用于时间的时区的名称。从Ruby1.8开始，对于UTC时间返回“UTC”，而不是“GMT”。\\n \n   t = Time.gm(2000, \"jan\", 1, 20, 15, 1)\n   t.zone   #=> \"UTC\"\n   t = Time.local(2000, \"jan\", 1, 20, 15, 1)\n   t.zone   #=> \"CST\"", "name": "eval", "namespace": "RubyVM::InstructionSequence", "path": "RubyVM::InstructionSequence#eval", "type": "instance_method", "visibility": "public"}, "RubyVM::InstructionSequence#first_lineno": {"description": "创建一个新的时间对象，该对象的值为+time+、+seconds_with_frac+或+seconds+和+microseconds_with_frac+（从纪元开始）。\\n +seconds_with_frac+和+microseconds_with_frac+ \\n可以是整数、浮点、有理或其他数字。\\n在某些系统上，非可移植功能允许偏移量为负数。\\n \\n如果给定数值参数，则结果为本地时间。\\n \n   Time.at(0)                                #=> 1969-12-31 18:00:00 -0600\n   Time.at(Time.at(0))                       #=> 1969-12-31 18:00:00 -0600\n   Time.at(946702800)                        #=> 1999-12-31 23:00:00 -0600\n   Time.at(-284061600)                       #=> 1960-12-31 00:00:00 -0600\n   Time.at(946684800.2).usec                 #=> 200000\n   Time.at(946684800, 123456.789).nsec       #=> 123456789\n   Time.at(946684800, 123456789, :nsec).nsec  #=> 123456789", "name": "first_lineno", "namespace": "RubyVM::InstructionSequence", "path": "RubyVM::InstructionSequence#first_lineno", "type": "instance_method", "visibility": "public"}, "RubyVM::InstructionSequence#inspect": {"description": "基于给定值创建时间对象，解释为UTC（GMT）。必须指定年份。其他值默认为该字段的最小值（可以是+nil+或省略）。月份可以用1到12之间的数字或三个字母的英文月份名称来指定。小时在24小时时钟（0..23）上指定。如果任何值超出范围，则引发ArgumentError。还将接受时间到时间的顺序输出中的十个参数。\\n\\n +sec_with_frac+和+usec_with_frac+可以有小数部分。n \n   Time.utc(2000,\"jan\",1,20,15,1)  #=> 2000-01-01 20:15:01 UTC\n   Time.gm(2000,\"jan\",1,20,15,1)   #=> 2000-01-01 20:15:01 UTC", "name": "inspect", "namespace": "RubyVM::InstructionSequence", "path": "RubyVM::InstructionSequence#inspect", "type": "instance_method", "visibility": "public"}, "RubyVM::InstructionSequence#label": {"description": "与time:：gm相同，但解释本地时区中的值。\\n n    Time.local(2000,\"jan\",1,20,15,1)   #=> 2000-01-01 20:15:01 -0600", "name": "label", "namespace": "RubyVM::InstructionSequence", "path": "RubyVM::InstructionSequence#label", "type": "instance_method", "visibility": "public"}, "RubyVM::InstructionSequence#marshal_dump": {"description": "", "name": "marshal_dump", "namespace": "RubyVM::InstructionSequence", "path": "RubyVM::InstructionSequence#marshal_dump", "type": "instance_method", "visibility": "private"}, "RubyVM::InstructionSequence#marshal_load": {"description": "", "name": "marshal_load", "namespace": "RubyVM::InstructionSequence", "path": "RubyVM::InstructionSequence#marshal_load", "type": "instance_method", "visibility": "private"}, "RubyVM::InstructionSequence#path": {"description": "与time:：gm相同，但解释本地时区中的值。\\n n    Time.local(2000,\"jan\",1,20,15,1)   #=> 2000-01-01 20:15:01 -0600", "name": "path", "namespace": "RubyVM::InstructionSequence", "path": "RubyVM::InstructionSequence#path", "type": "instance_method", "visibility": "public"}, "RubyVM::InstructionSequence#to_a": {"description": "为当前时间创建新的时间对象。\\n这与Time.new相同，没有参数。\\n n    Time.now            #=> 2009-06-24 12:39:54 +0900", "name": "to_a", "namespace": "RubyVM::InstructionSequence", "path": "RubyVM::InstructionSequence#to_a", "type": "instance_method", "visibility": "public"}, "RubyVM::InstructionSequence#to_binary": {"description": "基于给定值创建时间对象，解释为UTC（GMT）。必须指定年份。其他值默认为该字段的最小值（可以是+nil+或省略）。月份可以用1到12之间的数字或三个字母的英文月份名称来指定。小时在24小时时钟（0..23）上指定。如果任何值超出范围，则引发ArgumentError。还将接受时间到时间的顺序输出中的十个参数。\\n\\n +sec_with_frac+和+usec_with_frac+可以有小数部分。n \n   Time.utc(2000,\"jan\",1,20,15,1)  #=> 2000-01-01 20:15:01 UTC\n   Time.gm(2000,\"jan\",1,20,15,1)   #=> 2000-01-01 20:15:01 UTC", "name": "to_binary", "namespace": "RubyVM::InstructionSequence", "path": "RubyVM::InstructionSequence#to_binary", "type": "instance_method", "visibility": "public"}, "RubyVM::InstructionSequence#trace_points": {"description": "返回一个哈希，该哈希包含VM内依赖于实现的计数器。\\n \\n此哈希包含有关方法/常量缓存序列的信息：\\n \n  {\n    :global_method_state=>251,\n    :global_constant_state=>481,\n    :class_serial=>9029\n  }\n \\n哈希的内容是特定于实现的，将来可能会更改。\\n \\n此方法只适用于C Ruby。", "name": "trace_points", "namespace": "RubyVM::InstructionSequence", "path": "RubyVM::InstructionSequence#trace_points", "type": "instance_method", "visibility": "public"}, "RubyVM::InstructionSequence.compile": {"description": "计算指令序列并返回结果。\\n n     RubyVM::InstructionSequence.compile(\"1 + 2\").eval #=> 3", "name": "compile", "namespace": "RubyVM::InstructionSequence", "path": "RubyVM::InstructionSequence.compile", "type": "class_method", "visibility": "public"}, "RubyVM::InstructionSequence.compile_file": {"description": "rubyvm：：指令名称", "name": "compile_file", "namespace": "RubyVM::InstructionSequence", "path": "RubyVM::InstructionSequence.compile_file", "type": "class_method", "visibility": "public"}, "RubyVM::InstructionSequence.compile_option": {"description": "InstructionSequence类表示Ruby虚拟机的已编译指令序列。\\n \\n使用它，您可以获得组成方法或过程的指令的句柄，将ruby代码字符串编译为vm指令，并将指令序列分解为字符串以便于检查。如果您想了解RubyVM是如何工作的，那么它非常有用，但是它还允许您控制RubyISEQ编译器的各种设置。\\n \\n您可以在ruby源代码的+insns.def+中找到VM指令的源代码。\\n \\n指令序列结果几乎肯定会随着Ruby的变化而变化，因此本文档中的示例输出可能与您看到的不同。", "name": "compile_option", "namespace": "RubyVM::InstructionSequence", "path": "RubyVM::InstructionSequence.compile_option", "type": "class_method", "visibility": "public"}, "RubyVM::InstructionSequence.compile_option=": {"description": "返回此指令序列的绝对路径。\\n \\n +nil+如果从字符串计算ISEQ。\\n \\n例如，使用：：compile_file:\\n \\n/tmp/method.rb def hello \\n将“hello，world”放在IRB中\\n end \\n \\n \\n>iseq=rubyvm:：InstructionSequence.compile_file（'/tmp/method.rb'）\\n > iseq.absolute_path #=> /tmp/method.rb", "name": "compile_option=", "namespace": "RubyVM::InstructionSequence", "path": "RubyVM::InstructionSequence.compile_option=", "type": "class_method", "visibility": "public"}, "RubyVM::InstructionSequence.disasm": {"description": "以可读形式返回指令序列+String+。\\n \n  puts RubyVM::InstructionSequence.compile('1 + 2').disasm\n \\n产生时间：\\n \n  == disasm: <RubyVM::InstructionSequence:<compiled>@<compiled>>==========\n  0000 trace            1                                               (   1)\n  0002 putobject        1\n  0004 putobject        2\n  0006 opt_plus         <ic:1>\n 0008离开", "name": "disasm", "namespace": "RubyVM::InstructionSequence", "path": "RubyVM::InstructionSequence.disasm", "type": "class_method", "visibility": "public"}, "RubyVM::InstructionSequence.disassemble": {"description": "以可读形式返回指令序列+String+。\\n \n  puts RubyVM::InstructionSequence.compile('1 + 2').disasm\n \\n产生时间：\\n \n  == disasm: <RubyVM::InstructionSequence:<compiled>@<compiled>>==========\n  0000 trace            1                                               (   1)\n  0002 putobject        1\n  0004 putobject        2\n  0006 opt_plus         <ic:1>\n 0008离开", "name": "disassemble", "namespace": "RubyVM::InstructionSequence", "path": "RubyVM::InstructionSequence.disassemble", "type": "class_method", "visibility": "public"}, "RubyVM::InstructionSequence.load": {"description": ":nodoc:", "name": "load", "namespace": "RubyVM::InstructionSequence", "path": "RubyVM::InstructionSequence.load", "type": "class_method", "visibility": "public"}, "RubyVM::InstructionSequence.load_from_binary": {"description": "以可读形式返回指令序列+String+。\\n \n  puts RubyVM::InstructionSequence.compile('1 + 2').disasm\n \\n产生时间：\\n \n  == disasm: <RubyVM::InstructionSequence:<compiled>@<compiled>>==========\n  0000 trace            1                                               (   1)\n  0002 putobject        1\n  0004 putobject        2\n  0006 opt_plus         <ic:1>\n 0008离开", "name": "load_from_binary", "namespace": "RubyVM::InstructionSequence", "path": "RubyVM::InstructionSequence.load_from_binary", "type": "class_method", "visibility": "public"}, "RubyVM::InstructionSequence.load_from_binary_extra_data": {"description": "迭代所有直接子指令序列。\\n迭代顺序是定义的实现/版本，因此人们不应依赖于该顺序。", "name": "load_from_binary_extra_data", "namespace": "RubyVM::InstructionSequence", "path": "RubyVM::InstructionSequence.load_from_binary_extra_data", "type": "class_method", "visibility": "public"}, "RubyVM::InstructionSequence.new": {"description": "计算指令序列并返回结果。\\n n     RubyVM::InstructionSequence.compile(\"1 + 2\").eval #=> 3", "name": "new", "namespace": "RubyVM::InstructionSequence", "path": "RubyVM::InstructionSequence.new", "type": "class_method", "visibility": "public"}, "RubyVM::InstructionSequence.of": {"description": "返回从中加载指令序列的第一个源行的编号。\\n \\n例如，使用irb:\\n \\n iseq=rubyvm:：InstructionSequence.compile（'num=1+2'）\\n #=> <RubyVM::InstructionSequence:<compiled>@<compiled>> \\n iseq.first_lineno \\n #=> 1", "name": "of", "namespace": "RubyVM::InstructionSequence", "path": "RubyVM::InstructionSequence.of", "type": "class_method", "visibility": "public"}, "RubyVM::OPTS": {"description": "返回此指令序列的可读字符串表示形式，包括标签和路径。", "name": "OPTS", "namespace": "RubyVM", "path": "RubyVM::OPTS", "type": "constant", "return": ["Array", ""], "visibility": "public"}, "UncaughtThrowError": {"description": "返回此指令序列的路径。\\n \\n <code><compiled></code>，如果从字符串计算ISEQ。\\n \\n例如，使用irb:\\n \\n iseq=rubyvm:：InstructionSequence.compile（'num=1+2'）\\n #=> <RubyVM::InstructionSequence:<compiled>@<compiled>> \\n iseq.path \\n #=> \"<compiled>\" \\n \\n using：：compile_file:\\n \\n/tmp/method.rb def hello \\n将“hello，world”置于irb中\\n end \\n \\n n>iseq=rubyvm:：InstructionSequence.compile_file（'/tmp/method.rb'）\\n > iseq.path #=> /tmp/method.rb", "name": "UncaughtThrowError", "namespace": "", "path": "UncaughtThrowError", "type": "class", "visibility": "public"}, "UncaughtThrowError#initialize": {"description": "返回此指令序列的路径。\\n \\n <code><compiled></code>，如果从字符串计算ISEQ。\\n \\n例如，使用irb:\\n \\n iseq=rubyvm:：InstructionSequence.compile（'num=1+2'）\\n #=> <RubyVM::InstructionSequence:<compiled>@<compiled>> \\n iseq.path \\n #=> \"<compiled>\" \\n \\n using：：compile_file:\\n \\n/tmp/method.rb def hello \\n将“hello，world”置于irb中\\n end \\n \\n n>iseq=rubyvm:：InstructionSequence.compile_file（'/tmp/method.rb'）\\n > iseq.path #=> /tmp/method.rb", "name": "initialize", "namespace": "UncaughtThrowError", "path": "UncaughtThrowError#initialize", "type": "instance_method", "visibility": "public"}, "UncaughtThrowError#tag": {"description": "返回包含14个元素的数组，这些元素表示具有以下数据的指令序列：\\n\\n[magic]\n  A string identifying the data format. <b>Always\n  +YARVInstructionSequence/SimpleDataFormat+.</b>\n\\n[major\\u version]\n  The major version of the instruction sequence.\n\\n[minor\\u version]\n  The minor version of the instruction sequence.\n\\n[format\\u type]\n  A number identifying the data format. <b>Always 1</b>.\n\\n[misc]\n  A hash containing:\n\n  [+:arg_size+]\n方法或块所采用的参数总数（如果iseq不表示方法或块，则为0）\n  [+:local_size+]\n局部变量+1\n  [+:stack_max+]\n用于计算抛出SystemStackError的堆栈深度。\\n \\n[label]\n  The name of the context (block, method, class, module, etc.) that this\n  instruction sequence belongs to.\n\n  <code><main></code> if it's at the top level, <code><compiled></code> if\n  it was evaluated from a string.\n \\n[path]\n  The relative path to the Ruby file where the instruction sequence was\n  loaded from.\n\n  <code><compiled></code> if the iseq was evaluated from a string.\n \\n[absolute诳path]\n  The absolute path to the Ruby file where the instruction sequence was\n  loaded from.\n\n  +nil+ if the iseq was evaluated from a string.\n \\n[诳first诳lineno]\n  The number of the first source line where the instruction sequence was\n  loaded from.\n \\n[类型]\n  The type of the instruction sequence.\n\n  Valid values are +:top+, +:method+, +:block+, +:class+, +:rescue+,\n  +:ensure+, +:eval+, +:main+, and +:defined_guard+.\n \\n[本地变量]\n  An array containing the names of all arguments and local variables as\n  symbols.\n \\n[参数]\n  An Hash object containing parameter information.\n\n  More info about these values can be found in +vm_core.h+.\n \\n[catch_table]\n  A list of exceptions and control flow operators (rescue, next, redo,\n  break, etc.).\n \\n[字节码]\n  An array of arrays containing the instruction names and operands that\n  make up the body of the instruction sequence.\n \\n请注意，此格式特定于MRI，且与版本相关。", "name": "tag", "namespace": "UncaughtThrowError", "path": "UncaughtThrowError#tag", "type": "instance_method", "visibility": "public"}, "UncaughtThrowError#to_s": {"description": "将序列化的ISEQ二进制格式数据作为字符串对象返回。\\n相应的ISEQ对象由rubyvm:：InstructionSequence创建。从\\u binary（）方法加载\\u。\\n \\n字符串extra_data将与二进制数据一起保存。\\n您可以使用rubyvm:：InstructionSequence访问此数据。从\\u binary \\u extra \\u数据（binary）加载\\u。\\n \\n请注意，转换后的二进制数据不可移植。\\n不能将此二进制数据移动到其他计算机。\\n不能使用由Ruby的另一个版本/另一个体系结构创建的二进制数据。", "name": "to_s", "namespace": "UncaughtThrowError", "path": "UncaughtThrowError#to_s", "type": "instance_method", "visibility": "public"}, "UncaughtThrowError#value": {"description": "返回指令序列中的跟踪点。\\n返回一个[line，event_symbol]对数组。", "name": "value", "namespace": "UncaughtThrowError", "path": "UncaughtThrowError#value", "type": "instance_method", "visibility": "public"}, "TracePoint": {"description": "获取+source+，一个Ruby代码字符串，并将其编译为\\n InstructionSequence。\\n \\n可选选取+file+、+path+和+line+，它们描述+source+中作为元数据附加到返回的+iseq+的Ruby代码的文件名、绝对路径和第一个行号。\\n \\n +options+（可以是+true+、+false+或+Hash+）用于修改Ruby ISEQ编译器的默认行为。\\n \\n有关有效编译选项的详细信息，请参阅：：compile_option=。n \n   RubyVM::InstructionSequence.compile(\"a = 1 + 2\")\n   #=> <RubyVM::InstructionSequence:<compiled>@<compiled>>", "name": "TracePoint", "namespace": "", "path": "TracePoint", "type": "class", "visibility": "public"}, "TracePoint#binding": {"description": "获取+file+，一个包含Ruby源文件位置的字符串，读取、分析和编译该文件，并返回+iseq+，即使用源位置元数据集编译的InstructionSequence。\\n \\n可选地使用+options+（可以是+true+、+false+或+Hash+）来修改Ruby ISEQ编译器的默认行为。\\n \\n有关有效编译选项的详细信息，请参阅：：compile_option=。n \n    # /tmp/hello.rb\n    puts \"Hello, world!\"\n\n    # elsewhere\n    RubyVM::InstructionSequence.compile_file(\"/tmp/hello.rb\")\n    #=> <RubyVM::InstructionSequence:<main>@/tmp/hello.rb>", "name": "binding", "namespace": "TracePoint", "path": "TracePoint#binding", "type": "instance_method", "visibility": "public"}, "TracePoint#callee_id": {"description": "返回Ruby ISEQ编译器使用的默认选项的哈希值。\\n \\n有关详细信息，请参阅InstructionSequence。编译_选项=。", "name": "callee_id", "namespace": "TracePoint", "path": "TracePoint#callee_id", "type": "instance_method", "visibility": "public"}, "TracePoint#defined_class": {"description": "在RubyISEQ编译器中设置各种优化的默认值。\\n \\n +options+的可能值包括+true+（启用所有选项）、+false+（禁用所有选项）和+nil+（保留所有选项不变）。\\n \\n您还可以传递+options+中要更改的+Hash+，哈希中不存在的任何选项都将保持不变。\\n \\n可以设置为+true+或+false+的可能选项名（+options+中的键）包括：\\n \\n*+：inline \\u const \\u cache+\\n*+：指令\\u universion+\\n*+：操作数\\u universion+\\n*+：窥视孔\\u优化+\\n*+：专用的\\u指令+\\n*+：堆栈\\u缓存+\\n*+：tailcall \\u优化+\\n \\n另外，+：调试级别+c设为整数。\\n \\n通过将上述任何值作为+options+参数传递给\\n：：new、：：compile和：：compile_文件，可以为一次ISEQ编译器运行覆盖这些默认选项。", "name": "defined_class", "namespace": "TracePoint", "path": "TracePoint#defined_class", "type": "instance_method", "visibility": "public"}, "TracePoint#disable": {"description": "获取+body+，一个方法或proc对象，并返回一个字符串，其中包含+body+的可读指令。\\n \\n对于method对象：\\n \n  # /tmp/method.rb\n  def hello\n    puts \"hello, world\"\n  end\n\n  puts RubyVM::InstructionSequence.disasm(method(:hello))\n \\n products:\\n \n  == disasm: <RubyVM::InstructionSequence:hello@/tmp/method.rb>============\n  0000 trace            8                                               (   1)\n  0002 trace            1                                               (   2)\n  0004 putself\n  0005 putstring        \"hello, world\"\n  0007 send             :puts, 1, nil, 8, <ic:0>\n  0013 trace            16                                              (   3)\n  0015 leave                                                            (   2)\n \\n for a proc:\\n \n  # /tmp/proc.rb\n  p = proc { num = 1 + 2 }\n  puts RubyVM::InstructionSequence.disasm(p)\n \\n products:\\n \n  == disasm: <RubyVM::InstructionSequence:block in <main>@/tmp/proc.rb>===\n  == catch table\n  | catch type: redo   st: 0000 ed: 0012 sp: 0000 cont: 0000\n  | catch type: next   st: 0000 ed: 0012 sp: 0000 cont: 0012\n  |------------------------------------------------------------------------\n  local table (size: 2, argc: 0 [opts: 0, rest: -1, post: 0, block: -1] s1)\n  [ 2] num\n  0000 trace            1                                               (   1)\n  0002 putobject        1\n  0004 putobject        2\n  0006 opt_plus         <ic:1>\n  0008 dup\n  0009 setlocal         num, 0\n 0012 leave", "name": "disable", "namespace": "TracePoint", "path": "TracePoint#disable", "type": "instance_method", "visibility": "public"}, "TracePoint#enable": {"description": "获取+body+，一个方法或proc对象，并返回一个字符串，其中包含+body+的可读指令。\\n \\n对于method对象：\\n \n  # /tmp/method.rb\n  def hello\n    puts \"hello, world\"\n  end\n\n  puts RubyVM::InstructionSequence.disasm(method(:hello))\n \\n products:\\n \n  == disasm: <RubyVM::InstructionSequence:hello@/tmp/method.rb>============\n  0000 trace            8                                               (   1)\n  0002 trace            1                                               (   2)\n  0004 putself\n  0005 putstring        \"hello, world\"\n  0007 send             :puts, 1, nil, 8, <ic:0>\n  0013 trace            16                                              (   3)\n  0015 leave                                                            (   2)\n \\n for a proc:\\n \n  # /tmp/proc.rb\n  p = proc { num = 1 + 2 }\n  puts RubyVM::InstructionSequence.disasm(p)\n \\n products:\\n \n  == disasm: <RubyVM::InstructionSequence:block in <main>@/tmp/proc.rb>===\n  == catch table\n  | catch type: redo   st: 0000 ed: 0012 sp: 0000 cont: 0000\n  | catch type: next   st: 0000 ed: 0012 sp: 0000 cont: 0012\n  |------------------------------------------------------------------------\n  local table (size: 2, argc: 0 [opts: 0, rest: -1, post: 0, block: -1] s1)\n  [ 2] num\n  0000 trace            1                                               (   1)\n  0002 putobject        1\n  0004 putobject        2\n  0006 opt_plus         <ic:1>\n  0008 dup\n  0009 setlocal         num, 0\n 0012 leave", "name": "enable", "namespace": "TracePoint", "path": "TracePoint#enable", "type": "instance_method", "visibility": "public"}, "TracePoint#enabled?": {"description": "从rubyvm:：InstructionSequence创建的二进制格式字符串对象加载ISEQ对象到\\u binary。\\n \\n此加载程序没有验证程序，因此加载中断/修改的二进制文件会导致严重问题。\\n \\n不应加载其他人提供的二进制数据。\\n您应该使用自己翻译的二进制数据。", "name": "enabled?", "namespace": "TracePoint", "path": "TracePoint#enabled?", "type": "instance_method", "visibility": "public", "return": [["Boolean"], ""]}, "TracePoint#event": {"description": "加载嵌入到二进制格式字符串对象中的额外数据。", "name": "event", "namespace": "TracePoint", "path": "TracePoint#event", "type": "instance_method", "visibility": "public"}, "TracePoint#inspect": {"description": "获取+source+，一个Ruby代码字符串，并将其编译为\\n InstructionSequence。\\n \\n可选选取+file+、+path+和+line+，它们描述+source+中作为元数据附加到返回的+iseq+的Ruby代码的文件名、绝对路径和第一行编号。\\n \\n +options+（可以是+true+、+false+或+Hash+）用于修改Ruby ISEQ编译器的默认行为。\\n \\n有关有效编译选项的详细信息，请参阅：：compile_option=。n \n   RubyVM::InstructionSequence.compile(\"a = 1 + 2\")\n   #=> <RubyVM::InstructionSequence:<compiled>@<compiled>>", "name": "inspect", "namespace": "TracePoint", "path": "TracePoint#inspect", "type": "instance_method", "visibility": "public"}, "TracePoint#lineno": {"description": "返回包含给定过程或方法的指令序列。\\n \\n例如，使用irb:\\n \\n 35; a proc \\n>p=proc num=1+2 \\n>rubyvm:：InstructionSequence.of（p \\n > #=> <RubyVM::InstructionSequence:block in irb_binding@(irb)> \\n \\n 35;表示方法\\n>def foo（bar）；puts bar; end \\n>rubyvm:：InstructionSequence.of（meth法（：foo））\\n > #=> <RubyVM::InstructionSequence:foo@(irb)> \\n \\n \\n使用：：编译\\u文件\\n \\n \\n \\n \\/tmp/iseq/iseq-of.rb def def def hello.rb def def def hello世界\\n结束\\n \\n$A全局\\u proc=proc str='a'+'b'\\n \\n在irb中\\n>需要.rb的/tmp/iseq_'\\n \\n首先是方法hello \\n>rubyvm:：InstructionSequence.of（method（：hello））\\n > #=> #<RubyVM::InstructionSequence:0x007fb73d7cb1d0> \\n \\n然后是全局过程\\n>rubyvm:：InstructionSequence.（$a覕global_proc）\\n > #=> #<RubyVM::InstructionSequence:0x007fb73d7caf78>", "name": "lineno", "namespace": "TracePoint", "path": "TracePoint#lineno", "type": "instance_method", "visibility": "public"}, "TracePoint#method_id": {"description": "rubyvm:：OPTS，显示vm构建选项", "name": "method_id", "namespace": "TracePoint", "path": "TracePoint#method_id", "type": "instance_method", "visibility": "public"}, "TracePoint#path": {"description": "使用没有相应+catch+块的标记调用+throw+时引发。\\n \n   throw \"foo\", \"bar\"\n \\n<em>引发异常：</em>\\n\\n UncaughtThrowError:uncaught throw“foo”", "name": "path", "namespace": "TracePoint", "path": "TracePoint#path", "type": "instance_method", "visibility": "public"}, "TracePoint#raised_exception": {"description": "使用没有相应+catch+块的标记调用+throw+时引发。\\n \n   throw \"foo\", \"bar\"\n \\n<em>引发异常：</em>\\n\\n UncaughtThrowError:uncaught throw“foo”", "name": "raised_exception", "namespace": "TracePoint", "path": "TracePoint#raised_exception", "type": "instance_method", "visibility": "public"}, "TracePoint#return_value": {"description": "返回所调用的标记对象。", "name": "return_value", "namespace": "TracePoint", "path": "TracePoint#return_value", "type": "instance_method", "visibility": "public"}, "TracePoint#self": {"description": "返回带已检查标记的格式化消息。", "name": "self", "namespace": "TracePoint", "path": "TracePoint#self", "type": "instance_method", "visibility": "public"}, "TracePoint.new": {"description": "返回调用的返回值。", "name": "new", "namespace": "TracePoint", "path": "TracePoint.new", "type": "class_method", "visibility": "public"}, "TracePoint.stat": {"description": "一个类，它在一个良好的面向对象的API中提供内核的功能。\\n \\n==example \\n \\n我们可以使用TracePoint专门收集异常的信息：\\n \n    trace = TracePoint.new(:raise) do |tp|\n p[t p.lineno，t p.event，t p.raired_exception]\n    end\n    #=> #<TracePoint:disabled>\n\n    trace.enable\n    #=> false\n\n    0 / 0\n    #=> [5, :raise, #<ZeroDivisionError: divided by 0>]\n \\n==events \\n \\n如果不指定要侦听的事件类型，TracePoint将包括所有可用的事件。\\n \\n注意：不依赖于当前事件集，因为此列表可能会更改。相反，建议您指定要使用的事件类型。\\n \\n要筛选跟踪的内容，可以将以下任意一项作为+事件+：\\n \\n+：行+：：在新行上执行代码\\n+：类+：：启动类或模块定义\\n+：结束+：：完成类或模块定义\\n+：调用+：：调用Ruby方法\\n+：返回+：：从Ruby方法返回\\n+：c_调用+：：调用C语言例程\\n+：c_返回+：：从C语言例程返回\\n+：raise+：：引发异常\\n+：b_call+：：块条目处的事件挂钩\\n+：b_return+：：块结束处的事件挂钩\\n+：线程_begin+：：线程开始处的事件挂钩\\n+：线程_end+：：线程结束处的事件挂钩\\n+：光纤_switch+：：光纤交换机处的事件挂钩", "name": "stat", "namespace": "TracePoint", "path": "TracePoint.stat", "type": "class_method", "visibility": "public"}, "TracePoint.trace": {"description": "从事件返回生成的绑定对象", "name": "trace", "namespace": "TracePoint", "path": "TracePoint.trace", "type": "class_method", "visibility": "public"}, "Math": {"description": "返回被调用方法的被调用名称", "name": "Math", "namespace": "", "path": "Math", "type": "class", "visibility": "public"}, "GC": {"description": "返回被调用方法的类或模块。\\n \\n class C; def foo; end；end \\n trace=TracePoint。new（：call）do tp \\n \t  p tp.defined_class #=> C \\n end.enable do \\n C.new.foo \\n end \\n \\n如果方法由模块定义，则返回该模块。\\n \\n module M; def foo; end；end \\n class C; include M; end；\\n trace=TracePoint.new（：call）do tp \\n \t  p tp.defined_class #=> M \\n end.enable do \\n C.new.foo \\n end \\n \\n \\n<b>note:</b>defined_class returns singleton class.\\n \\n kernel set_trace_func的第6个块参数传递由singleton类附加的原始类。\\n\\n<b>这是kernel set_trace_func和TracePoint之间的区别。</b>\\n \\n class C; def self.foo；end; end \\n trace=TracePoint。new（：call）do tp \\n \t  p tp.defined_class #=> #<Class:C> \\n end.enable do \\n C.foo \\n end", "name": "GC", "namespace": "", "path": "GC", "type": "module", "visibility": "public"}, "GC#garbage_collect": {"description": "正在运行的文件的路径", "name": "garbage_collect", "namespace": "GC", "path": "GC#garbage_collect", "type": "module_function", "visibility": "public"}, "GC.add_stress_to_class": {"description": "", "name": "add_stress_to_class", "namespace": "GC", "path": "GC.add_stress_to_class", "type": "module_function", "visibility": "public"}, "GC.count": {"description": "trace.enable->true或false trace.enable block->obj \\n \\n激活跟踪\\n \\n如果启用跟踪，则返回true。\\n如果跟踪被禁用，则返回false。\\n \\n trace.enabled?  #=> false \\n trace.enable    #=> false (previous state)\n                     #   trace is enabled\ntrace.enabled?  #=> true \\n trace.enable    #=> true (previous state)\n                     #   trace is still enabled\n \\n如果给定了块，跟踪将仅在块范围内启用。\\n \\n trace.enabled？\\n #=> false \\n \\n trace.enable do\n    trace.enabled?\n    # only enabled for this block\nend \\n \\n trace.enabled？\\n #=> false \\n \\n注意：您不能访问块内的事件挂钩。\\n \\n trace.enable P tp.lineno \\n #=> RuntimeError: access from outside", "name": "count", "namespace": "GC", "path": "GC.count", "type": "module_function", "visibility": "public"}, "GC.disable": {"description": "启用？->对或错\\n \\n跟踪的当前状态", "name": "disable", "namespace": "GC", "path": "GC.disable", "type": "module_function", "visibility": "public"}, "GC.enable": {"description": "事件类型\\n \\n有关详细信息，请参阅TracePoint@events。", "name": "enable", "namespace": "GC", "path": "GC.enable", "type": "module_function", "visibility": "public"}, "GC.latest_gc_info": {"description": "返回一个包含人类可读TracePoint状态的字符串。", "name": "latest_gc_info", "namespace": "GC", "path": "GC.latest_gc_info", "type": "module_function", "visibility": "public"}, "GC.malloc_allocated_size": {"description": "事件的行号", "name": "malloc_allocated_size", "namespace": "GC", "path": "GC.malloc_allocated_size", "type": "module_function", "visibility": "public"}, "GC.malloc_allocations": {"description": "返回被调用方法的定义处的名称", "name": "malloc_allocations", "namespace": "GC", "path": "GC.malloc_allocations", "type": "module_function", "visibility": "public"}, "GC.remove_stress_to_class": {"description": "", "name": "remove_stress_to_class", "namespace": "GC", "path": "GC.remove_stress_to_class", "type": "module_function", "visibility": "public"}, "GC.start": {"description": "正在运行的文件的路径", "name": "start", "namespace": "GC", "path": "GC.start", "type": "module_function", "visibility": "public"}, "GC.stat": {"description": "在+上引发异常的值：引发+事件", "name": "stat", "namespace": "GC", "path": "GC.stat", "type": "module_function", "visibility": "public"}, "GC.stress": {"description": "返回值来自+：返回+，+c_return+和+b_return+事件", "name": "stress", "namespace": "GC", "path": "GC.stress", "type": "module_function", "visibility": "public"}, "GC.stress=": {"description": "事件期间返回跟踪对象\\n \\n与TracePoint binding:\\n trace.binding.eval（'self'）", "name": "stress=", "namespace": "GC", "path": "GC.stress=", "type": "module_function", "visibility": "public"}, "GC.verify_internal_consistency": {"description": "tracepoint.new（事件）{ }→| | obj对象块N TracePoint归来的新对象，逆境中默认启用。N阶下，激活微量使用，你必须使TracePoint # N =（呼叫跟踪TracePoint.new）做| TP | \n    p [tp.lineno, tp.defined_class, tp.method_id, tp.event]\nend #=> #<TracePoint:disabled> trace.enable N N N #=> false \\“你好，让TracePoint！”n #…n #〔48，IRB插件：：：：：：调用printf，AbstractNotifier，\\n # ]……N，当你想deactivate微量使用，你必须禁用TracePoint # N N TracePoint trace.disable湖”事件的可能事件和更多的信息。N一块必须考虑到，否则ArgumentError是提出。N示踪法，如果不包括在给定的事件过滤器，一RuntimeError是提出。TracePoint.trace（N线）做| TP | \n    p tp.raised_exception\nend #=> RuntimeError: 'raised_exception' not supported by this event N示踪方法是所谓的，如果A是提出RuntimeError外块。\n     TracePoint.trace(:line) do |tp|\n       $tp = tp\n     end\n     $tp.lineno #=> access from outside (RuntimeError)\n \\n \\n从其他线程访问是禁止的。", "name": "verify_internal_consistency", "namespace": "GC", "path": "GC.verify_internal_consistency", "type": "module_function", "visibility": "public"}, "GC::INTERNAL_CONSTANTS": {"description": "", "name": "INTERNAL_CONSTANTS", "namespace": "GC", "path": "GC::INTERNAL_CONSTANTS", "type": "constant", "return": ["Hash", ""], "visibility": "public"}, "GC::OPTS": {"description": "", "name": "OPTS", "namespace": "GC", "path": "GC::OPTS", "type": "constant", "return": ["Array", ""], "visibility": "public"}, "GC::Profiler": {"description": "", "name": "Profiler", "namespace": "GC", "path": "GC::Profiler", "type": "module", "visibility": "public"}, "GC::Profiler.clear": {"description": "obj tracepoint.stat＞N学院内部信息TracePoint归来。N值的内容是执行返回的特异性。n它可能在未来改变。N本法是唯一的TracePoint调试本身。", "name": "clear", "namespace": "GC::Profiler", "path": "GC::Profiler.clear", "type": "module_function", "visibility": "public"}, "GC::Profiler.disable": {"description": "呼叫一个TracePoint.trace：\\n（事件）{ }→| | obj对象块N A TracePoint.new便利方法是微量\\n自动启动。    trace.enabled? #=> true \n    trace = TracePoint.trace(:call) { |tp| [tp.lineno, tp.event] }\n    #=> #<TracePoint:enabled>\n \\n \\n", "name": "disable", "namespace": "GC::Profiler", "path": "GC::Profiler.disable", "type": "module_function", "visibility": "public"}, "GC::Profiler.enable": {"description": "模块包含模块的数学函数的基本trigonometric和超越函数。海上浮动列表类是Ruby常数定义的浮点精度。N是一个给定的域和codomains只有真正的数字（不复杂）。", "name": "enable", "namespace": "GC::Profiler", "path": "GC::Profiler.enable", "type": "module_function", "visibility": "public"}, "GC::Profiler.enabled?": {"description": "在气相色谱接口模块可以对红宝石的标记与扫垃圾收集机制。N是一个优先的方法以ObjectSpace \\n模块。N你可能获得的信息通过一个操作：GC GC测量。", "name": "enabled?", "namespace": "GC::Profiler", "path": "GC::Profiler.enabled?", "type": "module_function", "visibility": "public", "return": [["Boolean"], ""]}, "GC::Profiler.raw_data": {"description": "initiates垃圾收集，除非手动关闭。N是定义本法与关键字参数，默认是真实的：\\n \\n使用全\n   def GC.start(full_mark: true, immediate_sweep: true); end\n _马克：FALSE将小到GC。\\n：FALSE使用引用他们即刻_扫到（使用懒惰的扫掠。N注：论文的论点是实施和版本相关的关键字。他们是不是未来的保证是兼容的，和可能被忽略，如果优先执行不支持他们。", "name": "raw_data", "namespace": "GC::Profiler", "path": "GC::Profiler.raw_data", "type": "module_function", "visibility": "public"}, "GC::Profiler.report": {"description": "时代发生的相数。它返回N数时代因为GC过程开始时发生的。", "name": "report", "namespace": "GC::Profiler", "path": "GC::Profiler.report", "type": "module_function", "visibility": "public"}, "GC::Profiler.result": {"description": "disables垃圾收集的垃圾收集，如果返回的+true+已经禁用。\n   GC.disable   #=> false\n   GC.disable   #=> true \\n", "name": "result", "namespace": "GC::Profiler", "path": "GC::Profiler.result", "type": "module_function", "visibility": "public"}, "GC::Profiler.total_time": {"description": "如果您的垃圾收集，垃圾收集是+true+返回以前的残疾人。\n   GC.disable   #=> false\n   GC.enable    #=> true\n   GC.enable    #=> false \\n", "name": "total_time", "namespace": "GC::Profiler", "path": "GC::Profiler.total_time", "type": "module_function", "visibility": "public"}}